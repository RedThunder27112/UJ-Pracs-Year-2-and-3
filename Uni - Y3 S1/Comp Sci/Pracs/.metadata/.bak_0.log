!SESSION 2023-02-22 12:11:37.868 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_ZA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-02-22 12:12:11.529
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-02-22 12:12:11.529
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-02-22 12:12:11.529
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-02-22 12:12:19.042
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\redth'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-02-23 12:57:59.369 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_ZA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-02-23 12:58:24.413
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-02-23 12:58:24.413
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-02-23 12:58:24.413
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-02-23 12:58:29.576
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\redth'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 1006 2023-02-23 13:00:53.715
!MESSAGE <module:java.management.rmi> is not on its project's build path

!ENTRY org.eclipse.jdt.core 4 1006 2023-02-23 13:00:53.716
!MESSAGE <module:java.naming> is not on its project's build path

!ENTRY org.eclipse.jdt.core 4 1006 2023-02-23 13:00:53.717
!MESSAGE <module:java.scripting> is not on its project's build path

!ENTRY org.eclipse.jdt.core 4 1006 2023-02-23 13:00:53.717
!MESSAGE <module:java.security.sasl> is not on its project's build path

!ENTRY org.eclipse.jdt.core 4 1006 2023-02-23 13:00:53.718
!MESSAGE <module:java.sql.rowset> is not on its project's build path

!ENTRY org.eclipse.jdt.core 4 1006 2023-02-23 13:00:53.719
!MESSAGE <module:java.xml.crypto> is not on its project's build path

!ENTRY org.eclipse.jdt.core 4 1006 2023-02-23 13:00:53.720
!MESSAGE <module:java.compiler> is not on its project's build path

!ENTRY org.eclipse.jdt.core 4 1006 2023-02-23 13:00:53.720
!MESSAGE <module:java.security.jgss> is not on its project's build path

!ENTRY org.eclipse.jdt.core 4 1006 2023-02-23 13:00:53.721
!MESSAGE <module:java.smartcardio> is not on its project's build path

!ENTRY org.eclipse.jdt.core 4 1006 2023-02-23 13:00:53.722
!MESSAGE <module:java.se> is not on its project's build path

!ENTRY org.eclipse.ui 4 4 2023-02-23 13:00:54.528
!MESSAGE To avoid deadlock while executing Display.syncExec() with argument: org.eclipse.jdt.internal.ui.wizards.buildpaths.BuildPathsBlock$$Lambda$1119/0x0000000100dded90@2386e23, thread ModalContext will interrupt UI thread.
!SUBENTRY 1 org.eclipse.ui 4 4 2023-02-23 13:00:54.528
!MESSAGE ModalContext thread is an instance of Worker or owns an ILock
!STACK 0
java.lang.IllegalStateException: Call stack for thread ModalContext
	at java.management@17.0.4.1/sun.management.ThreadImpl.dumpThreads0(Native Method)
	at java.management@17.0.4.1/sun.management.ThreadImpl.getThreadInfo(ThreadImpl.java:485)
	at org.eclipse.ui.internal.UILockListener.reportInterruption(UILockListener.java:214)
	at org.eclipse.ui.internal.UILockListener.interruptUI(UILockListener.java:180)
	at org.eclipse.ui.internal.PendingSyncExec.waitUntilExecuted(PendingSyncExec.java:92)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:142)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4792)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.BuildPathsBlock.lambda$1(BuildPathsBlock.java:966)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.BuildPathsBlock$$Lambda$1118/0x0000000100ddeb70.doQuery(Unknown Source)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.BuildPathsBlock.flush(BuildPathsBlock.java:807)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.BuildPathsBlock.configureJavaProject(BuildPathsBlock.java:758)
	at org.eclipse.jdt.ui.wizards.JavaCapabilityConfigurationPage.configureJavaProject(JavaCapabilityConfigurationPage.java:283)
	at org.eclipse.jdt.ui.wizards.JavaCapabilityConfigurationPage.configureJavaProject(JavaCapabilityConfigurationPage.java:259)
	at org.eclipse.jdt.ui.wizards.NewJavaProjectWizardPageTwo.updateProject(NewJavaProjectWizardPageTwo.java:255)
	at org.eclipse.jdt.ui.wizards.NewJavaProjectWizardPageTwo$1UpdateRunnable.run(NewJavaProjectWizardPageTwo.java:163)
	at org.eclipse.ui.actions.WorkspaceModifyDelegatingOperation.execute(WorkspaceModifyDelegatingOperation.java:71)
	at org.eclipse.ui.actions.WorkspaceModifyOperation.lambda$0(WorkspaceModifyOperation.java:110)
	at org.eclipse.ui.actions.WorkspaceModifyOperation$$Lambda$1108/0x0000000100bf53f0.run(Unknown Source)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2380)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2405)
	at org.eclipse.ui.actions.WorkspaceModifyOperation.run(WorkspaceModifyOperation.java:131)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)
!SUBENTRY 1 org.eclipse.ui 4 4 2023-02-23 13:00:54.528
!MESSAGE UI thread waiting on a job or lock.
!STACK 0
java.lang.IllegalStateException: Call stack for thread main
	at org.eclipse.swt.internal.win32.OS.WaitMessage(Native Method)
	at org.eclipse.swt.widgets.Display.sleep(Display.java:4759)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:824)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.jface.dialogs.MessageDialog.open(MessageDialog.java:609)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.BuildPathsBlock.lambda$2(BuildPathsBlock.java:977)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.BuildPathsBlock$$Lambda$1119/0x0000000100dded90.run(Unknown Source)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:172)
	at org.eclipse.ui.internal.UISynchronizer$$Lambda$1047/0x0000000100b8daa8.run(Unknown Source)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:132)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4043)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3648)
	at org.eclipse.ui.internal.dialogs.EventLoopProgressMonitor.runEventLoop(EventLoopProgressMonitor.java:126)
	at org.eclipse.ui.internal.dialogs.EventLoopProgressMonitor.isCanceled(EventLoopProgressMonitor.java:100)
	at org.eclipse.core.internal.jobs.ThreadJob.isCanceled(ThreadJob.java:148)
	at org.eclipse.core.internal.jobs.ThreadJob.waitForRun(ThreadJob.java:280)
	at org.eclipse.core.internal.jobs.ThreadJob.joinRun(ThreadJob.java:208)
	at org.eclipse.core.internal.jobs.ImplicitJobs.begin(ImplicitJobs.java:95)
	at org.eclipse.core.internal.jobs.JobManager.beginRule(JobManager.java:315)
	at org.eclipse.core.internal.resources.WorkManager.checkIn(WorkManager.java:124)
	at org.eclipse.core.internal.resources.Workspace.prepareOperation(Workspace.java:2330)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2375)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2405)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.newsourcepage.DialogPackageExplorer.setSelection(DialogPackageExplorer.java:451)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.newsourcepage.DialogPackageExplorer.setInput(DialogPackageExplorer.java:428)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.newsourcepage.NewSourceContainerWorkbookPage.doUpdateUI(NewSourceContainerWorkbookPage.java:137)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.newsourcepage.NewSourceContainerWorkbookPage$$Lambda$1112/0x0000000100dddec0.run(Unknown Source)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:132)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4043)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3648)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.block(ModalContext.java:166)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:368)
	at org.eclipse.jface.wizard.WizardDialog.run(WizardDialog.java:1034)
	at org.eclipse.jdt.ui.wizards.NewJavaProjectWizardPageTwo.changeToNewProject(NewJavaProjectWizardPageTwo.java:175)
	at org.eclipse.jdt.ui.wizards.NewJavaProjectWizardPageTwo.createProvisonalProject(NewJavaProjectWizardPageTwo.java:482)
	at org.eclipse.jdt.ui.wizards.NewJavaProjectWizardPageTwo.setVisible(NewJavaProjectWizardPageTwo.java:133)
	at org.eclipse.jface.wizard.WizardDialog.updateForPage(WizardDialog.java:1253)
	at org.eclipse.jface.wizard.WizardDialog.lambda$3(WizardDialog.java:1223)
	at org.eclipse.jface.wizard.WizardDialog$$Lambda$1106/0x0000000100db7990.run(Unknown Source)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jface.wizard.WizardDialog.showPage(WizardDialog.java:1223)
	at org.eclipse.jface.wizard.WizardDialog.nextPressed(WizardDialog.java:918)
	at org.eclipse.jface.wizard.WizardDialog.buttonPressed(WizardDialog.java:469)
	at org.eclipse.jface.dialogs.Dialog.lambda$0(Dialog.java:619)
	at org.eclipse.jface.dialogs.Dialog$$Lambda$231/0x0000000100321548.accept(Unknown Source)
	at org.eclipse.swt.events.SelectionListener$1.widgetSelected(SelectionListener.java:84)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:252)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4068)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:823)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.ui.internal.actions.NewWizardShortcutAction.run(NewWizardShortcutAction.java:130)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.jface.action.ActionContributionItem$$Lambda$535/0x0000000100653d88.handleEvent(Unknown Source)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4068)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.ui.internal.Workbench$$Lambda$271/0x00000001002c5550.run(Unknown Source)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base@17.0.4.1/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base@17.0.4.1/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base@17.0.4.1/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base@17.0.4.1/java.lang.reflect.Method.invoke(Method.java:568)
	at app//org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at app//org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at app//org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui 4 4 2023-02-23 13:00:55.562
!MESSAGE To avoid deadlock while executing Display.syncExec() with argument: org.eclipse.jdt.internal.ui.wizards.buildpaths.BuildPathsBlock$$Lambda$1119/0x0000000100dded90@2386e23, thread ModalContext will interrupt UI thread.
!SUBENTRY 1 org.eclipse.ui 4 4 2023-02-23 13:00:55.562
!MESSAGE ModalContext thread is an instance of Worker or owns an ILock
!STACK 0
java.lang.IllegalStateException: Call stack for thread ModalContext
	at java.management@17.0.4.1/sun.management.ThreadImpl.dumpThreads0(Native Method)
	at java.management@17.0.4.1/sun.management.ThreadImpl.getThreadInfo(ThreadImpl.java:485)
	at org.eclipse.ui.internal.UILockListener.reportInterruption(UILockListener.java:214)
	at org.eclipse.ui.internal.UILockListener.interruptUI(UILockListener.java:180)
	at org.eclipse.ui.internal.PendingSyncExec.waitUntilExecuted(PendingSyncExec.java:92)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:142)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4792)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.BuildPathsBlock.lambda$1(BuildPathsBlock.java:966)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.BuildPathsBlock$$Lambda$1118/0x0000000100ddeb70.doQuery(Unknown Source)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.BuildPathsBlock.flush(BuildPathsBlock.java:807)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.BuildPathsBlock.configureJavaProject(BuildPathsBlock.java:758)
	at org.eclipse.jdt.ui.wizards.JavaCapabilityConfigurationPage.configureJavaProject(JavaCapabilityConfigurationPage.java:283)
	at org.eclipse.jdt.ui.wizards.JavaCapabilityConfigurationPage.configureJavaProject(JavaCapabilityConfigurationPage.java:259)
	at org.eclipse.jdt.ui.wizards.NewJavaProjectWizardPageTwo.updateProject(NewJavaProjectWizardPageTwo.java:255)
	at org.eclipse.jdt.ui.wizards.NewJavaProjectWizardPageTwo$1UpdateRunnable.run(NewJavaProjectWizardPageTwo.java:163)
	at org.eclipse.ui.actions.WorkspaceModifyDelegatingOperation.execute(WorkspaceModifyDelegatingOperation.java:71)
	at org.eclipse.ui.actions.WorkspaceModifyOperation.lambda$0(WorkspaceModifyOperation.java:110)
	at org.eclipse.ui.actions.WorkspaceModifyOperation$$Lambda$1108/0x0000000100bf53f0.run(Unknown Source)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2380)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2405)
	at org.eclipse.ui.actions.WorkspaceModifyOperation.run(WorkspaceModifyOperation.java:131)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)
!SUBENTRY 1 org.eclipse.ui 4 4 2023-02-23 13:00:55.562
!MESSAGE UI thread waiting on a job or lock.
!STACK 0
java.lang.IllegalStateException: Call stack for thread main
	at org.eclipse.swt.internal.win32.OS.WaitMessage(Native Method)
	at org.eclipse.swt.widgets.Display.sleep(Display.java:4759)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:824)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.jface.dialogs.MessageDialog.open(MessageDialog.java:609)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.BuildPathsBlock.lambda$2(BuildPathsBlock.java:977)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.BuildPathsBlock$$Lambda$1119/0x0000000100dded90.run(Unknown Source)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:172)
	at org.eclipse.ui.internal.UISynchronizer$$Lambda$1047/0x0000000100b8daa8.run(Unknown Source)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:132)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4043)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3648)
	at org.eclipse.ui.internal.dialogs.EventLoopProgressMonitor.runEventLoop(EventLoopProgressMonitor.java:126)
	at org.eclipse.ui.internal.dialogs.EventLoopProgressMonitor.isCanceled(EventLoopProgressMonitor.java:100)
	at org.eclipse.core.internal.jobs.ThreadJob.isCanceled(ThreadJob.java:148)
	at org.eclipse.core.internal.jobs.ThreadJob.waitForRun(ThreadJob.java:280)
	at org.eclipse.core.internal.jobs.ThreadJob.joinRun(ThreadJob.java:208)
	at org.eclipse.core.internal.jobs.ImplicitJobs.begin(ImplicitJobs.java:95)
	at org.eclipse.core.internal.jobs.JobManager.beginRule(JobManager.java:315)
	at org.eclipse.core.internal.resources.WorkManager.checkIn(WorkManager.java:124)
	at org.eclipse.core.internal.resources.Workspace.prepareOperation(Workspace.java:2330)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2375)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2405)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.newsourcepage.DialogPackageExplorer.setSelection(DialogPackageExplorer.java:451)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.newsourcepage.DialogPackageExplorer.setInput(DialogPackageExplorer.java:428)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.newsourcepage.NewSourceContainerWorkbookPage.doUpdateUI(NewSourceContainerWorkbookPage.java:137)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.newsourcepage.NewSourceContainerWorkbookPage$$Lambda$1112/0x0000000100dddec0.run(Unknown Source)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:132)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4043)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3648)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.block(ModalContext.java:166)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:368)
	at org.eclipse.jface.wizard.WizardDialog.run(WizardDialog.java:1034)
	at org.eclipse.jdt.ui.wizards.NewJavaProjectWizardPageTwo.changeToNewProject(NewJavaProjectWizardPageTwo.java:175)
	at org.eclipse.jdt.ui.wizards.NewJavaProjectWizardPageTwo.createProvisonalProject(NewJavaProjectWizardPageTwo.java:482)
	at org.eclipse.jdt.ui.wizards.NewJavaProjectWizardPageTwo.setVisible(NewJavaProjectWizardPageTwo.java:133)
	at org.eclipse.jface.wizard.WizardDialog.updateForPage(WizardDialog.java:1253)
	at org.eclipse.jface.wizard.WizardDialog.lambda$3(WizardDialog.java:1223)
	at org.eclipse.jface.wizard.WizardDialog$$Lambda$1106/0x0000000100db7990.run(Unknown Source)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jface.wizard.WizardDialog.showPage(WizardDialog.java:1223)
	at org.eclipse.jface.wizard.WizardDialog.nextPressed(WizardDialog.java:918)
	at org.eclipse.jface.wizard.WizardDialog.buttonPressed(WizardDialog.java:469)
	at org.eclipse.jface.dialogs.Dialog.lambda$0(Dialog.java:619)
	at org.eclipse.jface.dialogs.Dialog$$Lambda$231/0x0000000100321548.accept(Unknown Source)
	at org.eclipse.swt.events.SelectionListener$1.widgetSelected(SelectionListener.java:84)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:252)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4068)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:823)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.ui.internal.actions.NewWizardShortcutAction.run(NewWizardShortcutAction.java:130)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.jface.action.ActionContributionItem$$Lambda$535/0x0000000100653d88.handleEvent(Unknown Source)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4068)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.ui.internal.Workbench$$Lambda$271/0x00000001002c5550.run(Unknown Source)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base@17.0.4.1/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base@17.0.4.1/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base@17.0.4.1/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base@17.0.4.1/java.lang.reflect.Method.invoke(Method.java:568)
	at app//org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at app//org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at app//org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui 4 4 2023-02-23 13:00:56.598
!MESSAGE To avoid deadlock while executing Display.syncExec() with argument: org.eclipse.jdt.internal.ui.wizards.buildpaths.BuildPathsBlock$$Lambda$1119/0x0000000100dded90@2386e23, thread ModalContext will interrupt UI thread.
!SUBENTRY 1 org.eclipse.ui 4 4 2023-02-23 13:00:56.598
!MESSAGE ModalContext thread is an instance of Worker or owns an ILock
!STACK 0
java.lang.IllegalStateException: Call stack for thread ModalContext
	at java.management@17.0.4.1/sun.management.ThreadImpl.dumpThreads0(Native Method)
	at java.management@17.0.4.1/sun.management.ThreadImpl.getThreadInfo(ThreadImpl.java:485)
	at org.eclipse.ui.internal.UILockListener.reportInterruption(UILockListener.java:214)
	at org.eclipse.ui.internal.UILockListener.interruptUI(UILockListener.java:180)
	at org.eclipse.ui.internal.PendingSyncExec.waitUntilExecuted(PendingSyncExec.java:92)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:142)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4792)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.BuildPathsBlock.lambda$1(BuildPathsBlock.java:966)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.BuildPathsBlock$$Lambda$1118/0x0000000100ddeb70.doQuery(Unknown Source)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.BuildPathsBlock.flush(BuildPathsBlock.java:807)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.BuildPathsBlock.configureJavaProject(BuildPathsBlock.java:758)
	at org.eclipse.jdt.ui.wizards.JavaCapabilityConfigurationPage.configureJavaProject(JavaCapabilityConfigurationPage.java:283)
	at org.eclipse.jdt.ui.wizards.JavaCapabilityConfigurationPage.configureJavaProject(JavaCapabilityConfigurationPage.java:259)
	at org.eclipse.jdt.ui.wizards.NewJavaProjectWizardPageTwo.updateProject(NewJavaProjectWizardPageTwo.java:255)
	at org.eclipse.jdt.ui.wizards.NewJavaProjectWizardPageTwo$1UpdateRunnable.run(NewJavaProjectWizardPageTwo.java:163)
	at org.eclipse.ui.actions.WorkspaceModifyDelegatingOperation.execute(WorkspaceModifyDelegatingOperation.java:71)
	at org.eclipse.ui.actions.WorkspaceModifyOperation.lambda$0(WorkspaceModifyOperation.java:110)
	at org.eclipse.ui.actions.WorkspaceModifyOperation$$Lambda$1108/0x0000000100bf53f0.run(Unknown Source)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2380)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2405)
	at org.eclipse.ui.actions.WorkspaceModifyOperation.run(WorkspaceModifyOperation.java:131)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)
!SUBENTRY 1 org.eclipse.ui 4 4 2023-02-23 13:00:56.599
!MESSAGE UI thread waiting on a job or lock.
!STACK 0
java.lang.IllegalStateException: Call stack for thread main
	at org.eclipse.swt.internal.win32.OS.WaitMessage(Native Method)
	at org.eclipse.swt.widgets.Display.sleep(Display.java:4759)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:824)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.jface.dialogs.MessageDialog.open(MessageDialog.java:609)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.BuildPathsBlock.lambda$2(BuildPathsBlock.java:977)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.BuildPathsBlock$$Lambda$1119/0x0000000100dded90.run(Unknown Source)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:172)
	at org.eclipse.ui.internal.UISynchronizer$$Lambda$1047/0x0000000100b8daa8.run(Unknown Source)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:132)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4043)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3648)
	at org.eclipse.ui.internal.dialogs.EventLoopProgressMonitor.runEventLoop(EventLoopProgressMonitor.java:126)
	at org.eclipse.ui.internal.dialogs.EventLoopProgressMonitor.isCanceled(EventLoopProgressMonitor.java:100)
	at org.eclipse.core.internal.jobs.ThreadJob.isCanceled(ThreadJob.java:148)
	at org.eclipse.core.internal.jobs.ThreadJob.waitForRun(ThreadJob.java:280)
	at org.eclipse.core.internal.jobs.ThreadJob.joinRun(ThreadJob.java:208)
	at org.eclipse.core.internal.jobs.ImplicitJobs.begin(ImplicitJobs.java:95)
	at org.eclipse.core.internal.jobs.JobManager.beginRule(JobManager.java:315)
	at org.eclipse.core.internal.resources.WorkManager.checkIn(WorkManager.java:124)
	at org.eclipse.core.internal.resources.Workspace.prepareOperation(Workspace.java:2330)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2375)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2405)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.newsourcepage.DialogPackageExplorer.setSelection(DialogPackageExplorer.java:451)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.newsourcepage.DialogPackageExplorer.setInput(DialogPackageExplorer.java:428)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.newsourcepage.NewSourceContainerWorkbookPage.doUpdateUI(NewSourceContainerWorkbookPage.java:137)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.newsourcepage.NewSourceContainerWorkbookPage$$Lambda$1112/0x0000000100dddec0.run(Unknown Source)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:132)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4043)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3648)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.block(ModalContext.java:166)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:368)
	at org.eclipse.jface.wizard.WizardDialog.run(WizardDialog.java:1034)
	at org.eclipse.jdt.ui.wizards.NewJavaProjectWizardPageTwo.changeToNewProject(NewJavaProjectWizardPageTwo.java:175)
	at org.eclipse.jdt.ui.wizards.NewJavaProjectWizardPageTwo.createProvisonalProject(NewJavaProjectWizardPageTwo.java:482)
	at org.eclipse.jdt.ui.wizards.NewJavaProjectWizardPageTwo.setVisible(NewJavaProjectWizardPageTwo.java:133)
	at org.eclipse.jface.wizard.WizardDialog.updateForPage(WizardDialog.java:1253)
	at org.eclipse.jface.wizard.WizardDialog.lambda$3(WizardDialog.java:1223)
	at org.eclipse.jface.wizard.WizardDialog$$Lambda$1106/0x0000000100db7990.run(Unknown Source)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jface.wizard.WizardDialog.showPage(WizardDialog.java:1223)
	at org.eclipse.jface.wizard.WizardDialog.nextPressed(WizardDialog.java:918)
	at org.eclipse.jface.wizard.WizardDialog.buttonPressed(WizardDialog.java:469)
	at org.eclipse.jface.dialogs.Dialog.lambda$0(Dialog.java:619)
	at org.eclipse.jface.dialogs.Dialog$$Lambda$231/0x0000000100321548.accept(Unknown Source)
	at org.eclipse.swt.events.SelectionListener$1.widgetSelected(SelectionListener.java:84)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:252)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4068)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:823)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.ui.internal.actions.NewWizardShortcutAction.run(NewWizardShortcutAction.java:130)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.jface.action.ActionContributionItem$$Lambda$535/0x0000000100653d88.handleEvent(Unknown Source)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4068)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.ui.internal.Workbench$$Lambda$271/0x00000001002c5550.run(Unknown Source)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base@17.0.4.1/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base@17.0.4.1/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base@17.0.4.1/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base@17.0.4.1/java.lang.reflect.Method.invoke(Method.java:568)
	at app//org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at app//org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at app//org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui 4 4 2023-02-23 13:00:57.632
!MESSAGE To avoid deadlock while executing Display.syncExec() with argument: org.eclipse.jdt.internal.ui.wizards.buildpaths.BuildPathsBlock$$Lambda$1119/0x0000000100dded90@2386e23, thread ModalContext will interrupt UI thread.
!SUBENTRY 1 org.eclipse.ui 4 4 2023-02-23 13:00:57.632
!MESSAGE ModalContext thread is an instance of Worker or owns an ILock
!STACK 0
java.lang.IllegalStateException: Call stack for thread ModalContext
	at java.management@17.0.4.1/sun.management.ThreadImpl.dumpThreads0(Native Method)
	at java.management@17.0.4.1/sun.management.ThreadImpl.getThreadInfo(ThreadImpl.java:485)
	at org.eclipse.ui.internal.UILockListener.reportInterruption(UILockListener.java:214)
	at org.eclipse.ui.internal.UILockListener.interruptUI(UILockListener.java:180)
	at org.eclipse.ui.internal.PendingSyncExec.waitUntilExecuted(PendingSyncExec.java:92)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:142)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4792)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.BuildPathsBlock.lambda$1(BuildPathsBlock.java:966)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.BuildPathsBlock$$Lambda$1118/0x0000000100ddeb70.doQuery(Unknown Source)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.BuildPathsBlock.flush(BuildPathsBlock.java:807)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.BuildPathsBlock.configureJavaProject(BuildPathsBlock.java:758)
	at org.eclipse.jdt.ui.wizards.JavaCapabilityConfigurationPage.configureJavaProject(JavaCapabilityConfigurationPage.java:283)
	at org.eclipse.jdt.ui.wizards.JavaCapabilityConfigurationPage.configureJavaProject(JavaCapabilityConfigurationPage.java:259)
	at org.eclipse.jdt.ui.wizards.NewJavaProjectWizardPageTwo.updateProject(NewJavaProjectWizardPageTwo.java:255)
	at org.eclipse.jdt.ui.wizards.NewJavaProjectWizardPageTwo$1UpdateRunnable.run(NewJavaProjectWizardPageTwo.java:163)
	at org.eclipse.ui.actions.WorkspaceModifyDelegatingOperation.execute(WorkspaceModifyDelegatingOperation.java:71)
	at org.eclipse.ui.actions.WorkspaceModifyOperation.lambda$0(WorkspaceModifyOperation.java:110)
	at org.eclipse.ui.actions.WorkspaceModifyOperation$$Lambda$1108/0x0000000100bf53f0.run(Unknown Source)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2380)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2405)
	at org.eclipse.ui.actions.WorkspaceModifyOperation.run(WorkspaceModifyOperation.java:131)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)
!SUBENTRY 1 org.eclipse.ui 4 4 2023-02-23 13:00:57.633
!MESSAGE UI thread waiting on a job or lock.
!STACK 0
java.lang.IllegalStateException: Call stack for thread main
	at org.eclipse.swt.internal.win32.OS.WaitMessage(Native Method)
	at org.eclipse.swt.widgets.Display.sleep(Display.java:4759)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:824)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.jface.dialogs.MessageDialog.open(MessageDialog.java:609)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.BuildPathsBlock.lambda$2(BuildPathsBlock.java:977)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.BuildPathsBlock$$Lambda$1119/0x0000000100dded90.run(Unknown Source)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:172)
	at org.eclipse.ui.internal.UISynchronizer$$Lambda$1047/0x0000000100b8daa8.run(Unknown Source)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:132)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4043)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3648)
	at org.eclipse.ui.internal.dialogs.EventLoopProgressMonitor.runEventLoop(EventLoopProgressMonitor.java:126)
	at org.eclipse.ui.internal.dialogs.EventLoopProgressMonitor.isCanceled(EventLoopProgressMonitor.java:100)
	at org.eclipse.core.internal.jobs.ThreadJob.isCanceled(ThreadJob.java:148)
	at org.eclipse.core.internal.jobs.ThreadJob.waitForRun(ThreadJob.java:280)
	at org.eclipse.core.internal.jobs.ThreadJob.joinRun(ThreadJob.java:208)
	at org.eclipse.core.internal.jobs.ImplicitJobs.begin(ImplicitJobs.java:95)
	at org.eclipse.core.internal.jobs.JobManager.beginRule(JobManager.java:315)
	at org.eclipse.core.internal.resources.WorkManager.checkIn(WorkManager.java:124)
	at org.eclipse.core.internal.resources.Workspace.prepareOperation(Workspace.java:2330)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2375)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2405)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.newsourcepage.DialogPackageExplorer.setSelection(DialogPackageExplorer.java:451)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.newsourcepage.DialogPackageExplorer.setInput(DialogPackageExplorer.java:428)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.newsourcepage.NewSourceContainerWorkbookPage.doUpdateUI(NewSourceContainerWorkbookPage.java:137)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.newsourcepage.NewSourceContainerWorkbookPage$$Lambda$1112/0x0000000100dddec0.run(Unknown Source)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:132)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4043)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3648)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.block(ModalContext.java:166)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:368)
	at org.eclipse.jface.wizard.WizardDialog.run(WizardDialog.java:1034)
	at org.eclipse.jdt.ui.wizards.NewJavaProjectWizardPageTwo.changeToNewProject(NewJavaProjectWizardPageTwo.java:175)
	at org.eclipse.jdt.ui.wizards.NewJavaProjectWizardPageTwo.createProvisonalProject(NewJavaProjectWizardPageTwo.java:482)
	at org.eclipse.jdt.ui.wizards.NewJavaProjectWizardPageTwo.setVisible(NewJavaProjectWizardPageTwo.java:133)
	at org.eclipse.jface.wizard.WizardDialog.updateForPage(WizardDialog.java:1253)
	at org.eclipse.jface.wizard.WizardDialog.lambda$3(WizardDialog.java:1223)
	at org.eclipse.jface.wizard.WizardDialog$$Lambda$1106/0x0000000100db7990.run(Unknown Source)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jface.wizard.WizardDialog.showPage(WizardDialog.java:1223)
	at org.eclipse.jface.wizard.WizardDialog.nextPressed(WizardDialog.java:918)
	at org.eclipse.jface.wizard.WizardDialog.buttonPressed(WizardDialog.java:469)
	at org.eclipse.jface.dialogs.Dialog.lambda$0(Dialog.java:619)
	at org.eclipse.jface.dialogs.Dialog$$Lambda$231/0x0000000100321548.accept(Unknown Source)
	at org.eclipse.swt.events.SelectionListener$1.widgetSelected(SelectionListener.java:84)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:252)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4068)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:823)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.ui.internal.actions.NewWizardShortcutAction.run(NewWizardShortcutAction.java:130)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.jface.action.ActionContributionItem$$Lambda$535/0x0000000100653d88.handleEvent(Unknown Source)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4068)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.ui.internal.Workbench$$Lambda$271/0x00000001002c5550.run(Unknown Source)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base@17.0.4.1/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base@17.0.4.1/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base@17.0.4.1/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base@17.0.4.1/java.lang.reflect.Method.invoke(Method.java:568)
	at app//org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at app//org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at app//org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui 4 4 2023-02-23 13:00:58.668
!MESSAGE To avoid deadlock while executing Display.syncExec() with argument: org.eclipse.jdt.internal.ui.wizards.buildpaths.BuildPathsBlock$$Lambda$1119/0x0000000100dded90@2386e23, thread ModalContext will interrupt UI thread.
!SUBENTRY 1 org.eclipse.ui 4 4 2023-02-23 13:00:58.668
!MESSAGE ModalContext thread is an instance of Worker or owns an ILock
!STACK 0
java.lang.IllegalStateException: Call stack for thread ModalContext
	at java.management@17.0.4.1/sun.management.ThreadImpl.dumpThreads0(Native Method)
	at java.management@17.0.4.1/sun.management.ThreadImpl.getThreadInfo(ThreadImpl.java:485)
	at org.eclipse.ui.internal.UILockListener.reportInterruption(UILockListener.java:214)
	at org.eclipse.ui.internal.UILockListener.interruptUI(UILockListener.java:180)
	at org.eclipse.ui.internal.PendingSyncExec.waitUntilExecuted(PendingSyncExec.java:92)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:142)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4792)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.BuildPathsBlock.lambda$1(BuildPathsBlock.java:966)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.BuildPathsBlock$$Lambda$1118/0x0000000100ddeb70.doQuery(Unknown Source)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.BuildPathsBlock.flush(BuildPathsBlock.java:807)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.BuildPathsBlock.configureJavaProject(BuildPathsBlock.java:758)
	at org.eclipse.jdt.ui.wizards.JavaCapabilityConfigurationPage.configureJavaProject(JavaCapabilityConfigurationPage.java:283)
	at org.eclipse.jdt.ui.wizards.JavaCapabilityConfigurationPage.configureJavaProject(JavaCapabilityConfigurationPage.java:259)
	at org.eclipse.jdt.ui.wizards.NewJavaProjectWizardPageTwo.updateProject(NewJavaProjectWizardPageTwo.java:255)
	at org.eclipse.jdt.ui.wizards.NewJavaProjectWizardPageTwo$1UpdateRunnable.run(NewJavaProjectWizardPageTwo.java:163)
	at org.eclipse.ui.actions.WorkspaceModifyDelegatingOperation.execute(WorkspaceModifyDelegatingOperation.java:71)
	at org.eclipse.ui.actions.WorkspaceModifyOperation.lambda$0(WorkspaceModifyOperation.java:110)
	at org.eclipse.ui.actions.WorkspaceModifyOperation$$Lambda$1108/0x0000000100bf53f0.run(Unknown Source)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2380)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2405)
	at org.eclipse.ui.actions.WorkspaceModifyOperation.run(WorkspaceModifyOperation.java:131)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)
!SUBENTRY 1 org.eclipse.ui 4 4 2023-02-23 13:00:58.668
!MESSAGE UI thread waiting on a job or lock.
!STACK 0
java.lang.IllegalStateException: Call stack for thread main
	at org.eclipse.swt.internal.win32.OS.WaitMessage(Native Method)
	at org.eclipse.swt.widgets.Display.sleep(Display.java:4759)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:824)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.jface.dialogs.MessageDialog.open(MessageDialog.java:609)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.BuildPathsBlock.lambda$2(BuildPathsBlock.java:977)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.BuildPathsBlock$$Lambda$1119/0x0000000100dded90.run(Unknown Source)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:172)
	at org.eclipse.ui.internal.UISynchronizer$$Lambda$1047/0x0000000100b8daa8.run(Unknown Source)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:132)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4043)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3648)
	at org.eclipse.ui.internal.dialogs.EventLoopProgressMonitor.runEventLoop(EventLoopProgressMonitor.java:126)
	at org.eclipse.ui.internal.dialogs.EventLoopProgressMonitor.isCanceled(EventLoopProgressMonitor.java:100)
	at org.eclipse.core.internal.jobs.ThreadJob.isCanceled(ThreadJob.java:148)
	at org.eclipse.core.internal.jobs.ThreadJob.waitForRun(ThreadJob.java:280)
	at org.eclipse.core.internal.jobs.ThreadJob.joinRun(ThreadJob.java:208)
	at org.eclipse.core.internal.jobs.ImplicitJobs.begin(ImplicitJobs.java:95)
	at org.eclipse.core.internal.jobs.JobManager.beginRule(JobManager.java:315)
	at org.eclipse.core.internal.resources.WorkManager.checkIn(WorkManager.java:124)
	at org.eclipse.core.internal.resources.Workspace.prepareOperation(Workspace.java:2330)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2375)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2405)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.newsourcepage.DialogPackageExplorer.setSelection(DialogPackageExplorer.java:451)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.newsourcepage.DialogPackageExplorer.setInput(DialogPackageExplorer.java:428)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.newsourcepage.NewSourceContainerWorkbookPage.doUpdateUI(NewSourceContainerWorkbookPage.java:137)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.newsourcepage.NewSourceContainerWorkbookPage$$Lambda$1112/0x0000000100dddec0.run(Unknown Source)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:132)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4043)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3648)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.block(ModalContext.java:166)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:368)
	at org.eclipse.jface.wizard.WizardDialog.run(WizardDialog.java:1034)
	at org.eclipse.jdt.ui.wizards.NewJavaProjectWizardPageTwo.changeToNewProject(NewJavaProjectWizardPageTwo.java:175)
	at org.eclipse.jdt.ui.wizards.NewJavaProjectWizardPageTwo.createProvisonalProject(NewJavaProjectWizardPageTwo.java:482)
	at org.eclipse.jdt.ui.wizards.NewJavaProjectWizardPageTwo.setVisible(NewJavaProjectWizardPageTwo.java:133)
	at org.eclipse.jface.wizard.WizardDialog.updateForPage(WizardDialog.java:1253)
	at org.eclipse.jface.wizard.WizardDialog.lambda$3(WizardDialog.java:1223)
	at org.eclipse.jface.wizard.WizardDialog$$Lambda$1106/0x0000000100db7990.run(Unknown Source)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jface.wizard.WizardDialog.showPage(WizardDialog.java:1223)
	at org.eclipse.jface.wizard.WizardDialog.nextPressed(WizardDialog.java:918)
	at org.eclipse.jface.wizard.WizardDialog.buttonPressed(WizardDialog.java:469)
	at org.eclipse.jface.dialogs.Dialog.lambda$0(Dialog.java:619)
	at org.eclipse.jface.dialogs.Dialog$$Lambda$231/0x0000000100321548.accept(Unknown Source)
	at org.eclipse.swt.events.SelectionListener$1.widgetSelected(SelectionListener.java:84)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:252)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4068)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:823)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.ui.internal.actions.NewWizardShortcutAction.run(NewWizardShortcutAction.java:130)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.jface.action.ActionContributionItem$$Lambda$535/0x0000000100653d88.handleEvent(Unknown Source)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4068)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.ui.internal.Workbench$$Lambda$271/0x00000001002c5550.run(Unknown Source)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base@17.0.4.1/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base@17.0.4.1/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base@17.0.4.1/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base@17.0.4.1/java.lang.reflect.Method.invoke(Method.java:568)
	at app//org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at app//org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at app//org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui 4 4 2023-02-23 13:00:59.707
!MESSAGE To avoid deadlock while executing Display.syncExec() with argument: org.eclipse.jdt.internal.ui.wizards.buildpaths.BuildPathsBlock$$Lambda$1119/0x0000000100dded90@2386e23, thread ModalContext will interrupt UI thread.
!SUBENTRY 1 org.eclipse.ui 4 4 2023-02-23 13:00:59.707
!MESSAGE ModalContext thread is an instance of Worker or owns an ILock
!STACK 0
java.lang.IllegalStateException: Call stack for thread ModalContext
	at java.management@17.0.4.1/sun.management.ThreadImpl.dumpThreads0(Native Method)
	at java.management@17.0.4.1/sun.management.ThreadImpl.getThreadInfo(ThreadImpl.java:485)
	at org.eclipse.ui.internal.UILockListener.reportInterruption(UILockListener.java:214)
	at org.eclipse.ui.internal.UILockListener.interruptUI(UILockListener.java:180)
	at org.eclipse.ui.internal.PendingSyncExec.waitUntilExecuted(PendingSyncExec.java:92)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:142)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4792)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.BuildPathsBlock.lambda$1(BuildPathsBlock.java:966)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.BuildPathsBlock$$Lambda$1118/0x0000000100ddeb70.doQuery(Unknown Source)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.BuildPathsBlock.flush(BuildPathsBlock.java:807)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.BuildPathsBlock.configureJavaProject(BuildPathsBlock.java:758)
	at org.eclipse.jdt.ui.wizards.JavaCapabilityConfigurationPage.configureJavaProject(JavaCapabilityConfigurationPage.java:283)
	at org.eclipse.jdt.ui.wizards.JavaCapabilityConfigurationPage.configureJavaProject(JavaCapabilityConfigurationPage.java:259)
	at org.eclipse.jdt.ui.wizards.NewJavaProjectWizardPageTwo.updateProject(NewJavaProjectWizardPageTwo.java:255)
	at org.eclipse.jdt.ui.wizards.NewJavaProjectWizardPageTwo$1UpdateRunnable.run(NewJavaProjectWizardPageTwo.java:163)
	at org.eclipse.ui.actions.WorkspaceModifyDelegatingOperation.execute(WorkspaceModifyDelegatingOperation.java:71)
	at org.eclipse.ui.actions.WorkspaceModifyOperation.lambda$0(WorkspaceModifyOperation.java:110)
	at org.eclipse.ui.actions.WorkspaceModifyOperation$$Lambda$1108/0x0000000100bf53f0.run(Unknown Source)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2380)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2405)
	at org.eclipse.ui.actions.WorkspaceModifyOperation.run(WorkspaceModifyOperation.java:131)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)
!SUBENTRY 1 org.eclipse.ui 4 4 2023-02-23 13:00:59.707
!MESSAGE UI thread waiting on a job or lock.
!STACK 0
java.lang.IllegalStateException: Call stack for thread main
	at org.eclipse.swt.internal.win32.OS.WaitMessage(Native Method)
	at org.eclipse.swt.widgets.Display.sleep(Display.java:4759)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:824)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.jface.dialogs.MessageDialog.open(MessageDialog.java:609)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.BuildPathsBlock.lambda$2(BuildPathsBlock.java:977)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.BuildPathsBlock$$Lambda$1119/0x0000000100dded90.run(Unknown Source)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:172)
	at org.eclipse.ui.internal.UISynchronizer$$Lambda$1047/0x0000000100b8daa8.run(Unknown Source)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:132)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4043)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3648)
	at org.eclipse.ui.internal.dialogs.EventLoopProgressMonitor.runEventLoop(EventLoopProgressMonitor.java:126)
	at org.eclipse.ui.internal.dialogs.EventLoopProgressMonitor.isCanceled(EventLoopProgressMonitor.java:100)
	at org.eclipse.core.internal.jobs.ThreadJob.isCanceled(ThreadJob.java:148)
	at org.eclipse.core.internal.jobs.ThreadJob.waitForRun(ThreadJob.java:280)
	at org.eclipse.core.internal.jobs.ThreadJob.joinRun(ThreadJob.java:208)
	at org.eclipse.core.internal.jobs.ImplicitJobs.begin(ImplicitJobs.java:95)
	at org.eclipse.core.internal.jobs.JobManager.beginRule(JobManager.java:315)
	at org.eclipse.core.internal.resources.WorkManager.checkIn(WorkManager.java:124)
	at org.eclipse.core.internal.resources.Workspace.prepareOperation(Workspace.java:2330)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2375)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2405)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.newsourcepage.DialogPackageExplorer.setSelection(DialogPackageExplorer.java:451)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.newsourcepage.DialogPackageExplorer.setInput(DialogPackageExplorer.java:428)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.newsourcepage.NewSourceContainerWorkbookPage.doUpdateUI(NewSourceContainerWorkbookPage.java:137)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.newsourcepage.NewSourceContainerWorkbookPage$$Lambda$1112/0x0000000100dddec0.run(Unknown Source)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:132)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4043)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3648)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.block(ModalContext.java:166)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:368)
	at org.eclipse.jface.wizard.WizardDialog.run(WizardDialog.java:1034)
	at org.eclipse.jdt.ui.wizards.NewJavaProjectWizardPageTwo.changeToNewProject(NewJavaProjectWizardPageTwo.java:175)
	at org.eclipse.jdt.ui.wizards.NewJavaProjectWizardPageTwo.createProvisonalProject(NewJavaProjectWizardPageTwo.java:482)
	at org.eclipse.jdt.ui.wizards.NewJavaProjectWizardPageTwo.setVisible(NewJavaProjectWizardPageTwo.java:133)
	at org.eclipse.jface.wizard.WizardDialog.updateForPage(WizardDialog.java:1253)
	at org.eclipse.jface.wizard.WizardDialog.lambda$3(WizardDialog.java:1223)
	at org.eclipse.jface.wizard.WizardDialog$$Lambda$1106/0x0000000100db7990.run(Unknown Source)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jface.wizard.WizardDialog.showPage(WizardDialog.java:1223)
	at org.eclipse.jface.wizard.WizardDialog.nextPressed(WizardDialog.java:918)
	at org.eclipse.jface.wizard.WizardDialog.buttonPressed(WizardDialog.java:469)
	at org.eclipse.jface.dialogs.Dialog.lambda$0(Dialog.java:619)
	at org.eclipse.jface.dialogs.Dialog$$Lambda$231/0x0000000100321548.accept(Unknown Source)
	at org.eclipse.swt.events.SelectionListener$1.widgetSelected(SelectionListener.java:84)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:252)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4068)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:823)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.ui.internal.actions.NewWizardShortcutAction.run(NewWizardShortcutAction.java:130)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.jface.action.ActionContributionItem$$Lambda$535/0x0000000100653d88.handleEvent(Unknown Source)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4068)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.ui.internal.Workbench$$Lambda$271/0x00000001002c5550.run(Unknown Source)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base@17.0.4.1/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base@17.0.4.1/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base@17.0.4.1/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base@17.0.4.1/java.lang.reflect.Method.invoke(Method.java:568)
	at app//org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at app//org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at app//org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui 4 4 2023-02-23 13:01:00.742
!MESSAGE To avoid deadlock while executing Display.syncExec() with argument: org.eclipse.jdt.internal.ui.wizards.buildpaths.BuildPathsBlock$$Lambda$1119/0x0000000100dded90@2386e23, thread ModalContext will interrupt UI thread.
!SUBENTRY 1 org.eclipse.ui 4 4 2023-02-23 13:01:00.742
!MESSAGE ModalContext thread is an instance of Worker or owns an ILock
!STACK 0
java.lang.IllegalStateException: Call stack for thread ModalContext
	at java.management@17.0.4.1/sun.management.ThreadImpl.dumpThreads0(Native Method)
	at java.management@17.0.4.1/sun.management.ThreadImpl.getThreadInfo(ThreadImpl.java:485)
	at org.eclipse.ui.internal.UILockListener.reportInterruption(UILockListener.java:214)
	at org.eclipse.ui.internal.UILockListener.interruptUI(UILockListener.java:180)
	at org.eclipse.ui.internal.PendingSyncExec.waitUntilExecuted(PendingSyncExec.java:92)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:142)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4792)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.BuildPathsBlock.lambda$1(BuildPathsBlock.java:966)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.BuildPathsBlock$$Lambda$1118/0x0000000100ddeb70.doQuery(Unknown Source)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.BuildPathsBlock.flush(BuildPathsBlock.java:807)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.BuildPathsBlock.configureJavaProject(BuildPathsBlock.java:758)
	at org.eclipse.jdt.ui.wizards.JavaCapabilityConfigurationPage.configureJavaProject(JavaCapabilityConfigurationPage.java:283)
	at org.eclipse.jdt.ui.wizards.JavaCapabilityConfigurationPage.configureJavaProject(JavaCapabilityConfigurationPage.java:259)
	at org.eclipse.jdt.ui.wizards.NewJavaProjectWizardPageTwo.updateProject(NewJavaProjectWizardPageTwo.java:255)
	at org.eclipse.jdt.ui.wizards.NewJavaProjectWizardPageTwo$1UpdateRunnable.run(NewJavaProjectWizardPageTwo.java:163)
	at org.eclipse.ui.actions.WorkspaceModifyDelegatingOperation.execute(WorkspaceModifyDelegatingOperation.java:71)
	at org.eclipse.ui.actions.WorkspaceModifyOperation.lambda$0(WorkspaceModifyOperation.java:110)
	at org.eclipse.ui.actions.WorkspaceModifyOperation$$Lambda$1108/0x0000000100bf53f0.run(Unknown Source)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2380)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2405)
	at org.eclipse.ui.actions.WorkspaceModifyOperation.run(WorkspaceModifyOperation.java:131)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)
!SUBENTRY 1 org.eclipse.ui 4 4 2023-02-23 13:01:00.742
!MESSAGE UI thread waiting on a job or lock.
!STACK 0
java.lang.IllegalStateException: Call stack for thread main
	at org.eclipse.swt.internal.win32.OS.WaitMessage(Native Method)
	at org.eclipse.swt.widgets.Display.sleep(Display.java:4759)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:824)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.jface.dialogs.MessageDialog.open(MessageDialog.java:609)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.BuildPathsBlock.lambda$2(BuildPathsBlock.java:977)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.BuildPathsBlock$$Lambda$1119/0x0000000100dded90.run(Unknown Source)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:172)
	at org.eclipse.ui.internal.UISynchronizer$$Lambda$1047/0x0000000100b8daa8.run(Unknown Source)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:132)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4043)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3648)
	at org.eclipse.ui.internal.dialogs.EventLoopProgressMonitor.runEventLoop(EventLoopProgressMonitor.java:126)
	at org.eclipse.ui.internal.dialogs.EventLoopProgressMonitor.isCanceled(EventLoopProgressMonitor.java:100)
	at org.eclipse.core.internal.jobs.ThreadJob.isCanceled(ThreadJob.java:148)
	at org.eclipse.core.internal.jobs.ThreadJob.waitForRun(ThreadJob.java:280)
	at org.eclipse.core.internal.jobs.ThreadJob.joinRun(ThreadJob.java:208)
	at org.eclipse.core.internal.jobs.ImplicitJobs.begin(ImplicitJobs.java:95)
	at org.eclipse.core.internal.jobs.JobManager.beginRule(JobManager.java:315)
	at org.eclipse.core.internal.resources.WorkManager.checkIn(WorkManager.java:124)
	at org.eclipse.core.internal.resources.Workspace.prepareOperation(Workspace.java:2330)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2375)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2405)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.newsourcepage.DialogPackageExplorer.setSelection(DialogPackageExplorer.java:451)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.newsourcepage.DialogPackageExplorer.setInput(DialogPackageExplorer.java:428)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.newsourcepage.NewSourceContainerWorkbookPage.doUpdateUI(NewSourceContainerWorkbookPage.java:137)
	at org.eclipse.jdt.internal.ui.wizards.buildpaths.newsourcepage.NewSourceContainerWorkbookPage$$Lambda$1112/0x0000000100dddec0.run(Unknown Source)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:132)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4043)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3648)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.block(ModalContext.java:166)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:368)
	at org.eclipse.jface.wizard.WizardDialog.run(WizardDialog.java:1034)
	at org.eclipse.jdt.ui.wizards.NewJavaProjectWizardPageTwo.changeToNewProject(NewJavaProjectWizardPageTwo.java:175)
	at org.eclipse.jdt.ui.wizards.NewJavaProjectWizardPageTwo.createProvisonalProject(NewJavaProjectWizardPageTwo.java:482)
	at org.eclipse.jdt.ui.wizards.NewJavaProjectWizardPageTwo.setVisible(NewJavaProjectWizardPageTwo.java:133)
	at org.eclipse.jface.wizard.WizardDialog.updateForPage(WizardDialog.java:1253)
	at org.eclipse.jface.wizard.WizardDialog.lambda$3(WizardDialog.java:1223)
	at org.eclipse.jface.wizard.WizardDialog$$Lambda$1106/0x0000000100db7990.run(Unknown Source)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jface.wizard.WizardDialog.showPage(WizardDialog.java:1223)
	at org.eclipse.jface.wizard.WizardDialog.nextPressed(WizardDialog.java:918)
	at org.eclipse.jface.wizard.WizardDialog.buttonPressed(WizardDialog.java:469)
	at org.eclipse.jface.dialogs.Dialog.lambda$0(Dialog.java:619)
	at org.eclipse.jface.dialogs.Dialog$$Lambda$231/0x0000000100321548.accept(Unknown Source)
	at org.eclipse.swt.events.SelectionListener$1.widgetSelected(SelectionListener.java:84)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:252)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4068)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:823)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.ui.internal.actions.NewWizardShortcutAction.run(NewWizardShortcutAction.java:130)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.jface.action.ActionContributionItem$$Lambda$535/0x0000000100653d88.handleEvent(Unknown Source)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4068)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.ui.internal.Workbench$$Lambda$271/0x00000001002c5550.run(Unknown Source)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base@17.0.4.1/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base@17.0.4.1/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base@17.0.4.1/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base@17.0.4.1/java.lang.reflect.Method.invoke(Method.java:568)
	at app//org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at app//org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at app//org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SESSION 2023-02-23 16:17:22.356 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_ZA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-02-23 16:17:33.478
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-02-23 16:17:33.478
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-02-23 16:17:33.478
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-02-23 16:17:36.323
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\redth'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-02-28 08:40:46.814 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_ZA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-02-28 08:41:06.744
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-02-28 08:41:06.744
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-02-28 08:41:06.744
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-02-28 08:41:12.308
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\redth'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2023-02-28 08:50:50.845
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------

public class Main
{

	//This is a Quicksort algorithm coded in Java
	public static void quickSort(int[] array, int left, int right) {
	    if (left < right) {
	        int pivotIndex = partition(array, left, right); 
	        quickSort(array, left, pivotIndex - 1); 
	        quickSort(array, pivotIndex + 1, right);
	    }
	    
	}
	 
	private static int partition(int[] array, int left, int right) {
	    int pivotValue = array[right];  
	    int pivotIndex = left;   
	    for (int i = left; i < right; i++) {
	        if (array[i] < pivotValue) {
	            swap(array, i, pivotIndex);
	            pivotIndex++;
	        }
	    }
	    swap(array, pivotIndex, right);  
	    return pivotIndex;
	}
	 
	private static void swap(int[] array, int i, int j) {
	    int temp = array[i];
	    array[i] = array[j];
	    array[j] = temp;
	}

	public static void main(String[] args) 
	{
		int[] arr = new int[8];
		
		arr[0] = 2;
		arr[1] = 5;
		arr[2] = 1;
		arr[3] = 9;
		arr[4] = 3;
		arr[5] = 4;
		arr[6] = 7;
		arr[7] = 6;
		
		quickSort(arr, 0, 8);
		
		
		
		for(int i = 0; i < 8; i++)
		{
			System.out.println((i+1)+": "+arr[i]);
		}
		// TODO Auto-generated method stub
		
		)n-1)

	}
	
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-02-28 08:50:50.848
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-02-28 08:50:50.850
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-02-28 08:50:51.011
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------

public class Main
{

	//This is a Quicksort algorithm coded in Java
	public static void quickSort(int[] array, int left, int right) {
	    if (left < right) {
	        int pivotIndex = partition(array, left, right); 
	        quickSort(array, left, pivotIndex - 1); 
	        quickSort(array, pivotIndex + 1, right);
	    }
	    
	}
	 
	private static int partition(int[] array, int left, int right) {
	    int pivotValue = array[right];  
	    int pivotIndex = left;   
	    for (int i = left; i < right; i++) {
	        if (array[i] < pivotValue) {
	            swap(array, i, pivotIndex);
	            pivotIndex++;
	        }
	    }
	    swap(array, pivotIndex, right);  
	    return pivotIndex;
	}
	 
	private static void swap(int[] array, int i, int j) {
	    int temp = array[i];
	    array[i] = array[j];
	    array[j] = temp;
	}

	public static void main(String[] args) 
	{
		int[] arr = new int[8];
		
		arr[0] = 2;
		arr[1] = 5;
		arr[2] = 1;
		arr[3] = 9;
		arr[4] = 3;
		arr[5] = 4;
		arr[6] = 7;
		arr[7] = 6;
		
		quickSort(arr, 0, 8);
		
		
		
		for(int i = 0; i < 8; i++)
		{
			System.out.println((i+1)+": "+arr[i]);
		}
		// TODO Auto-generated method stub
		
		)n-1)

	}
	
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-02-28 08:50:51.013
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-02-28 08:50:51.016
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-02-28 08:50:53.038
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------

public class Main
{

	//This is a Quicksort algorithm coded in Java
	public static void quickSort(int[] array, int left, int right) {
	    if (left < right) {
	        int pivotIndex = partition(array, left, right); 
	        quickSort(array, left, pivotIndex - 1); 
	        quickSort(array, pivotIndex + 1, right);
	    }
	    
	}
	 
	private static int partition(int[] array, int left, int right) {
	    int pivotValue = array[right];  
	    int pivotIndex = left;   
	    for (int i = left; i < right; i++) {
	        if (array[i] < pivotValue) {
	            swap(array, i, pivotIndex);
	            pivotIndex++;
	        }
	    }
	    swap(array, pivotIndex, right);  
	    return pivotIndex;
	}
	 
	private static void swap(int[] array, int i, int j) {
	    int temp = array[i];
	    array[i] = array[j];
	    array[j] = temp;
	}

	public static void main(String[] args) 
	{
		int[] arr = new int[8];
		
		arr[0] = 2;
		arr[1] = 5;
		arr[2] = 1;
		arr[3] = 9;
		arr[4] = 3;
		arr[5] = 4;
		arr[6] = 7;
		arr[7] = 6;
		
		quickSort(arr, 0, 8);
		
		
		
		for(int i = 0; i < 8; i++)
		{
			System.out.println((i+1)+": "+arr[i]);
		}
		// TODO Auto-generated method stub
		
		(n-1)

	}
	
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-02-28 08:50:53.039
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-02-28 08:50:53.041
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-02-28 08:50:53.130
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------

public class Main
{

	//This is a Quicksort algorithm coded in Java
	public static void quickSort(int[] array, int left, int right) {
	    if (left < right) {
	        int pivotIndex = partition(array, left, right); 
	        quickSort(array, left, pivotIndex - 1); 
	        quickSort(array, pivotIndex + 1, right);
	    }
	    
	}
	 
	private static int partition(int[] array, int left, int right) {
	    int pivotValue = array[right];  
	    int pivotIndex = left;   
	    for (int i = left; i < right; i++) {
	        if (array[i] < pivotValue) {
	            swap(array, i, pivotIndex);
	            pivotIndex++;
	        }
	    }
	    swap(array, pivotIndex, right);  
	    return pivotIndex;
	}
	 
	private static void swap(int[] array, int i, int j) {
	    int temp = array[i];
	    array[i] = array[j];
	    array[j] = temp;
	}

	public static void main(String[] args) 
	{
		int[] arr = new int[8];
		
		arr[0] = 2;
		arr[1] = 5;
		arr[2] = 1;
		arr[3] = 9;
		arr[4] = 3;
		arr[5] = 4;
		arr[6] = 7;
		arr[7] = 6;
		
		quickSort(arr, 0, 8);
		
		
		
		for(int i = 0; i < 8; i++)
		{
			System.out.println((i+1)+": "+arr[i]);
		}
		// TODO Auto-generated method stub
		
		(n-1)

	}
	
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-02-28 08:50:53.131
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-02-28 08:50:53.132
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-02-28 08:50:54.591
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------

public class Main
{

	//This is a Quicksort algorithm coded in Java
	public static void quickSort(int[] array, int left, int right) {
	    if (left < right) {
	        int pivotIndex = partition(array, left, right); 
	        quickSort(array, left, pivotIndex - 1); 
	        quickSort(array, pivotIndex + 1, right);
	    }
	    
	}
	 
	private static int partition(int[] array, int left, int right) {
	    int pivotValue = array[right];  
	    int pivotIndex = left;   
	    for (int i = left; i < right; i++) {
	        if (array[i] < pivotValue) {
	            swap(array, i, pivotIndex);
	            pivotIndex++;
	        }
	    }
	    swap(array, pivotIndex, right);  
	    return pivotIndex;
	}
	 
	private static void swap(int[] array, int i, int j) {
	    int temp = array[i];
	    array[i] = array[j];
	    array[j] = temp;
	}

	public static void main(String[] args) 
	{
		int[] arr = new int[8];
		
		arr[0] = 2;
		arr[1] = 5;
		arr[2] = 1;
		arr[3] = 9;
		arr[4] = 3;
		arr[5] = 4;
		arr[6] = 7;
		arr[7] = 6;
		
		quickSort(arr, 0, 8);
		
		
		
		for(int i = 0; i < 8; i++)
		{
			System.out.println((i+1)+": "+arr[i]);
		}
		// TODO Auto-generated method stub
		
		
		(n-1)

	}
	
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-02-28 08:50:54.593
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-02-28 08:50:54.594
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-02-28 08:50:54.608
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------

public class Main
{

	//This is a Quicksort algorithm coded in Java
	public static void quickSort(int[] array, int left, int right) {
	    if (left < right) {
	        int pivotIndex = partition(array, left, right); 
	        quickSort(array, left, pivotIndex - 1); 
	        quickSort(array, pivotIndex + 1, right);
	    }
	    
	}
	 
	private static int partition(int[] array, int left, int right) {
	    int pivotValue = array[right];  
	    int pivotIndex = left;   
	    for (int i = left; i < right; i++) {
	        if (array[i] < pivotValue) {
	            swap(array, i, pivotIndex);
	            pivotIndex++;
	        }
	    }
	    swap(array, pivotIndex, right);  
	    return pivotIndex;
	}
	 
	private static void swap(int[] array, int i, int j) {
	    int temp = array[i];
	    array[i] = array[j];
	    array[j] = temp;
	}

	public static void main(String[] args) 
	{
		int[] arr = new int[8];
		
		arr[0] = 2;
		arr[1] = 5;
		arr[2] = 1;
		arr[3] = 9;
		arr[4] = 3;
		arr[5] = 4;
		arr[6] = 7;
		arr[7] = 6;
		
		quickSort(arr, 0, 8);
		
		
		
		for(int i = 0; i < 8; i++)
		{
			System.out.println((i+1)+": "+arr[i]);
		}
		// TODO Auto-generated method stub
		
		
		(n-1)

	}
	
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-02-28 08:50:54.610
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-02-28 08:50:54.611
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-02-28 08:59:18.889
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------

public class Main
{

	//This is a Quicksort algorithm coded in Java
	public static void quickSort(int[] array, int left, int right) {
	    if (left < right) {
	        int pivotIndex = partition(array, left, right); 
	        quickSort(array, left, pivotIndex - 1); 
	        quickSort(array, pivotIndex + 1, right);
	    }
	    
	}
	 
	private static int partition(int[] array, int left, int right) {
	    int pivotValue = array[right];  
	    int pivotIndex = left;   
	    for (int i = left; i < right; i++) {
	        if (array[i] < pivotValue) {
	            swap(array, i, pivotIndex);
	            pivotIndex++;
	        }
	    }
	    swap(array, pivotIndex, right);  
	    return pivotIndex;
	}
	 
	private static void swap(int[] array, int i, int j) {
	    int temp = array[i];
	    array[i] = array[j];
	    array[j] = temp;
	}

	public static void main(String[] args) 
	{
		int[] arr = new int[8];
		
		arr[0] = 2;
		arr[1] = 5;
		arr[2] = 1;
		arr[3] = 9;
		arr[4] = 3;
		arr[5] = 4;
		arr[6] = 7;
		arr[7] = 6;
		
		quickSort(arr, 0, 7);
		
		
		
		for(int i = 0; i < 8; i++)
		{
			System.out.println((i+1)+": "+arr[i]);
		}
		// TODO Auto-generated method stub
		
		2: C - 
		3:(n-1)
		
		(n-1)*2C
		3:C
		5:C
		7:C
		
		

	}
	
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-02-28 08:59:18.891
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-02-28 08:59:18.893
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-02-28 08:59:18.990
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------

public class Main
{

	//This is a Quicksort algorithm coded in Java
	public static void quickSort(int[] array, int left, int right) {
	    if (left < right) {
	        int pivotIndex = partition(array, left, right); 
	        quickSort(array, left, pivotIndex - 1); 
	        quickSort(array, pivotIndex + 1, right);
	    }
	    
	}
	 
	private static int partition(int[] array, int left, int right) {
	    int pivotValue = array[right];  
	    int pivotIndex = left;   
	    for (int i = left; i < right; i++) {
	        if (array[i] < pivotValue) {
	            swap(array, i, pivotIndex);
	            pivotIndex++;
	        }
	    }
	    swap(array, pivotIndex, right);  
	    return pivotIndex;
	}
	 
	private static void swap(int[] array, int i, int j) {
	    int temp = array[i];
	    array[i] = array[j];
	    array[j] = temp;
	}

	public static void main(String[] args) 
	{
		int[] arr = new int[8];
		
		arr[0] = 2;
		arr[1] = 5;
		arr[2] = 1;
		arr[3] = 9;
		arr[4] = 3;
		arr[5] = 4;
		arr[6] = 7;
		arr[7] = 6;
		
		quickSort(arr, 0, 7);
		
		
		
		for(int i = 0; i < 8; i++)
		{
			System.out.println((i+1)+": "+arr[i]);
		}
		// TODO Auto-generated method stub
		
		2: C - 
		3:(n-1)
		
		(n-1)*2C
		3:C
		5:C
		7:C
		
		

	}
	
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-02-28 08:59:18.991
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-02-28 08:59:18.992
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2023-03-02 13:04:21.384 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_ZA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 2 10035 2023-03-02 13:04:29.795
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.jface 2 0 2023-03-02 13:04:37.202
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-02 13:04:37.202
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-02 13:04:37.202
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-03-02 13:04:40.822
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\redth'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2023-03-02 14:08:40.003
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------

public class DList<T extends Comparable<T>> implements IList<T>, Cloneable {

	private Node<T> header = null;//prev
	private Node<T> trailer = null;//next
	private Integer size = 0;
	
	/**
	 * Default constructor
	 * parameters to Node constructor (next, prev, element)
	 */
	public DList() 
	{
		trailer = new Node<T>(null, null, null);
		header = new Node<T>(trailer, null, null);
		trailer.setPrev(header);
		size = 0;
	}
	
	
	/**
	 * Returns first node in the list
	 */
	public Node<T> first(){
		return header;
		}
	
	/**
	 * Returns last node in the list
	 */
	public Node<T> last(){
	return trailer;
	}
	
	
	/**
	 * Construct a List from an Array
	 * @param fromArray the array used to construct the list
	 */
	public DList(T[] fromArray) 
	{
		//if list only has 1 or less element, return
		if(fromArray.length <= 1)
		{
			return;
		}
		
		//create first and last element in array
		trailer = new Node<T>(null, null, fromArray[fromArray.length-1]);//tail
		header = new Node<T>(trailer, null, fromArray[0]);//head
		trailer.setPrev(header);
		size = 2;
		

		//get first node
		Node<T> tempNode = first();
		//now add rest of elements using addafter method
		for(int i = 1; i < fromArray.length-2; i++)
		{
			//calls a method to creates a new node after the first node
			//then reassigns that first node to be the new node
			tempNode = addAfter(tempNode, fromArray[i]);
		}

	}
	
	/**
	 * Convert the list to an array.
	 */
	public T[] toArray() 
	{
		//create array
		T[] array = (T[]) new Object[size];
		//get first node
		Node<T> tempNode = first();
		
		for(int i = 0; i < size; i++)
		{
			//assigns element to array
			array[i] = tempNode.getElement();
			//then changes node to next node
			tempNode = tempNode.getNext();
		}
		return array;

	}
	
	/**
	 * Provide a deep copy of the Linked List
	 */
	@Override
	public DList<T> clone() 
	{
		DList<T> newDList>T
		//COMPLETE CODE HERE
		
	}
	
	/**
	 * Add an element after a given node in the list
	 */
	@Override
	public Node<T> addAfter(Node<T> elem, T item) 
	{
		size++;
		//get prev node
		Node<T> nextNode = elem.getNext();
		//create new element
		Node<T> newNode = new Node<T>(nextNode, elem, item);//next, prev, element

		//now repoint the next and prev nodes to the new node
		nextNode.setPrev(newNode);
		elem.setNext(newNode);

		return newNode;
	}

	/**
	 * Add an element before a given node in a list
	 */
	@Override
	public Node<T> addBefore(Node<T> elem, T item) 
	{
		size++;
		//get prev node
		Node<T> prevNode = elem.getPrev();
		//create new element
		Node<T> newNode = new Node<T>(elem, prevNode, item);//next, prev, element

		//now repoint the next and prev nodes to the new node
		elem.setPrev(newNode);
		prevNode.setNext(newNode);

		return newNode;
	}

	/**
	 * Add an element to the start of the list
	 */
	public Node<T> addFirst(T item) {
		return addAfter(header, item);
	}
	
	/**
	 * Add an element to the end of the list
	 */
	public Node<T> addLast(T item) {
		return addBefore(trailer, item);
	}
	
	/**
	 * Remove a specified node from the list. The removed element is returned
	 */
	@Override
	public T remove(Node<T> elem) {
		//COMPLETE CODE HERE
	}

	/**
	 * Returns the node that contains the element that is specified as a parameter
	 */
	@Override
	public Node<T> search(T elem) {
		//COMPLETE CODE HERE
	}

	/**
	 * Returns true if the list is empty
	 */
	@Override
	public boolean isEmpty() {
		return (header.getNext() == trailer);
	}

	/**
	 * Return the size of the list
	 */
	@Override
	public Integer size() {
		return size;
	}
	
		/**
	 * Return the first element in the list
	 */
	public T head() {
		return header.getNext().getElement();
	}
	
	/**
	 * Returns a list that contains everything except the first element
	 */
	public IList<T> tail() {
		//COMPLETE CODE HERE
	}
	
	
	@Override
	public String toString() {
		String result = header.toString() + " <-> ";
		Node<T> currentNode = header.getNext();
		
		//COMPLETE CODE HERE
		
		result += trailer.toString();
		return result;
	}
	
	/**
	 * Return a new list that contains all the element in the current list
	 * that are less than a specified element
	 */
	public DList<T> splitLess(T element) {
		//COMPLETE CODE HERE
	}
	
	/**
	 * Return a new list that contains all the element in the current list
	 * that are greater than a specified element
	 */
	public DList<T> splitGreater(T element) {
		//COMPLETE CODE HERE
	}
	
	/**
	 * Return a new list that contains all the element in the current list
	 * that are equal to the specified element
	 */
	public DList<T> splitEqual(T element) {
		//COMPLETE CODE HERE
	}
	
	/**
	 * Return a new IList that contains the elements merged from the current list
	 * and the passed otherList
	 * @param otherList the other list to merge
	 * @return a new list of element
	 */
	public DList<T> merge(DList<T> otherList) {
		DList<T> newList = new DList<T>();
		Node<T> currentNode = header.getNext();
		Node<T> currentNode2 = otherList.header.getNext();
		
		//COMPLETE CODE HERE
		
		return newList;
	}
	
	/**
	 * Return a new list that has been sorted using a quick sort.
	 * @return a sorted list
	 */
	public DList<T> quicksort() {
		if (size() <= 1)
			return this.clone();
		
		//COMPLETE CODE HERE	
	
		//merge everything together
		DList<T> sortedList = smaller.merge(equal).merge(greater);
		return sortedList;
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-03-02 14:08:40.013
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-03-02 14:08:40.015
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-03-02 14:08:40.098
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------

public class DList<T extends Comparable<T>> implements IList<T>, Cloneable {

	private Node<T> header = null;//prev
	private Node<T> trailer = null;//next
	private Integer size = 0;
	
	/**
	 * Default constructor
	 * parameters to Node constructor (next, prev, element)
	 */
	public DList() 
	{
		trailer = new Node<T>(null, null, null);
		header = new Node<T>(trailer, null, null);
		trailer.setPrev(header);
		size = 0;
	}
	
	
	/**
	 * Returns first node in the list
	 */
	public Node<T> first(){
		return header;
		}
	
	/**
	 * Returns last node in the list
	 */
	public Node<T> last(){
	return trailer;
	}
	
	
	/**
	 * Construct a List from an Array
	 * @param fromArray the array used to construct the list
	 */
	public DList(T[] fromArray) 
	{
		//if list only has 1 or less element, return
		if(fromArray.length <= 1)
		{
			return;
		}
		
		//create first and last element in array
		trailer = new Node<T>(null, null, fromArray[fromArray.length-1]);//tail
		header = new Node<T>(trailer, null, fromArray[0]);//head
		trailer.setPrev(header);
		size = 2;
		

		//get first node
		Node<T> tempNode = first();
		//now add rest of elements using addafter method
		for(int i = 1; i < fromArray.length-2; i++)
		{
			//calls a method to creates a new node after the first node
			//then reassigns that first node to be the new node
			tempNode = addAfter(tempNode, fromArray[i]);
		}

	}
	
	/**
	 * Convert the list to an array.
	 */
	public T[] toArray() 
	{
		//create array
		T[] array = (T[]) new Object[size];
		//get first node
		Node<T> tempNode = first();
		
		for(int i = 0; i < size; i++)
		{
			//assigns element to array
			array[i] = tempNode.getElement();
			//then changes node to next node
			tempNode = tempNode.getNext();
		}
		return array;

	}
	
	/**
	 * Provide a deep copy of the Linked List
	 */
	@Override
	public DList<T> clone() 
	{
		DList<T> newDList>T
		//COMPLETE CODE HERE
		
	}
	
	/**
	 * Add an element after a given node in the list
	 */
	@Override
	public Node<T> addAfter(Node<T> elem, T item) 
	{
		size++;
		//get prev node
		Node<T> nextNode = elem.getNext();
		//create new element
		Node<T> newNode = new Node<T>(nextNode, elem, item);//next, prev, element

		//now repoint the next and prev nodes to the new node
		nextNode.setPrev(newNode);
		elem.setNext(newNode);

		return newNode;
	}

	/**
	 * Add an element before a given node in a list
	 */
	@Override
	public Node<T> addBefore(Node<T> elem, T item) 
	{
		size++;
		//get prev node
		Node<T> prevNode = elem.getPrev();
		//create new element
		Node<T> newNode = new Node<T>(elem, prevNode, item);//next, prev, element

		//now repoint the next and prev nodes to the new node
		elem.setPrev(newNode);
		prevNode.setNext(newNode);

		return newNode;
	}

	/**
	 * Add an element to the start of the list
	 */
	public Node<T> addFirst(T item) {
		return addAfter(header, item);
	}
	
	/**
	 * Add an element to the end of the list
	 */
	public Node<T> addLast(T item) {
		return addBefore(trailer, item);
	}
	
	/**
	 * Remove a specified node from the list. The removed element is returned
	 */
	@Override
	public T remove(Node<T> elem) {
		//COMPLETE CODE HERE
	}

	/**
	 * Returns the node that contains the element that is specified as a parameter
	 */
	@Override
	public Node<T> search(T elem) {
		//COMPLETE CODE HERE
	}

	/**
	 * Returns true if the list is empty
	 */
	@Override
	public boolean isEmpty() {
		return (header.getNext() == trailer);
	}

	/**
	 * Return the size of the list
	 */
	@Override
	public Integer size() {
		return size;
	}
	
		/**
	 * Return the first element in the list
	 */
	public T head() {
		return header.getNext().getElement();
	}
	
	/**
	 * Returns a list that contains everything except the first element
	 */
	public IList<T> tail() {
		//COMPLETE CODE HERE
	}
	
	
	@Override
	public String toString() {
		String result = header.toString() + " <-> ";
		Node<T> currentNode = header.getNext();
		
		//COMPLETE CODE HERE
		
		result += trailer.toString();
		return result;
	}
	
	/**
	 * Return a new list that contains all the element in the current list
	 * that are less than a specified element
	 */
	public DList<T> splitLess(T element) {
		//COMPLETE CODE HERE
	}
	
	/**
	 * Return a new list that contains all the element in the current list
	 * that are greater than a specified element
	 */
	public DList<T> splitGreater(T element) {
		//COMPLETE CODE HERE
	}
	
	/**
	 * Return a new list that contains all the element in the current list
	 * that are equal to the specified element
	 */
	public DList<T> splitEqual(T element) {
		//COMPLETE CODE HERE
	}
	
	/**
	 * Return a new IList that contains the elements merged from the current list
	 * and the passed otherList
	 * @param otherList the other list to merge
	 * @return a new list of element
	 */
	public DList<T> merge(DList<T> otherList) {
		DList<T> newList = new DList<T>();
		Node<T> currentNode = header.getNext();
		Node<T> currentNode2 = otherList.header.getNext();
		
		//COMPLETE CODE HERE
		
		return newList;
	}
	
	/**
	 * Return a new list that has been sorted using a quick sort.
	 * @return a sorted list
	 */
	public DList<T> quicksort() {
		if (size() <= 1)
			return this.clone();
		
		//COMPLETE CODE HERE	
	
		//merge everything together
		DList<T> sortedList = smaller.merge(equal).merge(greater);
		return sortedList;
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-03-02 14:08:40.099
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-03-02 14:08:40.100
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2023-03-02 14:54:52.363 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_ZA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-03-02 14:55:04.951
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-02 14:55:04.951
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-02 14:55:04.952
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-03-02 14:55:08.582
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\redth'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-03-09 13:00:27.832 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_ZA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 2 10035 2023-03-09 13:04:09.987
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.jface 2 0 2023-03-09 13:04:18.669
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-09 13:04:18.669
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-09 13:04:18.669
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-03-09 13:04:22.873
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\redth'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-03-09 13:10:42.277 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_ZA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-03-09 13:11:27.635
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-09 13:11:27.635
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-09 13:11:27.635
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-03-09 13:11:33.375
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\redth'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-03-14 11:55:08.736 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_ZA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-03-14 11:56:02.401
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-14 11:56:02.401
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-14 11:56:02.401
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-03-14 11:56:08.607
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\redth'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-03-16 11:19:03.386 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_ZA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-03-16 11:19:21.564
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-16 11:19:21.564
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-16 11:19:21.564
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-03-16 11:19:26.613
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\redth'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-03-20 11:45:40.331 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_ZA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 2 10035 2023-03-20 11:45:48.745
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.jface 2 0 2023-03-20 11:45:57.263
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-20 11:45:57.264
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-20 11:45:57.264
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-03-20 11:46:01.057
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\redth'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-03-23 13:18:23.065 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_ZA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-03-23 13:19:07.809
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-23 13:19:07.809
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-23 13:19:07.809
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-03-23 13:19:15.736
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\redth'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-03-23 14:22:49.126 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_ZA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-03-23 14:23:05.025
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-23 14:23:05.026
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-23 14:23:05.026
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-03-23 14:23:12.821
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\redth'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-03-23 16:46:49.955 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_ZA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 4 567 2023-03-23 16:46:53.877
!MESSAGE Workspace restored, but some problems occurred.
!SUBENTRY 1 org.eclipse.core.resources 4 567 2023-03-23 16:46:53.877
!MESSAGE Could not read metadata for '221003350_P05'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/221003350_P05)[567]: java.lang.Exception: The project description file (.project) for '221003350_P05' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:571)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:545)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2023-03-23 16:46:53.881
!MESSAGE The project description file (.project) for '221003350_P05' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for '221003350_P05' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:895)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:875)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:731)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1587)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2547)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2252)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:571)
	at org.eclipse.core.resources.ResourcesPlugin$WorkspaceInitCustomizer.addingService(ResourcesPlugin.java:1)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:943)
	at org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:1)
	at org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256)
	at org.osgi.util.tracker.AbstractTracked.trackInitial(AbstractTracked.java:183)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:321)
	at org.osgi.util.tracker.ServiceTracker.open(ServiceTracker.java:264)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:545)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:818)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$2.run(BundleContextImpl.java:1)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:569)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:810)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:767)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:153)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jface 2 0 2023-03-23 16:46:56.945
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-23 16:46:56.945
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-23 16:46:56.945
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-03-23 16:47:01.597
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\redth'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.lsp4e 4 0 2023-03-23 16:47:13.727
!MESSAGE Exception occurred while fetching the content type from the buffer
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/221003350_P05/src/Main.java)[368]: java.lang.Exception: Resource '/221003350_P05/src/Main.java' does not exist.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.resources.Resource.checkExists(Resource.java:330)
	at org.eclipse.core.internal.resources.Resource.checkAccessible(Resource.java:204)
	at org.eclipse.core.internal.resources.File.getContentDescription(File.java:255)
	at org.eclipse.core.internal.filebuffers.ResourceTextFileBuffer.getContentType(ResourceTextFileBuffer.java:201)
	at org.eclipse.lsp4e.LSPEclipseUtils.getDocumentContentTypes(LSPEclipseUtils.java:933)
	at org.eclipse.lsp4e.LanguageServersRegistry.canUseLanguageServer(LanguageServersRegistry.java:442)
	at org.eclipse.lsp4e.HasLanguageServerPropertyTester.test(HasLanguageServerPropertyTester.java:34)
	at org.eclipse.core.internal.expressions.Property.test(Property.java:65)
	at org.eclipse.core.expressions.TestExpression.evaluate(TestExpression.java:107)
	at org.eclipse.core.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:54)
	at org.eclipse.core.expressions.WithExpression.evaluate(WithExpression.java:84)
	at org.eclipse.core.expressions.CompositeExpression.evaluateOr(CompositeExpression.java:68)
	at org.eclipse.core.expressions.OrExpression.evaluate(OrExpression.java:26)
	at org.eclipse.ui.internal.texteditor.codemining.CodeMiningProviderDescriptor.matches(CodeMiningProviderDescriptor.java:189)
	at org.eclipse.ui.internal.texteditor.codemining.CodeMiningProviderRegistry.getProviders(CodeMiningProviderRegistry.java:110)
	at org.eclipse.ui.texteditor.AbstractTextEditor.installCodeMiningProviders(AbstractTextEditor.java:4019)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.installCodeMiningProviders(JavaEditor.java:4271)
	at org.eclipse.ui.texteditor.AbstractTextEditor.initializeSourceViewer(AbstractTextEditor.java:4009)
	at org.eclipse.ui.texteditor.AbstractTextEditor.createPartControl(AbstractTextEditor.java:3470)
	at org.eclipse.ui.texteditor.StatusTextEditor.createPartControl(StatusTextEditor.java:64)
	at org.eclipse.ui.texteditor.AbstractDecoratedTextEditor.createPartControl(AbstractDecoratedTextEditor.java:454)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.createPartControl(JavaEditor.java:3093)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.createPartControl(CompilationUnitEditor.java:1522)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.createPartControl(CompatibilityPart.java:158)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityEditor.createPartControl(CompatibilityEditor.java:96)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:365)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:995)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:960)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalInject(InjectorImpl.java:140)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:403)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:330)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:202)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:91)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:60)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:42)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:132)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:995)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:659)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:763)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:728)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:712)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.lambda$0(PartServiceImpl.java:105)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.lambda$0(UIEventHandler.java:38)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:183)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4792)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:38)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElementGen(ElementContainerImpl.java:170)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElement(ElementContainerImpl.java:188)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.hidePart(PartServiceImpl.java:1381)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.hidePart(PartServiceImpl.java:1331)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.closePart(StackRenderer.java:1182)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer$3.close(StackRenderer.java:1042)
	at org.eclipse.swt.custom.CTabFolder.onMouse(CTabFolder.java:1961)
	at org.eclipse.swt.custom.CTabFolder.lambda$0(CTabFolder.java:337)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4068)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 1 org.eclipse.core.resources 4 368 2023-03-23 16:47:13.728
!MESSAGE Resource '/221003350_P05/src/Main.java' does not exist.
!STACK 0
java.lang.Exception: Resource '/221003350_P05/src/Main.java' does not exist.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.resources.Resource.checkExists(Resource.java:330)
	at org.eclipse.core.internal.resources.Resource.checkAccessible(Resource.java:204)
	at org.eclipse.core.internal.resources.File.getContentDescription(File.java:255)
	at org.eclipse.core.internal.filebuffers.ResourceTextFileBuffer.getContentType(ResourceTextFileBuffer.java:201)
	at org.eclipse.lsp4e.LSPEclipseUtils.getDocumentContentTypes(LSPEclipseUtils.java:933)
	at org.eclipse.lsp4e.LanguageServersRegistry.canUseLanguageServer(LanguageServersRegistry.java:442)
	at org.eclipse.lsp4e.HasLanguageServerPropertyTester.test(HasLanguageServerPropertyTester.java:34)
	at org.eclipse.core.internal.expressions.Property.test(Property.java:65)
	at org.eclipse.core.expressions.TestExpression.evaluate(TestExpression.java:107)
	at org.eclipse.core.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:54)
	at org.eclipse.core.expressions.WithExpression.evaluate(WithExpression.java:84)
	at org.eclipse.core.expressions.CompositeExpression.evaluateOr(CompositeExpression.java:68)
	at org.eclipse.core.expressions.OrExpression.evaluate(OrExpression.java:26)
	at org.eclipse.ui.internal.texteditor.codemining.CodeMiningProviderDescriptor.matches(CodeMiningProviderDescriptor.java:189)
	at org.eclipse.ui.internal.texteditor.codemining.CodeMiningProviderRegistry.getProviders(CodeMiningProviderRegistry.java:110)
	at org.eclipse.ui.texteditor.AbstractTextEditor.installCodeMiningProviders(AbstractTextEditor.java:4019)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.installCodeMiningProviders(JavaEditor.java:4271)
	at org.eclipse.ui.texteditor.AbstractTextEditor.initializeSourceViewer(AbstractTextEditor.java:4009)
	at org.eclipse.ui.texteditor.AbstractTextEditor.createPartControl(AbstractTextEditor.java:3470)
	at org.eclipse.ui.texteditor.StatusTextEditor.createPartControl(StatusTextEditor.java:64)
	at org.eclipse.ui.texteditor.AbstractDecoratedTextEditor.createPartControl(AbstractDecoratedTextEditor.java:454)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.createPartControl(JavaEditor.java:3093)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.createPartControl(CompilationUnitEditor.java:1522)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.createPartControl(CompatibilityPart.java:158)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityEditor.createPartControl(CompatibilityEditor.java:96)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:365)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:995)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:960)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalInject(InjectorImpl.java:140)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:403)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:330)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:202)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:91)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:60)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:42)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:132)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:995)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:659)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:763)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:728)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:712)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.lambda$0(PartServiceImpl.java:105)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.lambda$0(UIEventHandler.java:38)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:183)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4792)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:38)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElementGen(ElementContainerImpl.java:170)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElement(ElementContainerImpl.java:188)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.hidePart(PartServiceImpl.java:1381)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.hidePart(PartServiceImpl.java:1331)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.closePart(StackRenderer.java:1182)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer$3.close(StackRenderer.java:1042)
	at org.eclipse.swt.custom.CTabFolder.onMouse(CTabFolder.java:1961)
	at org.eclipse.swt.custom.CTabFolder.lambda$0(CTabFolder.java:337)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4068)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.lsp4e 4 0 2023-03-23 16:47:13.738
!MESSAGE Exception occurred while fetching the content type from the buffer
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/221003350_P05/src/Main.java)[368]: java.lang.Exception: Resource '/221003350_P05/src/Main.java' does not exist.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.resources.Resource.checkExists(Resource.java:330)
	at org.eclipse.core.internal.resources.Resource.checkAccessible(Resource.java:204)
	at org.eclipse.core.internal.resources.File.getContentDescription(File.java:255)
	at org.eclipse.core.internal.filebuffers.ResourceTextFileBuffer.getContentType(ResourceTextFileBuffer.java:201)
	at org.eclipse.lsp4e.LSPEclipseUtils.getDocumentContentTypes(LSPEclipseUtils.java:933)
	at org.eclipse.lsp4e.LanguageServersRegistry.canUseLanguageServer(LanguageServersRegistry.java:442)
	at org.eclipse.lsp4e.HasLanguageServerPropertyTester.test(HasLanguageServerPropertyTester.java:34)
	at org.eclipse.core.internal.expressions.Property.test(Property.java:65)
	at org.eclipse.core.expressions.TestExpression.evaluate(TestExpression.java:107)
	at org.eclipse.core.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:54)
	at org.eclipse.core.expressions.WithExpression.evaluate(WithExpression.java:84)
	at org.eclipse.core.expressions.CompositeExpression.evaluateOr(CompositeExpression.java:68)
	at org.eclipse.core.expressions.OrExpression.evaluate(OrExpression.java:26)
	at org.eclipse.ui.internal.texteditor.codemining.CodeMiningProviderDescriptor.matches(CodeMiningProviderDescriptor.java:189)
	at org.eclipse.ui.internal.texteditor.codemining.CodeMiningProviderRegistry.getProviders(CodeMiningProviderRegistry.java:110)
	at org.eclipse.ui.texteditor.AbstractTextEditor.installCodeMiningProviders(AbstractTextEditor.java:4019)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.installCodeMiningProviders(JavaEditor.java:4271)
	at org.eclipse.ui.texteditor.AbstractTextEditor.initializeSourceViewer(AbstractTextEditor.java:4009)
	at org.eclipse.ui.texteditor.AbstractTextEditor.createPartControl(AbstractTextEditor.java:3470)
	at org.eclipse.ui.texteditor.StatusTextEditor.createPartControl(StatusTextEditor.java:64)
	at org.eclipse.ui.texteditor.AbstractDecoratedTextEditor.createPartControl(AbstractDecoratedTextEditor.java:454)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.createPartControl(JavaEditor.java:3093)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.createPartControl(CompilationUnitEditor.java:1522)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.createPartControl(CompatibilityPart.java:158)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityEditor.createPartControl(CompatibilityEditor.java:96)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:365)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:995)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:960)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalInject(InjectorImpl.java:140)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:403)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:330)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:202)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:91)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:60)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:42)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:132)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:995)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:659)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:763)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:728)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:712)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.lambda$0(PartServiceImpl.java:105)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.lambda$0(UIEventHandler.java:38)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:183)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4792)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:38)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElementGen(ElementContainerImpl.java:170)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElement(ElementContainerImpl.java:188)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.hidePart(PartServiceImpl.java:1381)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.hidePart(PartServiceImpl.java:1331)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.closePart(StackRenderer.java:1182)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer$3.close(StackRenderer.java:1042)
	at org.eclipse.swt.custom.CTabFolder.onMouse(CTabFolder.java:1961)
	at org.eclipse.swt.custom.CTabFolder.lambda$0(CTabFolder.java:337)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4068)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SUBENTRY 1 org.eclipse.core.resources 4 368 2023-03-23 16:47:13.739
!MESSAGE Resource '/221003350_P05/src/Main.java' does not exist.
!STACK 0
java.lang.Exception: Resource '/221003350_P05/src/Main.java' does not exist.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.resources.Resource.checkExists(Resource.java:330)
	at org.eclipse.core.internal.resources.Resource.checkAccessible(Resource.java:204)
	at org.eclipse.core.internal.resources.File.getContentDescription(File.java:255)
	at org.eclipse.core.internal.filebuffers.ResourceTextFileBuffer.getContentType(ResourceTextFileBuffer.java:201)
	at org.eclipse.lsp4e.LSPEclipseUtils.getDocumentContentTypes(LSPEclipseUtils.java:933)
	at org.eclipse.lsp4e.LanguageServersRegistry.canUseLanguageServer(LanguageServersRegistry.java:442)
	at org.eclipse.lsp4e.HasLanguageServerPropertyTester.test(HasLanguageServerPropertyTester.java:34)
	at org.eclipse.core.internal.expressions.Property.test(Property.java:65)
	at org.eclipse.core.expressions.TestExpression.evaluate(TestExpression.java:107)
	at org.eclipse.core.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:54)
	at org.eclipse.core.expressions.WithExpression.evaluate(WithExpression.java:84)
	at org.eclipse.core.expressions.CompositeExpression.evaluateOr(CompositeExpression.java:68)
	at org.eclipse.core.expressions.OrExpression.evaluate(OrExpression.java:26)
	at org.eclipse.ui.internal.texteditor.codemining.CodeMiningProviderDescriptor.matches(CodeMiningProviderDescriptor.java:189)
	at org.eclipse.ui.internal.texteditor.codemining.CodeMiningProviderRegistry.getProviders(CodeMiningProviderRegistry.java:110)
	at org.eclipse.ui.texteditor.AbstractTextEditor.installCodeMiningProviders(AbstractTextEditor.java:4019)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.installCodeMiningProviders(JavaEditor.java:4271)
	at org.eclipse.ui.texteditor.AbstractTextEditor.initializeSourceViewer(AbstractTextEditor.java:4009)
	at org.eclipse.ui.texteditor.AbstractTextEditor.createPartControl(AbstractTextEditor.java:3470)
	at org.eclipse.ui.texteditor.StatusTextEditor.createPartControl(StatusTextEditor.java:64)
	at org.eclipse.ui.texteditor.AbstractDecoratedTextEditor.createPartControl(AbstractDecoratedTextEditor.java:454)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.createPartControl(JavaEditor.java:3093)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.createPartControl(CompilationUnitEditor.java:1522)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.createPartControl(CompatibilityPart.java:158)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityEditor.createPartControl(CompatibilityEditor.java:96)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:365)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:995)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:960)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalInject(InjectorImpl.java:140)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:403)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:330)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:202)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:91)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:60)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:42)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:132)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:995)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:659)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:763)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:728)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:712)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.lambda$0(PartServiceImpl.java:105)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.lambda$0(UIEventHandler.java:38)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:183)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4792)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:38)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElementGen(ElementContainerImpl.java:170)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElement(ElementContainerImpl.java:188)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.hidePart(PartServiceImpl.java:1381)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.hidePart(PartServiceImpl.java:1331)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.closePart(StackRenderer.java:1182)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer$3.close(StackRenderer.java:1042)
	at org.eclipse.swt.custom.CTabFolder.onMouse(CTabFolder.java:1961)
	at org.eclipse.swt.custom.CTabFolder.lambda$0(CTabFolder.java:337)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4251)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4068)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3645)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
!SESSION 2023-03-30 13:17:02.233 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_ZA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-03-30 13:21:10.884
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-30 13:21:10.884
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-30 13:21:10.884
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-03-30 13:21:15.142
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\redth'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-04-08 14:58:06.621 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_ZA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-04-08 14:58:48.659
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-08 14:58:48.660
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-08 14:58:48.660
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-08 14:58:55.143
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\redth'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-04-11 08:23:44.524 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_ZA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-04-11 08:24:04.360
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-11 08:24:04.360
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-11 08:24:04.360
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-11 08:24:10.399
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\redth'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-04-11 10:36:00.989 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_ZA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-04-11 10:36:16.660
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-11 10:36:16.660
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-11 10:36:16.660
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-11 10:36:21.038
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\redth'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-04-12 12:50:59.666 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_ZA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-04-12 12:51:19.561
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-12 12:51:19.561
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-12 12:51:19.561
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-12 12:51:24.969
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\redth'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-04-12 12:54:30.085 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_ZA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-04-12 12:54:39.063
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-12 12:54:39.063
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-12 12:54:39.063
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-12 12:54:43.204
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\redth'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-04-12 15:05:31.290 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_ZA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-04-12 15:06:35.794
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-12 15:06:35.794
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-12 15:06:35.794
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-12 15:06:38.966
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\redth'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2023-04-12 17:35:27.326
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------


import java.util.ArrayList;
import java.util.Iterator;

import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.TextArea;
import javafx.scene.input.MouseDragEvent;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.Pane;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Line;
import javafx.scene.shape.Shape;
import javafx.stage.Stage;

public class GraphPane extends StackPane
{
	static Pane pane;
	static int total;
	static TextArea txtTotal;
	static TextArea txtDisplay;
	static GridPane gridPane;
	static GraphPane graphPane;
	static Tree<Choice> tree;
	static Position<Choice> root;
	static ScrollPane scrollPane;
	
	public GraphPane()
	{
		
		graphPane = this;
		gridPane = new GridPane();
		//setting vbox/controls
		VBox vbox = new VBox();
		vbox.setMaxSize(200, 200);
		//setting pane/graph
		pane = new Pane();
		pane.setPrefSize(2000, 2000);
		
		//scrollpane
		scrollPane = new ScrollPane();
		scrollPane.setContent(pane);
		scrollPane.setPrefSize(600, 600);
		//adding both to main borderpane for layout
		gridPane.add(vbox, 0, 0);
		gridPane.add(scrollPane, 0, 1);

		
		//adding controls to vbox
		Label lblTotal = new Label("Total:");
		txtTotal = new TextArea();
		txtTotal.setPrefSize(getPrefWidth(), 20);
		
		Label lblDisplay = new Label("Display:");
		txtDisplay = new TextArea();
		txtDisplay.setPrefSize(getPrefWidth(), 20);
		
		vbox.setPadding(getInsets());
		
		vbox.getChildren().add(lblTotal);
		vbox.getChildren().add(txtTotal);
		vbox.getChildren().add(lblDisplay);
		vbox.getChildren().add(txtDisplay);
		

		this.getChildren().add(gridPane);
		Choice c1 = new Choice();
		tree = new Tree<Choice>(c1);
		root = tree.root();
		try 
		{
			Choice c2 = new Choice();
			Choice c3 = new Choice();
			Choice c4 = new Choice();
			Choice c5 = new Choice();
			Choice c6 = new Choice();

			
			Position<Choice> a1 = tree.addElementAsChild(root, c2);
			Position<Choice> a2 = tree.addElementAsChild(root, c3);
			//Position<Choice> a3 =tree.addElementAsChild(root, c4);

			//ArrayList<Position<Choice>> aL = new ArrayList<Position<Choice>>();
			//aL.add(a1);
			//aL.add(a2);
			////aL.add(a3);
			
			Position<Choice> b1 =tree.addElementAsChild(a1, c5);
			//Position<Choice> b1 =tree.addListParents(aL, c5);
			//Position<Choice> d1 =tree.addElementAsChild(b1, c6);

			displayNodes(tree, root);
			System.out.println(tree.preOrderElementTraversal(tree, root));
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		////
		
	}
	
	final static int nodeSize = 50;
	final static int edgeSize = 50;
	public static void addNode(int x, int y, Choice elem)
	{
		Button button = new Button(""+elem.getID());
		button.setShape(new Circle(10));
		button.setPrefSize(nodeSize,nodeSize);
		button.setLayoutX(x);
		button.setLayoutY(y);
		pane.getChildren().add(button);
		button.setTextFill(null);
		button.setOnAction(new EventHandler <ActionEvent>()
		{
			
			@Override
			public void handle(ActionEvent event) 
			{
				//total += elem;
				txtTotal.setText(""+total);
				graphPane.setVisible(false);
				
				//this is to search if parent has been visisted
				searchResult = false;
				//this is to search if a fellow child has been visited
				searchChildResult = true;
				try 
				{
					searchParentVisited(tree,  root, Integer.parseInt(button.getText()));
					searchFellowChildVisited(tree,  root, Integer.parseInt(button.getText()));
	
				} catch (Exception e) 
				{
					e.printStackTrace();
				}
				
				

				
				//if parent not visited yet
				if(!searchResult)
				{
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: Parent of Choice not selected yet.", graphPane);
					Stage secondStage = new Stage();
					
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
			        return;
					
				}else
				if(!searchChildResult)//now check if a fellow child has already been chosen
				{
								
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: You cannot choose more than one choice at the same depth", graphPane);
					Stage secondStage = new Stage();
					
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
			        return;
					
					
				}else
				if(button.getTextFill() == null)//if button viable
				{
					//opens main menu
					InfoPane root = new InfoPane(elem, button, graphPane);
					Stage secondStage = new Stage();
					
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Info");
			        secondStage.show();
					
				}else
				if(button.getTextFill().equals(Color.BLUE))//if buttons already been selected
				{
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: This option has already been selected.", graphPane);
					Stage secondStage = new Stage();
					
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
				}else
				{

					
				}
			}			
		});
	}
	
	public static void addEdge(int xP, int yP,int x, int y, Position<Choice> choice)
	{	
		//System.out.println(xP +"-"+yP+"-"+x+"-"+y);
		//create line/edge from start to end
		Line line = new Line(xP+30, yP+30, x+30, y+30);
		Label lblWeight = new Label(""+choice.element().getWeight());
		lblWeight.setLayoutX((xP+30+x+30)/2);
		lblWeight.setLayoutY((yP+30+y+30)/2);
		
		//create directional arrow on line
		//Line arrowUp = new Line(x+15, y+25, x+30, y+30);
		//Line arrowDown = new Line(x+25, y+15, x+30, y+30);
		
		//add line to pane
		//pane.getChildren().add(arrowUp);
		//pane.getChildren().add(arrowDown);
		pane.getChildren().add(line);
		pane.getChildren().add(lblWeight);
	}
	

	static int loop = 0;

	private static void displayNodes(Tree<Choice> tree, Position<Choice> choice) throws Exception 
	{
		
		Iterator<Position<Choice>> iterator = tree.children(choice);

		if(tree.parent(choice).get(0) == null)
		{
			choice.element().setX(0);
			choice.element().setY((int)scrollPane.getPrefHeight()/2);

			addNode(0, choice.element().getY(), choice.element());
		}
		
		while(iterator.hasNext())
		{
			//counts at which child you are currently at
			loop++;
			
			Position<Choice> position = iterator.next();
			
			//get depth which is the x axis
			int depth = tree.depth(tree, position)+1;
			
			//calcuate y
			double numChild = tree.getNumChildren(tree.parent(position).get(0));
			
			int parentChoice = 0;
			//determines how a child of one parents should look
			if(tree.parent(position).size() == 1)
			{
				parentChoice = 0;
			}else
			if(tree.parent(position).size() % 2 == 0)//determines how a child of many parents should look - if even
			{
				parentChoice = tree.getNumChildren(tree.parent(position).get(0))/2;
				
			}else//determines how a child of many parents should look - if odd
			{
				parentChoice = (int)(tree.getNumChildren(tree.parent(position).get(0))/2+0.5);
			}
			
			//these 3 if child nodes out evenly
			if(numChild/2 > loop || loop==1)//in lower bound of loop
			{
				//set above parent
				position.element().setY(tree.parent(position).get(parentChoice).element().getY()-200/loop);
			}else
			if(numChild/2 == loop || numChild/2 == loop-0.5)//at centre of loop
			{
				//set same as parent Y axis
				position.element().setY(tree.parent(position).get(parentChoice).element().getY());
			}else
			{
				//set below parent
				position.element().setY((int)(tree.parent(position).get(parentChoice).element().getY()+200/(numChild+1-loop)));
				System.out.println("ID " + position.element().getID()+"   X: "+ position.element().getX()+"   Y: "(tree.parent(position).get(parentChoice).element().getY()+200/(numChild+1-loop));
			}
					
				
			//}
			
			if(loop == numChild)
			{
				loop = 0;
			}
			
			position.element().setX(depth*100);
			System.out.println("ID " + position.element().getID()+"   X: "+ position.element().getX()+"   Y: "+position.element().getY());
			
			//add nodes
			addNode(position.element().getX(), position.element().getY(),position.element());
			
			//add all edges - can have many parents
			for(Position<Choice> c : tree.parent(position))
			{
				addEdge(c.element().getX(),c.element().getY(),position.element().getX(),position.element().getY(),position);
			}
			
			displayNodes(tree, position);
			
		}
		
	}

	static boolean searchResult;
	private static void searchParentVisited(Tree<Choice> tree, Position<Choice> choice, int id) throws Exception 
	{
		Iterator<Position<Choice>> iterator = tree.children(choice);
		//checks if root
		if(tree.parent(choice).get(0) == null)
		{
			//checks if root is search id
			if(id == root.element().id)
			{
				searchResult = true;
				return;
			}
		}
		
		while(iterator.hasNext())
		{
			Position<Choice> position = iterator.next();

			//checks if correct node is found
			if(id == position.element().getID())
			{
				//checks if parent node has been visited before
				for(Position<Choice> c : tree.parent(position))
				{
					searchResult = c.element().getVisited();
					
					if(searchResult)
					{
						return;
					}
				}
				
			}
			
			searchParentVisited(tree, position, id);	
		}	
	}
	
	static boolean searchChildResult;
	private static void searchFellowChildVisited(Tree<Choice> tree, Position<Choice> choice, int id) throws Exception 
	{

		Iterator<Position<Choice>> iterator = tree.children(choice);
		//checks if root
		if(tree.parent(choice).get(0) == null)
		{
			//checks if root is search id
			if(id == root.element().id)
			{
				searchChildResult = true;
				return;
			}
		}
		
		while(iterator.hasNext())
		{
			
			Position<Choice> position = iterator.next();
			//checks if correct node is found
			if(id == position.element().getID())
			{

				//goes over all children of that paren
				Iterator<Position<Choice>> iteratorChild = tree.children(tree.parent(position).get(0));
				
				while(iteratorChild.hasNext())
				{
					
					Position<Choice> positionChild = iteratorChild.next();
					System.out.println(positionChild.element().getID() + "  "+ positionChild.element().getVisited());
					//if child visited, return false
					if(positionChild.element().getVisited())
					{

						searchChildResult = false;
						return;
					}
				}
					

				
			}
			
			searchFellowChildVisited(tree, position, id);	
		}	
		System.out.println("failure");
		
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-04-12 17:35:27.330
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-04-12 17:35:27.332
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-12 17:35:27.628
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------


import java.util.ArrayList;
import java.util.Iterator;

import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.TextArea;
import javafx.scene.input.MouseDragEvent;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.Pane;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Line;
import javafx.scene.shape.Shape;
import javafx.stage.Stage;

public class GraphPane extends StackPane
{
	static Pane pane;
	static int total;
	static TextArea txtTotal;
	static TextArea txtDisplay;
	static GridPane gridPane;
	static GraphPane graphPane;
	static Tree<Choice> tree;
	static Position<Choice> root;
	static ScrollPane scrollPane;
	
	public GraphPane()
	{
		
		graphPane = this;
		gridPane = new GridPane();
		//setting vbox/controls
		VBox vbox = new VBox();
		vbox.setMaxSize(200, 200);
		//setting pane/graph
		pane = new Pane();
		pane.setPrefSize(2000, 2000);
		
		//scrollpane
		scrollPane = new ScrollPane();
		scrollPane.setContent(pane);
		scrollPane.setPrefSize(600, 600);
		//adding both to main borderpane for layout
		gridPane.add(vbox, 0, 0);
		gridPane.add(scrollPane, 0, 1);

		
		//adding controls to vbox
		Label lblTotal = new Label("Total:");
		txtTotal = new TextArea();
		txtTotal.setPrefSize(getPrefWidth(), 20);
		
		Label lblDisplay = new Label("Display:");
		txtDisplay = new TextArea();
		txtDisplay.setPrefSize(getPrefWidth(), 20);
		
		vbox.setPadding(getInsets());
		
		vbox.getChildren().add(lblTotal);
		vbox.getChildren().add(txtTotal);
		vbox.getChildren().add(lblDisplay);
		vbox.getChildren().add(txtDisplay);
		

		this.getChildren().add(gridPane);
		Choice c1 = new Choice();
		tree = new Tree<Choice>(c1);
		root = tree.root();
		try 
		{
			Choice c2 = new Choice();
			Choice c3 = new Choice();
			Choice c4 = new Choice();
			Choice c5 = new Choice();
			Choice c6 = new Choice();

			
			Position<Choice> a1 = tree.addElementAsChild(root, c2);
			Position<Choice> a2 = tree.addElementAsChild(root, c3);
			//Position<Choice> a3 =tree.addElementAsChild(root, c4);

			//ArrayList<Position<Choice>> aL = new ArrayList<Position<Choice>>();
			//aL.add(a1);
			//aL.add(a2);
			////aL.add(a3);
			
			Position<Choice> b1 =tree.addElementAsChild(a1, c5);
			//Position<Choice> b1 =tree.addListParents(aL, c5);
			//Position<Choice> d1 =tree.addElementAsChild(b1, c6);

			displayNodes(tree, root);
			System.out.println(tree.preOrderElementTraversal(tree, root));
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		////
		
	}
	
	final static int nodeSize = 50;
	final static int edgeSize = 50;
	public static void addNode(int x, int y, Choice elem)
	{
		Button button = new Button(""+elem.getID());
		button.setShape(new Circle(10));
		button.setPrefSize(nodeSize,nodeSize);
		button.setLayoutX(x);
		button.setLayoutY(y);
		pane.getChildren().add(button);
		button.setTextFill(null);
		button.setOnAction(new EventHandler <ActionEvent>()
		{
			
			@Override
			public void handle(ActionEvent event) 
			{
				//total += elem;
				txtTotal.setText(""+total);
				graphPane.setVisible(false);
				
				//this is to search if parent has been visisted
				searchResult = false;
				//this is to search if a fellow child has been visited
				searchChildResult = true;
				try 
				{
					searchParentVisited(tree,  root, Integer.parseInt(button.getText()));
					searchFellowChildVisited(tree,  root, Integer.parseInt(button.getText()));
	
				} catch (Exception e) 
				{
					e.printStackTrace();
				}
				
				

				
				//if parent not visited yet
				if(!searchResult)
				{
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: Parent of Choice not selected yet.", graphPane);
					Stage secondStage = new Stage();
					
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
			        return;
					
				}else
				if(!searchChildResult)//now check if a fellow child has already been chosen
				{
								
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: You cannot choose more than one choice at the same depth", graphPane);
					Stage secondStage = new Stage();
					
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
			        return;
					
					
				}else
				if(button.getTextFill() == null)//if button viable
				{
					//opens main menu
					InfoPane root = new InfoPane(elem, button, graphPane);
					Stage secondStage = new Stage();
					
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Info");
			        secondStage.show();
					
				}else
				if(button.getTextFill().equals(Color.BLUE))//if buttons already been selected
				{
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: This option has already been selected.", graphPane);
					Stage secondStage = new Stage();
					
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
				}else
				{

					
				}
			}			
		});
	}
	
	public static void addEdge(int xP, int yP,int x, int y, Position<Choice> choice)
	{	
		//System.out.println(xP +"-"+yP+"-"+x+"-"+y);
		//create line/edge from start to end
		Line line = new Line(xP+30, yP+30, x+30, y+30);
		Label lblWeight = new Label(""+choice.element().getWeight());
		lblWeight.setLayoutX((xP+30+x+30)/2);
		lblWeight.setLayoutY((yP+30+y+30)/2);
		
		//create directional arrow on line
		//Line arrowUp = new Line(x+15, y+25, x+30, y+30);
		//Line arrowDown = new Line(x+25, y+15, x+30, y+30);
		
		//add line to pane
		//pane.getChildren().add(arrowUp);
		//pane.getChildren().add(arrowDown);
		pane.getChildren().add(line);
		pane.getChildren().add(lblWeight);
	}
	

	static int loop = 0;

	private static void displayNodes(Tree<Choice> tree, Position<Choice> choice) throws Exception 
	{
		
		Iterator<Position<Choice>> iterator = tree.children(choice);

		if(tree.parent(choice).get(0) == null)
		{
			choice.element().setX(0);
			choice.element().setY((int)scrollPane.getPrefHeight()/2);

			addNode(0, choice.element().getY(), choice.element());
		}
		
		while(iterator.hasNext())
		{
			//counts at which child you are currently at
			loop++;
			
			Position<Choice> position = iterator.next();
			
			//get depth which is the x axis
			int depth = tree.depth(tree, position)+1;
			
			//calcuate y
			double numChild = tree.getNumChildren(tree.parent(position).get(0));
			
			int parentChoice = 0;
			//determines how a child of one parents should look
			if(tree.parent(position).size() == 1)
			{
				parentChoice = 0;
			}else
			if(tree.parent(position).size() % 2 == 0)//determines how a child of many parents should look - if even
			{
				parentChoice = tree.getNumChildren(tree.parent(position).get(0))/2;
				
			}else//determines how a child of many parents should look - if odd
			{
				parentChoice = (int)(tree.getNumChildren(tree.parent(position).get(0))/2+0.5);
			}
			
			//these 3 if child nodes out evenly
			if(numChild/2 > loop || loop==1)//in lower bound of loop
			{
				//set above parent
				position.element().setY(tree.parent(position).get(parentChoice).element().getY()-200/loop);
			}else
			if(numChild/2 == loop || numChild/2 == loop-0.5)//at centre of loop
			{
				//set same as parent Y axis
				position.element().setY(tree.parent(position).get(parentChoice).element().getY());
			}else
			{
				//set below parent
				position.element().setY((int)(tree.parent(position).get(parentChoice).element().getY()+200/(numChild+1-loop)));
				System.out.println("ID " + position.element().getID()+"   X: "+ position.element().getX()+"   Y: "(tree.parent(position).get(parentChoice).element().getY()+200/(numChild+1-loop));
			}
					
				
			//}
			
			if(loop == numChild)
			{
				loop = 0;
			}
			
			position.element().setX(depth*100);
			System.out.println("ID " + position.element().getID()+"   X: "+ position.element().getX()+"   Y: "+position.element().getY());
			
			//add nodes
			addNode(position.element().getX(), position.element().getY(),position.element());
			
			//add all edges - can have many parents
			for(Position<Choice> c : tree.parent(position))
			{
				addEdge(c.element().getX(),c.element().getY(),position.element().getX(),position.element().getY(),position);
			}
			
			displayNodes(tree, position);
			
		}
		
	}

	static boolean searchResult;
	private static void searchParentVisited(Tree<Choice> tree, Position<Choice> choice, int id) throws Exception 
	{
		Iterator<Position<Choice>> iterator = tree.children(choice);
		//checks if root
		if(tree.parent(choice).get(0) == null)
		{
			//checks if root is search id
			if(id == root.element().id)
			{
				searchResult = true;
				return;
			}
		}
		
		while(iterator.hasNext())
		{
			Position<Choice> position = iterator.next();

			//checks if correct node is found
			if(id == position.element().getID())
			{
				//checks if parent node has been visited before
				for(Position<Choice> c : tree.parent(position))
				{
					searchResult = c.element().getVisited();
					
					if(searchResult)
					{
						return;
					}
				}
				
			}
			
			searchParentVisited(tree, position, id);	
		}	
	}
	
	static boolean searchChildResult;
	private static void searchFellowChildVisited(Tree<Choice> tree, Position<Choice> choice, int id) throws Exception 
	{

		Iterator<Position<Choice>> iterator = tree.children(choice);
		//checks if root
		if(tree.parent(choice).get(0) == null)
		{
			//checks if root is search id
			if(id == root.element().id)
			{
				searchChildResult = true;
				return;
			}
		}
		
		while(iterator.hasNext())
		{
			
			Position<Choice> position = iterator.next();
			//checks if correct node is found
			if(id == position.element().getID())
			{

				//goes over all children of that paren
				Iterator<Position<Choice>> iteratorChild = tree.children(tree.parent(position).get(0));
				
				while(iteratorChild.hasNext())
				{
					
					Position<Choice> positionChild = iteratorChild.next();
					System.out.println(positionChild.element().getID() + "  "+ positionChild.element().getVisited());
					//if child visited, return false
					if(positionChild.element().getVisited())
					{

						searchChildResult = false;
						return;
					}
				}
					

				
			}
			
			searchFellowChildVisited(tree, position, id);	
		}	
		System.out.println("failure");
		
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-12 17:35:27.630
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-12 17:35:27.634
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-12 17:35:30.167
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------


import java.util.ArrayList;
import java.util.Iterator;

import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.TextArea;
import javafx.scene.input.MouseDragEvent;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.Pane;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Line;
import javafx.scene.shape.Shape;
import javafx.stage.Stage;

public class GraphPane extends StackPane
{
	static Pane pane;
	static int total;
	static TextArea txtTotal;
	static TextArea txtDisplay;
	static GridPane gridPane;
	static GraphPane graphPane;
	static Tree<Choice> tree;
	static Position<Choice> root;
	static ScrollPane scrollPane;
	
	public GraphPane()
	{
		
		graphPane = this;
		gridPane = new GridPane();
		//setting vbox/controls
		VBox vbox = new VBox();
		vbox.setMaxSize(200, 200);
		//setting pane/graph
		pane = new Pane();
		pane.setPrefSize(2000, 2000);
		
		//scrollpane
		scrollPane = new ScrollPane();
		scrollPane.setContent(pane);
		scrollPane.setPrefSize(600, 600);
		//adding both to main borderpane for layout
		gridPane.add(vbox, 0, 0);
		gridPane.add(scrollPane, 0, 1);

		
		//adding controls to vbox
		Label lblTotal = new Label("Total:");
		txtTotal = new TextArea();
		txtTotal.setPrefSize(getPrefWidth(), 20);
		
		Label lblDisplay = new Label("Display:");
		txtDisplay = new TextArea();
		txtDisplay.setPrefSize(getPrefWidth(), 20);
		
		vbox.setPadding(getInsets());
		
		vbox.getChildren().add(lblTotal);
		vbox.getChildren().add(txtTotal);
		vbox.getChildren().add(lblDisplay);
		vbox.getChildren().add(txtDisplay);
		

		this.getChildren().add(gridPane);
		Choice c1 = new Choice();
		tree = new Tree<Choice>(c1);
		root = tree.root();
		try 
		{
			Choice c2 = new Choice();
			Choice c3 = new Choice();
			Choice c4 = new Choice();
			Choice c5 = new Choice();
			Choice c6 = new Choice();

			
			Position<Choice> a1 = tree.addElementAsChild(root, c2);
			Position<Choice> a2 = tree.addElementAsChild(root, c3);
			//Position<Choice> a3 =tree.addElementAsChild(root, c4);

			//ArrayList<Position<Choice>> aL = new ArrayList<Position<Choice>>();
			//aL.add(a1);
			//aL.add(a2);
			////aL.add(a3);
			
			Position<Choice> b1 =tree.addElementAsChild(a1, c5);
			//Position<Choice> b1 =tree.addListParents(aL, c5);
			//Position<Choice> d1 =tree.addElementAsChild(b1, c6);

			displayNodes(tree, root);
			System.out.println(tree.preOrderElementTraversal(tree, root));
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		////
		
	}
	
	final static int nodeSize = 50;
	final static int edgeSize = 50;
	public static void addNode(int x, int y, Choice elem)
	{
		Button button = new Button(""+elem.getID());
		button.setShape(new Circle(10));
		button.setPrefSize(nodeSize,nodeSize);
		button.setLayoutX(x);
		button.setLayoutY(y);
		pane.getChildren().add(button);
		button.setTextFill(null);
		button.setOnAction(new EventHandler <ActionEvent>()
		{
			
			@Override
			public void handle(ActionEvent event) 
			{
				//total += elem;
				txtTotal.setText(""+total);
				graphPane.setVisible(false);
				
				//this is to search if parent has been visisted
				searchResult = false;
				//this is to search if a fellow child has been visited
				searchChildResult = true;
				try 
				{
					searchParentVisited(tree,  root, Integer.parseInt(button.getText()));
					searchFellowChildVisited(tree,  root, Integer.parseInt(button.getText()));
	
				} catch (Exception e) 
				{
					e.printStackTrace();
				}
				
				

				
				//if parent not visited yet
				if(!searchResult)
				{
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: Parent of Choice not selected yet.", graphPane);
					Stage secondStage = new Stage();
					
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
			        return;
					
				}else
				if(!searchChildResult)//now check if a fellow child has already been chosen
				{
								
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: You cannot choose more than one choice at the same depth", graphPane);
					Stage secondStage = new Stage();
					
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
			        return;
					
					
				}else
				if(button.getTextFill() == null)//if button viable
				{
					//opens main menu
					InfoPane root = new InfoPane(elem, button, graphPane);
					Stage secondStage = new Stage();
					
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Info");
			        secondStage.show();
					
				}else
				if(button.getTextFill().equals(Color.BLUE))//if buttons already been selected
				{
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: This option has already been selected.", graphPane);
					Stage secondStage = new Stage();
					
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
				}else
				{

					
				}
			}			
		});
	}
	
	public static void addEdge(int xP, int yP,int x, int y, Position<Choice> choice)
	{	
		//System.out.println(xP +"-"+yP+"-"+x+"-"+y);
		//create line/edge from start to end
		Line line = new Line(xP+30, yP+30, x+30, y+30);
		Label lblWeight = new Label(""+choice.element().getWeight());
		lblWeight.setLayoutX((xP+30+x+30)/2);
		lblWeight.setLayoutY((yP+30+y+30)/2);
		
		//create directional arrow on line
		//Line arrowUp = new Line(x+15, y+25, x+30, y+30);
		//Line arrowDown = new Line(x+25, y+15, x+30, y+30);
		
		//add line to pane
		//pane.getChildren().add(arrowUp);
		//pane.getChildren().add(arrowDown);
		pane.getChildren().add(line);
		pane.getChildren().add(lblWeight);
	}
	

	static int loop = 0;

	private static void displayNodes(Tree<Choice> tree, Position<Choice> choice) throws Exception 
	{
		
		Iterator<Position<Choice>> iterator = tree.children(choice);

		if(tree.parent(choice).get(0) == null)
		{
			choice.element().setX(0);
			choice.element().setY((int)scrollPane.getPrefHeight()/2);

			addNode(0, choice.element().getY(), choice.element());
		}
		
		while(iterator.hasNext())
		{
			//counts at which child you are currently at
			loop++;
			
			Position<Choice> position = iterator.next();
			
			//get depth which is the x axis
			int depth = tree.depth(tree, position)+1;
			
			//calcuate y
			double numChild = tree.getNumChildren(tree.parent(position).get(0));
			
			int parentChoice = 0;
			//determines how a child of one parents should look
			if(tree.parent(position).size() == 1)
			{
				parentChoice = 0;
			}else
			if(tree.parent(position).size() % 2 == 0)//determines how a child of many parents should look - if even
			{
				parentChoice = tree.getNumChildren(tree.parent(position).get(0))/2;
				
			}else//determines how a child of many parents should look - if odd
			{
				parentChoice = (int)(tree.getNumChildren(tree.parent(position).get(0))/2+0.5);
			}
			
			//these 3 if child nodes out evenly
			if(numChild/2 > loop || loop==1)//in lower bound of loop
			{
				//set above parent
				position.element().setY(tree.parent(position).get(parentChoice).element().getY()-200/loop);
			}else
			if(numChild/2 == loop || numChild/2 == loop-0.5)//at centre of loop
			{
				//set same as parent Y axis
				position.element().setY(tree.parent(position).get(parentChoice).element().getY());
			}else
			{
				//set below parent
				position.element().setY((int)(tree.parent(position).get(parentChoice).element().getY()+200/(numChild+1-loop)));
				System.out.println("ID " + position.element().getID()+"   X: "+ position.element().getX()+"   Y: "(tree.parent(position).get(parentChoice).element().getY()+200/(numChild+1-loop));
			}
					
				
			//}
			
			if(loop == numChild)
			{
				loop = 0;
			}
			
			position.element().setX(depth*100);
			System.out.println("ID " + position.element().getID()+"   X: "+ position.element().getX()+"   Y: "+position.element().getY());
			
			//add nodes
			addNode(position.element().getX(), position.element().getY(),position.element());
			
			//add all edges - can have many parents
			for(Position<Choice> c : tree.parent(position))
			{
				addEdge(c.element().getX(),c.element().getY(),position.element().getX(),position.element().getY(),position);
			}
			
			displayNodes(tree, position);
			
		}
		
	}

	static boolean searchResult;
	private static void searchParentVisited(Tree<Choice> tree, Position<Choice> choice, int id) throws Exception 
	{
		Iterator<Position<Choice>> iterator = tree.children(choice);
		//checks if root
		if(tree.parent(choice).get(0) == null)
		{
			//checks if root is search id
			if(id == root.element().id)
			{
				searchResult = true;
				return;
			}
		}
		
		while(iterator.hasNext())
		{
			Position<Choice> position = iterator.next();

			//checks if correct node is found
			if(id == position.element().getID())
			{
				//checks if parent node has been visited before
				for(Position<Choice> c : tree.parent(position))
				{
					searchResult = c.element().getVisited();
					
					if(searchResult)
					{
						return;
					}
				}
				
			}
			
			searchParentVisited(tree, position, id);	
		}	
	}
	
	static boolean searchChildResult;
	private static void searchFellowChildVisited(Tree<Choice> tree, Position<Choice> choice, int id) throws Exception 
	{

		Iterator<Position<Choice>> iterator = tree.children(choice);
		//checks if root
		if(tree.parent(choice).get(0) == null)
		{
			//checks if root is search id
			if(id == root.element().id)
			{
				searchChildResult = true;
				return;
			}
		}
		
		while(iterator.hasNext())
		{
			
			Position<Choice> position = iterator.next();
			//checks if correct node is found
			if(id == position.element().getID())
			{

				//goes over all children of that paren
				Iterator<Position<Choice>> iteratorChild = tree.children(tree.parent(position).get(0));
				
				while(iteratorChild.hasNext())
				{
					
					Position<Choice> positionChild = iteratorChild.next();
					System.out.println(positionChild.element().getID() + "  "+ positionChild.element().getVisited());
					//if child visited, return false
					if(positionChild.element().getVisited())
					{

						searchChildResult = false;
						return;
					}
				}
					

				
			}
			
			searchFellowChildVisited(tree, position, id);	
		}	
		System.out.println("failure");
		
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-12 17:35:30.169
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-12 17:35:30.170
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-12 17:35:32.906
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------


import java.util.ArrayList;
import java.util.Iterator;

import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.TextArea;
import javafx.scene.input.MouseDragEvent;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.Pane;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Line;
import javafx.scene.shape.Shape;
import javafx.stage.Stage;

public class GraphPane extends StackPane
{
	static Pane pane;
	static int total;
	static TextArea txtTotal;
	static TextArea txtDisplay;
	static GridPane gridPane;
	static GraphPane graphPane;
	static Tree<Choice> tree;
	static Position<Choice> root;
	static ScrollPane scrollPane;
	
	public GraphPane()
	{
		
		graphPane = this;
		gridPane = new GridPane();
		//setting vbox/controls
		VBox vbox = new VBox();
		vbox.setMaxSize(200, 200);
		//setting pane/graph
		pane = new Pane();
		pane.setPrefSize(2000, 2000);
		
		//scrollpane
		scrollPane = new ScrollPane();
		scrollPane.setContent(pane);
		scrollPane.setPrefSize(600, 600);
		//adding both to main borderpane for layout
		gridPane.add(vbox, 0, 0);
		gridPane.add(scrollPane, 0, 1);

		
		//adding controls to vbox
		Label lblTotal = new Label("Total:");
		txtTotal = new TextArea();
		txtTotal.setPrefSize(getPrefWidth(), 20);
		
		Label lblDisplay = new Label("Display:");
		txtDisplay = new TextArea();
		txtDisplay.setPrefSize(getPrefWidth(), 20);
		
		vbox.setPadding(getInsets());
		
		vbox.getChildren().add(lblTotal);
		vbox.getChildren().add(txtTotal);
		vbox.getChildren().add(lblDisplay);
		vbox.getChildren().add(txtDisplay);
		

		this.getChildren().add(gridPane);
		Choice c1 = new Choice();
		tree = new Tree<Choice>(c1);
		root = tree.root();
		try 
		{
			Choice c2 = new Choice();
			Choice c3 = new Choice();
			Choice c4 = new Choice();
			Choice c5 = new Choice();
			Choice c6 = new Choice();

			
			Position<Choice> a1 = tree.addElementAsChild(root, c2);
			Position<Choice> a2 = tree.addElementAsChild(root, c3);
			//Position<Choice> a3 =tree.addElementAsChild(root, c4);

			//ArrayList<Position<Choice>> aL = new ArrayList<Position<Choice>>();
			//aL.add(a1);
			//aL.add(a2);
			////aL.add(a3);
			
			Position<Choice> b1 =tree.addElementAsChild(a1, c5);
			//Position<Choice> b1 =tree.addListParents(aL, c5);
			//Position<Choice> d1 =tree.addElementAsChild(b1, c6);

			displayNodes(tree, root);
			System.out.println(tree.preOrderElementTraversal(tree, root));
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		////
		
	}
	
	final static int nodeSize = 50;
	final static int edgeSize = 50;
	public static void addNode(int x, int y, Choice elem)
	{
		Button button = new Button(""+elem.getID());
		button.setShape(new Circle(10));
		button.setPrefSize(nodeSize,nodeSize);
		button.setLayoutX(x);
		button.setLayoutY(y);
		pane.getChildren().add(button);
		button.setTextFill(null);
		button.setOnAction(new EventHandler <ActionEvent>()
		{
			
			@Override
			public void handle(ActionEvent event) 
			{
				//total += elem;
				txtTotal.setText(""+total);
				graphPane.setVisible(false);
				
				//this is to search if parent has been visisted
				searchResult = false;
				//this is to search if a fellow child has been visited
				searchChildResult = true;
				try 
				{
					searchParentVisited(tree,  root, Integer.parseInt(button.getText()));
					searchFellowChildVisited(tree,  root, Integer.parseInt(button.getText()));
	
				} catch (Exception e) 
				{
					e.printStackTrace();
				}
				
				

				
				//if parent not visited yet
				if(!searchResult)
				{
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: Parent of Choice not selected yet.", graphPane);
					Stage secondStage = new Stage();
					
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
			        return;
					
				}else
				if(!searchChildResult)//now check if a fellow child has already been chosen
				{
								
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: You cannot choose more than one choice at the same depth", graphPane);
					Stage secondStage = new Stage();
					
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
			        return;
					
					
				}else
				if(button.getTextFill() == null)//if button viable
				{
					//opens main menu
					InfoPane root = new InfoPane(elem, button, graphPane);
					Stage secondStage = new Stage();
					
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Info");
			        secondStage.show();
					
				}else
				if(button.getTextFill().equals(Color.BLUE))//if buttons already been selected
				{
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: This option has already been selected.", graphPane);
					Stage secondStage = new Stage();
					
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
				}else
				{

					
				}
			}			
		});
	}
	
	public static void addEdge(int xP, int yP,int x, int y, Position<Choice> choice)
	{	
		//System.out.println(xP +"-"+yP+"-"+x+"-"+y);
		//create line/edge from start to end
		Line line = new Line(xP+30, yP+30, x+30, y+30);
		Label lblWeight = new Label(""+choice.element().getWeight());
		lblWeight.setLayoutX((xP+30+x+30)/2);
		lblWeight.setLayoutY((yP+30+y+30)/2);
		
		//create directional arrow on line
		//Line arrowUp = new Line(x+15, y+25, x+30, y+30);
		//Line arrowDown = new Line(x+25, y+15, x+30, y+30);
		
		//add line to pane
		//pane.getChildren().add(arrowUp);
		//pane.getChildren().add(arrowDown);
		pane.getChildren().add(line);
		pane.getChildren().add(lblWeight);
	}
	

	static int loop = 0;

	private static void displayNodes(Tree<Choice> tree, Position<Choice> choice) throws Exception 
	{
		
		Iterator<Position<Choice>> iterator = tree.children(choice);

		if(tree.parent(choice).get(0) == null)
		{
			choice.element().setX(0);
			choice.element().setY((int)scrollPane.getPrefHeight()/2);

			addNode(0, choice.element().getY(), choice.element());
		}
		
		while(iterator.hasNext())
		{
			//counts at which child you are currently at
			loop++;
			
			Position<Choice> position = iterator.next();
			
			//get depth which is the x axis
			int depth = tree.depth(tree, position)+1;
			
			//calcuate y
			double numChild = tree.getNumChildren(tree.parent(position).get(0));
			
			int parentChoice = 0;
			//determines how a child of one parents should look
			if(tree.parent(position).size() == 1)
			{
				parentChoice = 0;
			}else
			if(tree.parent(position).size() % 2 == 0)//determines how a child of many parents should look - if even
			{
				parentChoice = tree.getNumChildren(tree.parent(position).get(0))/2;
				
			}else//determines how a child of many parents should look - if odd
			{
				parentChoice = (int)(tree.getNumChildren(tree.parent(position).get(0))/2+0.5);
			}
			
			//these 3 if child nodes out evenly
			if(numChild/2 > loop || loop==1)//in lower bound of loop
			{
				//set above parent
				position.element().setY(tree.parent(position).get(parentChoice).element().getY()-200/loop);
			}else
			if(numChild/2 == loop || numChild/2 == loop-0.5)//at centre of loop
			{
				//set same as parent Y axis
				position.element().setY(tree.parent(position).get(parentChoice).element().getY());
			}else
			{
				//set below parent
				position.element().setY((int)(tree.parent(position).get(parentChoice).element().getY()+200/(numChild+1-loop)));
				System.out.println("ID " + position.element().getID()+"   Y: "(tree.parent(position).get(parentChoice).element().getY()+200/(numChild+1-loop));
			}
					
				
			//}
			
			if(loop == numChild)
			{
				loop = 0;
			}
			
			position.element().setX(depth*100);
			System.out.println("ID " + position.element().getID()+"   X: "+ position.element().getX()+"   Y: "+position.element().getY());
			
			//add nodes
			addNode(position.element().getX(), position.element().getY(),position.element());
			
			//add all edges - can have many parents
			for(Position<Choice> c : tree.parent(position))
			{
				addEdge(c.element().getX(),c.element().getY(),position.element().getX(),position.element().getY(),position);
			}
			
			displayNodes(tree, position);
			
		}
		
	}

	static boolean searchResult;
	private static void searchParentVisited(Tree<Choice> tree, Position<Choice> choice, int id) throws Exception 
	{
		Iterator<Position<Choice>> iterator = tree.children(choice);
		//checks if root
		if(tree.parent(choice).get(0) == null)
		{
			//checks if root is search id
			if(id == root.element().id)
			{
				searchResult = true;
				return;
			}
		}
		
		while(iterator.hasNext())
		{
			Position<Choice> position = iterator.next();

			//checks if correct node is found
			if(id == position.element().getID())
			{
				//checks if parent node has been visited before
				for(Position<Choice> c : tree.parent(position))
				{
					searchResult = c.element().getVisited();
					
					if(searchResult)
					{
						return;
					}
				}
				
			}
			
			searchParentVisited(tree, position, id);	
		}	
	}
	
	static boolean searchChildResult;
	private static void searchFellowChildVisited(Tree<Choice> tree, Position<Choice> choice, int id) throws Exception 
	{

		Iterator<Position<Choice>> iterator = tree.children(choice);
		//checks if root
		if(tree.parent(choice).get(0) == null)
		{
			//checks if root is search id
			if(id == root.element().id)
			{
				searchChildResult = true;
				return;
			}
		}
		
		while(iterator.hasNext())
		{
			
			Position<Choice> position = iterator.next();
			//checks if correct node is found
			if(id == position.element().getID())
			{

				//goes over all children of that paren
				Iterator<Position<Choice>> iteratorChild = tree.children(tree.parent(position).get(0));
				
				while(iteratorChild.hasNext())
				{
					
					Position<Choice> positionChild = iteratorChild.next();
					System.out.println(positionChild.element().getID() + "  "+ positionChild.element().getVisited());
					//if child visited, return false
					if(positionChild.element().getVisited())
					{

						searchChildResult = false;
						return;
					}
				}
					

				
			}
			
			searchFellowChildVisited(tree, position, id);	
		}	
		System.out.println("failure");
		
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-04-12 17:35:32.908
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-04-12 17:35:32.909
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-12 17:35:33.095
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------


import java.util.ArrayList;
import java.util.Iterator;

import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.TextArea;
import javafx.scene.input.MouseDragEvent;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.Pane;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Line;
import javafx.scene.shape.Shape;
import javafx.stage.Stage;

public class GraphPane extends StackPane
{
	static Pane pane;
	static int total;
	static TextArea txtTotal;
	static TextArea txtDisplay;
	static GridPane gridPane;
	static GraphPane graphPane;
	static Tree<Choice> tree;
	static Position<Choice> root;
	static ScrollPane scrollPane;
	
	public GraphPane()
	{
		
		graphPane = this;
		gridPane = new GridPane();
		//setting vbox/controls
		VBox vbox = new VBox();
		vbox.setMaxSize(200, 200);
		//setting pane/graph
		pane = new Pane();
		pane.setPrefSize(2000, 2000);
		
		//scrollpane
		scrollPane = new ScrollPane();
		scrollPane.setContent(pane);
		scrollPane.setPrefSize(600, 600);
		//adding both to main borderpane for layout
		gridPane.add(vbox, 0, 0);
		gridPane.add(scrollPane, 0, 1);

		
		//adding controls to vbox
		Label lblTotal = new Label("Total:");
		txtTotal = new TextArea();
		txtTotal.setPrefSize(getPrefWidth(), 20);
		
		Label lblDisplay = new Label("Display:");
		txtDisplay = new TextArea();
		txtDisplay.setPrefSize(getPrefWidth(), 20);
		
		vbox.setPadding(getInsets());
		
		vbox.getChildren().add(lblTotal);
		vbox.getChildren().add(txtTotal);
		vbox.getChildren().add(lblDisplay);
		vbox.getChildren().add(txtDisplay);
		

		this.getChildren().add(gridPane);
		Choice c1 = new Choice();
		tree = new Tree<Choice>(c1);
		root = tree.root();
		try 
		{
			Choice c2 = new Choice();
			Choice c3 = new Choice();
			Choice c4 = new Choice();
			Choice c5 = new Choice();
			Choice c6 = new Choice();

			
			Position<Choice> a1 = tree.addElementAsChild(root, c2);
			Position<Choice> a2 = tree.addElementAsChild(root, c3);
			//Position<Choice> a3 =tree.addElementAsChild(root, c4);

			//ArrayList<Position<Choice>> aL = new ArrayList<Position<Choice>>();
			//aL.add(a1);
			//aL.add(a2);
			////aL.add(a3);
			
			Position<Choice> b1 =tree.addElementAsChild(a1, c5);
			//Position<Choice> b1 =tree.addListParents(aL, c5);
			//Position<Choice> d1 =tree.addElementAsChild(b1, c6);

			displayNodes(tree, root);
			System.out.println(tree.preOrderElementTraversal(tree, root));
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		////
		
	}
	
	final static int nodeSize = 50;
	final static int edgeSize = 50;
	public static void addNode(int x, int y, Choice elem)
	{
		Button button = new Button(""+elem.getID());
		button.setShape(new Circle(10));
		button.setPrefSize(nodeSize,nodeSize);
		button.setLayoutX(x);
		button.setLayoutY(y);
		pane.getChildren().add(button);
		button.setTextFill(null);
		button.setOnAction(new EventHandler <ActionEvent>()
		{
			
			@Override
			public void handle(ActionEvent event) 
			{
				//total += elem;
				txtTotal.setText(""+total);
				graphPane.setVisible(false);
				
				//this is to search if parent has been visisted
				searchResult = false;
				//this is to search if a fellow child has been visited
				searchChildResult = true;
				try 
				{
					searchParentVisited(tree,  root, Integer.parseInt(button.getText()));
					searchFellowChildVisited(tree,  root, Integer.parseInt(button.getText()));
	
				} catch (Exception e) 
				{
					e.printStackTrace();
				}
				
				

				
				//if parent not visited yet
				if(!searchResult)
				{
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: Parent of Choice not selected yet.", graphPane);
					Stage secondStage = new Stage();
					
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
			        return;
					
				}else
				if(!searchChildResult)//now check if a fellow child has already been chosen
				{
								
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: You cannot choose more than one choice at the same depth", graphPane);
					Stage secondStage = new Stage();
					
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
			        return;
					
					
				}else
				if(button.getTextFill() == null)//if button viable
				{
					//opens main menu
					InfoPane root = new InfoPane(elem, button, graphPane);
					Stage secondStage = new Stage();
					
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Info");
			        secondStage.show();
					
				}else
				if(button.getTextFill().equals(Color.BLUE))//if buttons already been selected
				{
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: This option has already been selected.", graphPane);
					Stage secondStage = new Stage();
					
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
				}else
				{

					
				}
			}			
		});
	}
	
	public static void addEdge(int xP, int yP,int x, int y, Position<Choice> choice)
	{	
		//System.out.println(xP +"-"+yP+"-"+x+"-"+y);
		//create line/edge from start to end
		Line line = new Line(xP+30, yP+30, x+30, y+30);
		Label lblWeight = new Label(""+choice.element().getWeight());
		lblWeight.setLayoutX((xP+30+x+30)/2);
		lblWeight.setLayoutY((yP+30+y+30)/2);
		
		//create directional arrow on line
		//Line arrowUp = new Line(x+15, y+25, x+30, y+30);
		//Line arrowDown = new Line(x+25, y+15, x+30, y+30);
		
		//add line to pane
		//pane.getChildren().add(arrowUp);
		//pane.getChildren().add(arrowDown);
		pane.getChildren().add(line);
		pane.getChildren().add(lblWeight);
	}
	

	static int loop = 0;

	private static void displayNodes(Tree<Choice> tree, Position<Choice> choice) throws Exception 
	{
		
		Iterator<Position<Choice>> iterator = tree.children(choice);

		if(tree.parent(choice).get(0) == null)
		{
			choice.element().setX(0);
			choice.element().setY((int)scrollPane.getPrefHeight()/2);

			addNode(0, choice.element().getY(), choice.element());
		}
		
		while(iterator.hasNext())
		{
			//counts at which child you are currently at
			loop++;
			
			Position<Choice> position = iterator.next();
			
			//get depth which is the x axis
			int depth = tree.depth(tree, position)+1;
			
			//calcuate y
			double numChild = tree.getNumChildren(tree.parent(position).get(0));
			
			int parentChoice = 0;
			//determines how a child of one parents should look
			if(tree.parent(position).size() == 1)
			{
				parentChoice = 0;
			}else
			if(tree.parent(position).size() % 2 == 0)//determines how a child of many parents should look - if even
			{
				parentChoice = tree.getNumChildren(tree.parent(position).get(0))/2;
				
			}else//determines how a child of many parents should look - if odd
			{
				parentChoice = (int)(tree.getNumChildren(tree.parent(position).get(0))/2+0.5);
			}
			
			//these 3 if child nodes out evenly
			if(numChild/2 > loop || loop==1)//in lower bound of loop
			{
				//set above parent
				position.element().setY(tree.parent(position).get(parentChoice).element().getY()-200/loop);
			}else
			if(numChild/2 == loop || numChild/2 == loop-0.5)//at centre of loop
			{
				//set same as parent Y axis
				position.element().setY(tree.parent(position).get(parentChoice).element().getY());
			}else
			{
				//set below parent
				position.element().setY((int)(tree.parent(position).get(parentChoice).element().getY()+200/(numChild+1-loop)));
				System.out.println("ID " + position.element().getID()+"   Y: "(tree.parent(position).get(parentChoice).element().getY()+200/(numChild+1-loop));
			}
					
				
			//}
			
			if(loop == numChild)
			{
				loop = 0;
			}
			
			position.element().setX(depth*100);
			System.out.println("ID " + position.element().getID()+"   X: "+ position.element().getX()+"   Y: "+position.element().getY());
			
			//add nodes
			addNode(position.element().getX(), position.element().getY(),position.element());
			
			//add all edges - can have many parents
			for(Position<Choice> c : tree.parent(position))
			{
				addEdge(c.element().getX(),c.element().getY(),position.element().getX(),position.element().getY(),position);
			}
			
			displayNodes(tree, position);
			
		}
		
	}

	static boolean searchResult;
	private static void searchParentVisited(Tree<Choice> tree, Position<Choice> choice, int id) throws Exception 
	{
		Iterator<Position<Choice>> iterator = tree.children(choice);
		//checks if root
		if(tree.parent(choice).get(0) == null)
		{
			//checks if root is search id
			if(id == root.element().id)
			{
				searchResult = true;
				return;
			}
		}
		
		while(iterator.hasNext())
		{
			Position<Choice> position = iterator.next();

			//checks if correct node is found
			if(id == position.element().getID())
			{
				//checks if parent node has been visited before
				for(Position<Choice> c : tree.parent(position))
				{
					searchResult = c.element().getVisited();
					
					if(searchResult)
					{
						return;
					}
				}
				
			}
			
			searchParentVisited(tree, position, id);	
		}	
	}
	
	static boolean searchChildResult;
	private static void searchFellowChildVisited(Tree<Choice> tree, Position<Choice> choice, int id) throws Exception 
	{

		Iterator<Position<Choice>> iterator = tree.children(choice);
		//checks if root
		if(tree.parent(choice).get(0) == null)
		{
			//checks if root is search id
			if(id == root.element().id)
			{
				searchChildResult = true;
				return;
			}
		}
		
		while(iterator.hasNext())
		{
			
			Position<Choice> position = iterator.next();
			//checks if correct node is found
			if(id == position.element().getID())
			{

				//goes over all children of that paren
				Iterator<Position<Choice>> iteratorChild = tree.children(tree.parent(position).get(0));
				
				while(iteratorChild.hasNext())
				{
					
					Position<Choice> positionChild = iteratorChild.next();
					System.out.println(positionChild.element().getID() + "  "+ positionChild.element().getVisited());
					//if child visited, return false
					if(positionChild.element().getVisited())
					{

						searchChildResult = false;
						return;
					}
				}
					

				
			}
			
			searchFellowChildVisited(tree, position, id);	
		}	
		System.out.println("failure");
		
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-12 17:35:33.097
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-12 17:35:33.099
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-12 17:35:36.212
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------


import java.util.ArrayList;
import java.util.Iterator;

import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.TextArea;
import javafx.scene.input.MouseDragEvent;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.Pane;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Line;
import javafx.scene.shape.Shape;
import javafx.stage.Stage;

public class GraphPane extends StackPane
{
	static Pane pane;
	static int total;
	static TextArea txtTotal;
	static TextArea txtDisplay;
	static GridPane gridPane;
	static GraphPane graphPane;
	static Tree<Choice> tree;
	static Position<Choice> root;
	static ScrollPane scrollPane;
	
	public GraphPane()
	{
		
		graphPane = this;
		gridPane = new GridPane();
		//setting vbox/controls
		VBox vbox = new VBox();
		vbox.setMaxSize(200, 200);
		//setting pane/graph
		pane = new Pane();
		pane.setPrefSize(2000, 2000);
		
		//scrollpane
		scrollPane = new ScrollPane();
		scrollPane.setContent(pane);
		scrollPane.setPrefSize(600, 600);
		//adding both to main borderpane for layout
		gridPane.add(vbox, 0, 0);
		gridPane.add(scrollPane, 0, 1);

		
		//adding controls to vbox
		Label lblTotal = new Label("Total:");
		txtTotal = new TextArea();
		txtTotal.setPrefSize(getPrefWidth(), 20);
		
		Label lblDisplay = new Label("Display:");
		txtDisplay = new TextArea();
		txtDisplay.setPrefSize(getPrefWidth(), 20);
		
		vbox.setPadding(getInsets());
		
		vbox.getChildren().add(lblTotal);
		vbox.getChildren().add(txtTotal);
		vbox.getChildren().add(lblDisplay);
		vbox.getChildren().add(txtDisplay);
		

		this.getChildren().add(gridPane);
		Choice c1 = new Choice();
		tree = new Tree<Choice>(c1);
		root = tree.root();
		try 
		{
			Choice c2 = new Choice();
			Choice c3 = new Choice();
			Choice c4 = new Choice();
			Choice c5 = new Choice();
			Choice c6 = new Choice();

			
			Position<Choice> a1 = tree.addElementAsChild(root, c2);
			Position<Choice> a2 = tree.addElementAsChild(root, c3);
			//Position<Choice> a3 =tree.addElementAsChild(root, c4);

			//ArrayList<Position<Choice>> aL = new ArrayList<Position<Choice>>();
			//aL.add(a1);
			//aL.add(a2);
			////aL.add(a3);
			
			Position<Choice> b1 =tree.addElementAsChild(a1, c5);
			//Position<Choice> b1 =tree.addListParents(aL, c5);
			//Position<Choice> d1 =tree.addElementAsChild(b1, c6);

			displayNodes(tree, root);
			System.out.println(tree.preOrderElementTraversal(tree, root));
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		////
		
	}
	
	final static int nodeSize = 50;
	final static int edgeSize = 50;
	public static void addNode(int x, int y, Choice elem)
	{
		Button button = new Button(""+elem.getID());
		button.setShape(new Circle(10));
		button.setPrefSize(nodeSize,nodeSize);
		button.setLayoutX(x);
		button.setLayoutY(y);
		pane.getChildren().add(button);
		button.setTextFill(null);
		button.setOnAction(new EventHandler <ActionEvent>()
		{
			
			@Override
			public void handle(ActionEvent event) 
			{
				//total += elem;
				txtTotal.setText(""+total);
				graphPane.setVisible(false);
				
				//this is to search if parent has been visisted
				searchResult = false;
				//this is to search if a fellow child has been visited
				searchChildResult = true;
				try 
				{
					searchParentVisited(tree,  root, Integer.parseInt(button.getText()));
					searchFellowChildVisited(tree,  root, Integer.parseInt(button.getText()));
	
				} catch (Exception e) 
				{
					e.printStackTrace();
				}
				
				

				
				//if parent not visited yet
				if(!searchResult)
				{
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: Parent of Choice not selected yet.", graphPane);
					Stage secondStage = new Stage();
					
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
			        return;
					
				}else
				if(!searchChildResult)//now check if a fellow child has already been chosen
				{
								
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: You cannot choose more than one choice at the same depth", graphPane);
					Stage secondStage = new Stage();
					
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
			        return;
					
					
				}else
				if(button.getTextFill() == null)//if button viable
				{
					//opens main menu
					InfoPane root = new InfoPane(elem, button, graphPane);
					Stage secondStage = new Stage();
					
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Info");
			        secondStage.show();
					
				}else
				if(button.getTextFill().equals(Color.BLUE))//if buttons already been selected
				{
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: This option has already been selected.", graphPane);
					Stage secondStage = new Stage();
					
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
				}else
				{

					
				}
			}			
		});
	}
	
	public static void addEdge(int xP, int yP,int x, int y, Position<Choice> choice)
	{	
		//System.out.println(xP +"-"+yP+"-"+x+"-"+y);
		//create line/edge from start to end
		Line line = new Line(xP+30, yP+30, x+30, y+30);
		Label lblWeight = new Label(""+choice.element().getWeight());
		lblWeight.setLayoutX((xP+30+x+30)/2);
		lblWeight.setLayoutY((yP+30+y+30)/2);
		
		//create directional arrow on line
		//Line arrowUp = new Line(x+15, y+25, x+30, y+30);
		//Line arrowDown = new Line(x+25, y+15, x+30, y+30);
		
		//add line to pane
		//pane.getChildren().add(arrowUp);
		//pane.getChildren().add(arrowDown);
		pane.getChildren().add(line);
		pane.getChildren().add(lblWeight);
	}
	

	static int loop = 0;

	private static void displayNodes(Tree<Choice> tree, Position<Choice> choice) throws Exception 
	{
		
		Iterator<Position<Choice>> iterator = tree.children(choice);

		if(tree.parent(choice).get(0) == null)
		{
			choice.element().setX(0);
			choice.element().setY((int)scrollPane.getPrefHeight()/2);

			addNode(0, choice.element().getY(), choice.element());
		}
		
		while(iterator.hasNext())
		{
			//counts at which child you are currently at
			loop++;
			
			Position<Choice> position = iterator.next();
			
			//get depth which is the x axis
			int depth = tree.depth(tree, position)+1;
			
			//calcuate y
			double numChild = tree.getNumChildren(tree.parent(position).get(0));
			
			int parentChoice = 0;
			//determines how a child of one parents should look
			if(tree.parent(position).size() == 1)
			{
				parentChoice = 0;
			}else
			if(tree.parent(position).size() % 2 == 0)//determines how a child of many parents should look - if even
			{
				parentChoice = tree.getNumChildren(tree.parent(position).get(0))/2;
				
			}else//determines how a child of many parents should look - if odd
			{
				parentChoice = (int)(tree.getNumChildren(tree.parent(position).get(0))/2+0.5);
			}
			
			//these 3 if child nodes out evenly
			if(numChild/2 > loop || loop==1)//in lower bound of loop
			{
				//set above parent
				position.element().setY(tree.parent(position).get(parentChoice).element().getY()-200/loop);
			}else
			if(numChild/2 == loop || numChild/2 == loop-0.5)//at centre of loop
			{
				//set same as parent Y axis
				position.element().setY(tree.parent(position).get(parentChoice).element().getY());
			}else
			{
				//set below parent
				position.element().setY((int)(tree.parent(position).get(parentChoice).element().getY()+200/(numChild+1-loop)));
				System.out.println("ID " + position.element().getID()+"   Y: "(tree.parent(position).get(parentChoice).element().getY()+200/(numChild+1-loop));
			}
					
				
			//}
			
			if(loop == numChild)
			{
				loop = 0;
			}
			
			position.element().setX(depth*100);
			System.out.println("ID " + position.element().getID()+"   X: "+ position.element().getX()+"   Y: "+position.element().getY());
			
			//add nodes
			addNode(position.element().getX(), position.element().getY(),position.element());
			
			//add all edges - can have many parents
			for(Position<Choice> c : tree.parent(position))
			{
				addEdge(c.element().getX(),c.element().getY(),position.element().getX(),position.element().getY(),position);
			}
			
			displayNodes(tree, position);
			
		}
		
	}

	static boolean searchResult;
	private static void searchParentVisited(Tree<Choice> tree, Position<Choice> choice, int id) throws Exception 
	{
		Iterator<Position<Choice>> iterator = tree.children(choice);
		//checks if root
		if(tree.parent(choice).get(0) == null)
		{
			//checks if root is search id
			if(id == root.element().id)
			{
				searchResult = true;
				return;
			}
		}
		
		while(iterator.hasNext())
		{
			Position<Choice> position = iterator.next();

			//checks if correct node is found
			if(id == position.element().getID())
			{
				//checks if parent node has been visited before
				for(Position<Choice> c : tree.parent(position))
				{
					searchResult = c.element().getVisited();
					
					if(searchResult)
					{
						return;
					}
				}
				
			}
			
			searchParentVisited(tree, position, id);	
		}	
	}
	
	static boolean searchChildResult;
	private static void searchFellowChildVisited(Tree<Choice> tree, Position<Choice> choice, int id) throws Exception 
	{

		Iterator<Position<Choice>> iterator = tree.children(choice);
		//checks if root
		if(tree.parent(choice).get(0) == null)
		{
			//checks if root is search id
			if(id == root.element().id)
			{
				searchChildResult = true;
				return;
			}
		}
		
		while(iterator.hasNext())
		{
			
			Position<Choice> position = iterator.next();
			//checks if correct node is found
			if(id == position.element().getID())
			{

				//goes over all children of that paren
				Iterator<Position<Choice>> iteratorChild = tree.children(tree.parent(position).get(0));
				
				while(iteratorChild.hasNext())
				{
					
					Position<Choice> positionChild = iteratorChild.next();
					System.out.println(positionChild.element().getID() + "  "+ positionChild.element().getVisited());
					//if child visited, return false
					if(positionChild.element().getVisited())
					{

						searchChildResult = false;
						return;
					}
				}
					

				
			}
			
			searchFellowChildVisited(tree, position, id);	
		}	
		System.out.println("failure");
		
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-12 17:35:36.214
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-12 17:35:36.215
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-12 17:35:38.828
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------


import java.util.ArrayList;
import java.util.Iterator;

import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.TextArea;
import javafx.scene.input.MouseDragEvent;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.Pane;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Line;
import javafx.scene.shape.Shape;
import javafx.stage.Stage;

public class GraphPane extends StackPane
{
	static Pane pane;
	static int total;
	static TextArea txtTotal;
	static TextArea txtDisplay;
	static GridPane gridPane;
	static GraphPane graphPane;
	static Tree<Choice> tree;
	static Position<Choice> root;
	static ScrollPane scrollPane;
	
	public GraphPane()
	{
		
		graphPane = this;
		gridPane = new GridPane();
		//setting vbox/controls
		VBox vbox = new VBox();
		vbox.setMaxSize(200, 200);
		//setting pane/graph
		pane = new Pane();
		pane.setPrefSize(2000, 2000);
		
		//scrollpane
		scrollPane = new ScrollPane();
		scrollPane.setContent(pane);
		scrollPane.setPrefSize(600, 600);
		//adding both to main borderpane for layout
		gridPane.add(vbox, 0, 0);
		gridPane.add(scrollPane, 0, 1);

		
		//adding controls to vbox
		Label lblTotal = new Label("Total:");
		txtTotal = new TextArea();
		txtTotal.setPrefSize(getPrefWidth(), 20);
		
		Label lblDisplay = new Label("Display:");
		txtDisplay = new TextArea();
		txtDisplay.setPrefSize(getPrefWidth(), 20);
		
		vbox.setPadding(getInsets());
		
		vbox.getChildren().add(lblTotal);
		vbox.getChildren().add(txtTotal);
		vbox.getChildren().add(lblDisplay);
		vbox.getChildren().add(txtDisplay);
		

		this.getChildren().add(gridPane);
		Choice c1 = new Choice();
		tree = new Tree<Choice>(c1);
		root = tree.root();
		try 
		{
			Choice c2 = new Choice();
			Choice c3 = new Choice();
			Choice c4 = new Choice();
			Choice c5 = new Choice();
			Choice c6 = new Choice();

			
			Position<Choice> a1 = tree.addElementAsChild(root, c2);
			Position<Choice> a2 = tree.addElementAsChild(root, c3);
			//Position<Choice> a3 =tree.addElementAsChild(root, c4);

			//ArrayList<Position<Choice>> aL = new ArrayList<Position<Choice>>();
			//aL.add(a1);
			//aL.add(a2);
			////aL.add(a3);
			
			Position<Choice> b1 =tree.addElementAsChild(a1, c5);
			//Position<Choice> b1 =tree.addListParents(aL, c5);
			//Position<Choice> d1 =tree.addElementAsChild(b1, c6);

			displayNodes(tree, root);
			System.out.println(tree.preOrderElementTraversal(tree, root));
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		////
		
	}
	
	final static int nodeSize = 50;
	final static int edgeSize = 50;
	public static void addNode(int x, int y, Choice elem)
	{
		Button button = new Button(""+elem.getID());
		button.setShape(new Circle(10));
		button.setPrefSize(nodeSize,nodeSize);
		button.setLayoutX(x);
		button.setLayoutY(y);
		pane.getChildren().add(button);
		button.setTextFill(null);
		button.setOnAction(new EventHandler <ActionEvent>()
		{
			
			@Override
			public void handle(ActionEvent event) 
			{
				//total += elem;
				txtTotal.setText(""+total);
				graphPane.setVisible(false);
				
				//this is to search if parent has been visisted
				searchResult = false;
				//this is to search if a fellow child has been visited
				searchChildResult = true;
				try 
				{
					searchParentVisited(tree,  root, Integer.parseInt(button.getText()));
					searchFellowChildVisited(tree,  root, Integer.parseInt(button.getText()));
	
				} catch (Exception e) 
				{
					e.printStackTrace();
				}
				
				

				
				//if parent not visited yet
				if(!searchResult)
				{
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: Parent of Choice not selected yet.", graphPane);
					Stage secondStage = new Stage();
					
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
			        return;
					
				}else
				if(!searchChildResult)//now check if a fellow child has already been chosen
				{
								
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: You cannot choose more than one choice at the same depth", graphPane);
					Stage secondStage = new Stage();
					
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
			        return;
					
					
				}else
				if(button.getTextFill() == null)//if button viable
				{
					//opens main menu
					InfoPane root = new InfoPane(elem, button, graphPane);
					Stage secondStage = new Stage();
					
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Info");
			        secondStage.show();
					
				}else
				if(button.getTextFill().equals(Color.BLUE))//if buttons already been selected
				{
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: This option has already been selected.", graphPane);
					Stage secondStage = new Stage();
					
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
				}else
				{

					
				}
			}			
		});
	}
	
	public static void addEdge(int xP, int yP,int x, int y, Position<Choice> choice)
	{	
		//System.out.println(xP +"-"+yP+"-"+x+"-"+y);
		//create line/edge from start to end
		Line line = new Line(xP+30, yP+30, x+30, y+30);
		Label lblWeight = new Label(""+choice.element().getWeight());
		lblWeight.setLayoutX((xP+30+x+30)/2);
		lblWeight.setLayoutY((yP+30+y+30)/2);
		
		//create directional arrow on line
		//Line arrowUp = new Line(x+15, y+25, x+30, y+30);
		//Line arrowDown = new Line(x+25, y+15, x+30, y+30);
		
		//add line to pane
		//pane.getChildren().add(arrowUp);
		//pane.getChildren().add(arrowDown);
		pane.getChildren().add(line);
		pane.getChildren().add(lblWeight);
	}
	

	static int loop = 0;

	private static void displayNodes(Tree<Choice> tree, Position<Choice> choice) throws Exception 
	{
		
		Iterator<Position<Choice>> iterator = tree.children(choice);

		if(tree.parent(choice).get(0) == null)
		{
			choice.element().setX(0);
			choice.element().setY((int)scrollPane.getPrefHeight()/2);

			addNode(0, choice.element().getY(), choice.element());
		}
		
		while(iterator.hasNext())
		{
			//counts at which child you are currently at
			loop++;
			
			Position<Choice> position = iterator.next();
			
			//get depth which is the x axis
			int depth = tree.depth(tree, position)+1;
			
			//calcuate y
			double numChild = tree.getNumChildren(tree.parent(position).get(0));
			
			int parentChoice = 0;
			//determines how a child of one parents should look
			if(tree.parent(position).size() == 1)
			{
				parentChoice = 0;
			}else
			if(tree.parent(position).size() % 2 == 0)//determines how a child of many parents should look - if even
			{
				parentChoice = tree.getNumChildren(tree.parent(position).get(0))/2;
				
			}else//determines how a child of many parents should look - if odd
			{
				parentChoice = (int)(tree.getNumChildren(tree.parent(position).get(0))/2+0.5);
			}
			
			//these 3 if child nodes out evenly
			if(numChild/2 > loop || loop==1)//in lower bound of loop
			{
				//set above parent
				position.element().setY(tree.parent(position).get(parentChoice).element().getY()-200/loop);
			}else
			if(numChild/2 == loop || numChild/2 == loop-0.5)//at centre of loop
			{
				//set same as parent Y axis
				position.element().setY(tree.parent(position).get(parentChoice).element().getY());
			}else
			{
				//set below parent
				position.element().setY((int)(tree.parent(position).get(parentChoice).element().getY()+200/(numChild+1-loop)));
				System.out.println("ID " + position.element().getID()+"   Y: "(tree.parent(position).get(parentChoice).element().getY()+200/(numChild+1-loop));
			}
					
				
			//}
			
			if(loop == numChild)
			{
				loop = 0;
			}
			
			position.element().setX(depth*100);
			System.out.println("ID " + position.element().getID()+"   X: "+ position.element().getX()+"   Y: "+position.element().getY());
			
			//add nodes
			addNode(position.element().getX(), position.element().getY(),position.element());
			
			//add all edges - can have many parents
			for(Position<Choice> c : tree.parent(position))
			{
				addEdge(c.element().getX(),c.element().getY(),position.element().getX(),position.element().getY(),position);
			}
			
			displayNodes(tree, position);
			
		}
		
	}

	static boolean searchResult;
	private static void searchParentVisited(Tree<Choice> tree, Position<Choice> choice, int id) throws Exception 
	{
		Iterator<Position<Choice>> iterator = tree.children(choice);
		//checks if root
		if(tree.parent(choice).get(0) == null)
		{
			//checks if root is search id
			if(id == root.element().id)
			{
				searchResult = true;
				return;
			}
		}
		
		while(iterator.hasNext())
		{
			Position<Choice> position = iterator.next();

			//checks if correct node is found
			if(id == position.element().getID())
			{
				//checks if parent node has been visited before
				for(Position<Choice> c : tree.parent(position))
				{
					searchResult = c.element().getVisited();
					
					if(searchResult)
					{
						return;
					}
				}
				
			}
			
			searchParentVisited(tree, position, id);	
		}	
	}
	
	static boolean searchChildResult;
	private static void searchFellowChildVisited(Tree<Choice> tree, Position<Choice> choice, int id) throws Exception 
	{

		Iterator<Position<Choice>> iterator = tree.children(choice);
		//checks if root
		if(tree.parent(choice).get(0) == null)
		{
			//checks if root is search id
			if(id == root.element().id)
			{
				searchChildResult = true;
				return;
			}
		}
		
		while(iterator.hasNext())
		{
			
			Position<Choice> position = iterator.next();
			//checks if correct node is found
			if(id == position.element().getID())
			{

				//goes over all children of that paren
				Iterator<Position<Choice>> iteratorChild = tree.children(tree.parent(position).get(0));
				
				while(iteratorChild.hasNext())
				{
					
					Position<Choice> positionChild = iteratorChild.next();
					System.out.println(positionChild.element().getID() + "  "+ positionChild.element().getVisited());
					//if child visited, return false
					if(positionChild.element().getVisited())
					{

						searchChildResult = false;
						return;
					}
				}
					

				
			}
			
			searchFellowChildVisited(tree, position, id);	
		}	
		System.out.println("failure");
		
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-04-12 17:35:38.830
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-04-12 17:35:38.833
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-12 17:35:42.510
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------


import java.util.ArrayList;
import java.util.Iterator;

import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.TextArea;
import javafx.scene.input.MouseDragEvent;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.Pane;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Line;
import javafx.scene.shape.Shape;
import javafx.stage.Stage;

public class GraphPane extends StackPane
{
	static Pane pane;
	static int total;
	static TextArea txtTotal;
	static TextArea txtDisplay;
	static GridPane gridPane;
	static GraphPane graphPane;
	static Tree<Choice> tree;
	static Position<Choice> root;
	static ScrollPane scrollPane;
	
	public GraphPane()
	{
		
		graphPane = this;
		gridPane = new GridPane();
		//setting vbox/controls
		VBox vbox = new VBox();
		vbox.setMaxSize(200, 200);
		//setting pane/graph
		pane = new Pane();
		pane.setPrefSize(2000, 2000);
		
		//scrollpane
		scrollPane = new ScrollPane();
		scrollPane.setContent(pane);
		scrollPane.setPrefSize(600, 600);
		//adding both to main borderpane for layout
		gridPane.add(vbox, 0, 0);
		gridPane.add(scrollPane, 0, 1);

		
		//adding controls to vbox
		Label lblTotal = new Label("Total:");
		txtTotal = new TextArea();
		txtTotal.setPrefSize(getPrefWidth(), 20);
		
		Label lblDisplay = new Label("Display:");
		txtDisplay = new TextArea();
		txtDisplay.setPrefSize(getPrefWidth(), 20);
		
		vbox.setPadding(getInsets());
		
		vbox.getChildren().add(lblTotal);
		vbox.getChildren().add(txtTotal);
		vbox.getChildren().add(lblDisplay);
		vbox.getChildren().add(txtDisplay);
		

		this.getChildren().add(gridPane);
		Choice c1 = new Choice();
		tree = new Tree<Choice>(c1);
		root = tree.root();
		try 
		{
			Choice c2 = new Choice();
			Choice c3 = new Choice();
			Choice c4 = new Choice();
			Choice c5 = new Choice();
			Choice c6 = new Choice();

			
			Position<Choice> a1 = tree.addElementAsChild(root, c2);
			Position<Choice> a2 = tree.addElementAsChild(root, c3);
			//Position<Choice> a3 =tree.addElementAsChild(root, c4);

			//ArrayList<Position<Choice>> aL = new ArrayList<Position<Choice>>();
			//aL.add(a1);
			//aL.add(a2);
			////aL.add(a3);
			
			Position<Choice> b1 =tree.addElementAsChild(a1, c5);
			//Position<Choice> b1 =tree.addListParents(aL, c5);
			//Position<Choice> d1 =tree.addElementAsChild(b1, c6);

			displayNodes(tree, root);
			System.out.println(tree.preOrderElementTraversal(tree, root));
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		////
		
	}
	
	final static int nodeSize = 50;
	final static int edgeSize = 50;
	public static void addNode(int x, int y, Choice elem)
	{
		Button button = new Button(""+elem.getID());
		button.setShape(new Circle(10));
		button.setPrefSize(nodeSize,nodeSize);
		button.setLayoutX(x);
		button.setLayoutY(y);
		pane.getChildren().add(button);
		button.setTextFill(null);
		button.setOnAction(new EventHandler <ActionEvent>()
		{
			
			@Override
			public void handle(ActionEvent event) 
			{
				//total += elem;
				txtTotal.setText(""+total);
				graphPane.setVisible(false);
				
				//this is to search if parent has been visisted
				searchResult = false;
				//this is to search if a fellow child has been visited
				searchChildResult = true;
				try 
				{
					searchParentVisited(tree,  root, Integer.parseInt(button.getText()));
					searchFellowChildVisited(tree,  root, Integer.parseInt(button.getText()));
	
				} catch (Exception e) 
				{
					e.printStackTrace();
				}
				
				

				
				//if parent not visited yet
				if(!searchResult)
				{
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: Parent of Choice not selected yet.", graphPane);
					Stage secondStage = new Stage();
					
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
			        return;
					
				}else
				if(!searchChildResult)//now check if a fellow child has already been chosen
				{
								
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: You cannot choose more than one choice at the same depth", graphPane);
					Stage secondStage = new Stage();
					
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
			        return;
					
					
				}else
				if(button.getTextFill() == null)//if button viable
				{
					//opens main menu
					InfoPane root = new InfoPane(elem, button, graphPane);
					Stage secondStage = new Stage();
					
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Info");
			        secondStage.show();
					
				}else
				if(button.getTextFill().equals(Color.BLUE))//if buttons already been selected
				{
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: This option has already been selected.", graphPane);
					Stage secondStage = new Stage();
					
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
				}else
				{

					
				}
			}			
		});
	}
	
	public static void addEdge(int xP, int yP,int x, int y, Position<Choice> choice)
	{	
		//System.out.println(xP +"-"+yP+"-"+x+"-"+y);
		//create line/edge from start to end
		Line line = new Line(xP+30, yP+30, x+30, y+30);
		Label lblWeight = new Label(""+choice.element().getWeight());
		lblWeight.setLayoutX((xP+30+x+30)/2);
		lblWeight.setLayoutY((yP+30+y+30)/2);
		
		//create directional arrow on line
		//Line arrowUp = new Line(x+15, y+25, x+30, y+30);
		//Line arrowDown = new Line(x+25, y+15, x+30, y+30);
		
		//add line to pane
		//pane.getChildren().add(arrowUp);
		//pane.getChildren().add(arrowDown);
		pane.getChildren().add(line);
		pane.getChildren().add(lblWeight);
	}
	

	static int loop = 0;

	private static void displayNodes(Tree<Choice> tree, Position<Choice> choice) throws Exception 
	{
		
		Iterator<Position<Choice>> iterator = tree.children(choice);

		if(tree.parent(choice).get(0) == null)
		{
			choice.element().setX(0);
			choice.element().setY((int)scrollPane.getPrefHeight()/2);

			addNode(0, choice.element().getY(), choice.element());
		}
		
		while(iterator.hasNext())
		{
			//counts at which child you are currently at
			loop++;
			
			Position<Choice> position = iterator.next();
			
			//get depth which is the x axis
			int depth = tree.depth(tree, position)+1;
			
			//calcuate y
			double numChild = tree.getNumChildren(tree.parent(position).get(0));
			
			int parentChoice = 0;
			//determines how a child of one parents should look
			if(tree.parent(position).size() == 1)
			{
				parentChoice = 0;
			}else
			if(tree.parent(position).size() % 2 == 0)//determines how a child of many parents should look - if even
			{
				parentChoice = tree.getNumChildren(tree.parent(position).get(0))/2;
				
			}else//determines how a child of many parents should look - if odd
			{
				parentChoice = (int)(tree.getNumChildren(tree.parent(position).get(0))/2+0.5);
			}
			
			//these 3 if child nodes out evenly
			if(numChild/2 > loop || loop==1)//in lower bound of loop
			{
				//set above parent
				position.element().setY(tree.parent(position).get(parentChoice).element().getY()-200/loop);
			}else
			if(numChild/2 == loop || numChild/2 == loop-0.5)//at centre of loop
			{
				//set same as parent Y axis
				position.element().setY(tree.parent(position).get(parentChoice).element().getY());
			}else
			{
				//set below parent
				position.element().setY((int)(tree.parent(position).get(parentChoice).element().getY()+200/(numChild+1-loop)));
				System.out.println("ID " + position.element().getID()+"   Y: "(tree.parent(position).get(parentChoice).element().getY()+200/(numChild+1-loop));
			}
					
				
			//}
			
			if(loop == numChild)
			{
				loop = 0;
			}
			
			position.element().setX(depth*100);
			System.out.println("ID " + position.element().getID()+"   X: "+ position.element().getX()+"   Y: "+position.element().getY());
			
			//add nodes
			addNode(position.element().getX(), position.element().getY(),position.element());
			
			//add all edges - can have many parents
			for(Position<Choice> c : tree.parent(position))
			{
				addEdge(c.element().getX(),c.element().getY(),position.element().getX(),position.element().getY(),position);
			}
			
			displayNodes(tree, position);
			
		}
		
	}

	static boolean searchResult;
	private static void searchParentVisited(Tree<Choice> tree, Position<Choice> choice, int id) throws Exception 
	{
		Iterator<Position<Choice>> iterator = tree.children(choice);
		//checks if root
		if(tree.parent(choice).get(0) == null)
		{
			//checks if root is search id
			if(id == root.element().id)
			{
				searchResult = true;
				return;
			}
		}
		
		while(iterator.hasNext())
		{
			Position<Choice> position = iterator.next();

			//checks if correct node is found
			if(id == position.element().getID())
			{
				//checks if parent node has been visited before
				for(Position<Choice> c : tree.parent(position))
				{
					searchResult = c.element().getVisited();
					
					if(searchResult)
					{
						return;
					}
				}
				
			}
			
			searchParentVisited(tree, position, id);	
		}	
	}
	
	static boolean searchChildResult;
	private static void searchFellowChildVisited(Tree<Choice> tree, Position<Choice> choice, int id) throws Exception 
	{

		Iterator<Position<Choice>> iterator = tree.children(choice);
		//checks if root
		if(tree.parent(choice).get(0) == null)
		{
			//checks if root is search id
			if(id == root.element().id)
			{
				searchChildResult = true;
				return;
			}
		}
		
		while(iterator.hasNext())
		{
			
			Position<Choice> position = iterator.next();
			//checks if correct node is found
			if(id == position.element().getID())
			{

				//goes over all children of that paren
				Iterator<Position<Choice>> iteratorChild = tree.children(tree.parent(position).get(0));
				
				while(iteratorChild.hasNext())
				{
					
					Position<Choice> positionChild = iteratorChild.next();
					System.out.println(positionChild.element().getID() + "  "+ positionChild.element().getVisited());
					//if child visited, return false
					if(positionChild.element().getVisited())
					{

						searchChildResult = false;
						return;
					}
				}
					

				
			}
			
			searchFellowChildVisited(tree, position, id);	
		}	
		System.out.println("failure");
		
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-12 17:35:42.513
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-12 17:35:42.515
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-12 17:35:42.552
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------


import java.util.ArrayList;
import java.util.Iterator;

import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.TextArea;
import javafx.scene.input.MouseDragEvent;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.Pane;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Line;
import javafx.scene.shape.Shape;
import javafx.stage.Stage;

public class GraphPane extends StackPane
{
	static Pane pane;
	static int total;
	static TextArea txtTotal;
	static TextArea txtDisplay;
	static GridPane gridPane;
	static GraphPane graphPane;
	static Tree<Choice> tree;
	static Position<Choice> root;
	static ScrollPane scrollPane;
	
	public GraphPane()
	{
		
		graphPane = this;
		gridPane = new GridPane();
		//setting vbox/controls
		VBox vbox = new VBox();
		vbox.setMaxSize(200, 200);
		//setting pane/graph
		pane = new Pane();
		pane.setPrefSize(2000, 2000);
		
		//scrollpane
		scrollPane = new ScrollPane();
		scrollPane.setContent(pane);
		scrollPane.setPrefSize(600, 600);
		//adding both to main borderpane for layout
		gridPane.add(vbox, 0, 0);
		gridPane.add(scrollPane, 0, 1);

		
		//adding controls to vbox
		Label lblTotal = new Label("Total:");
		txtTotal = new TextArea();
		txtTotal.setPrefSize(getPrefWidth(), 20);
		
		Label lblDisplay = new Label("Display:");
		txtDisplay = new TextArea();
		txtDisplay.setPrefSize(getPrefWidth(), 20);
		
		vbox.setPadding(getInsets());
		
		vbox.getChildren().add(lblTotal);
		vbox.getChildren().add(txtTotal);
		vbox.getChildren().add(lblDisplay);
		vbox.getChildren().add(txtDisplay);
		

		this.getChildren().add(gridPane);
		Choice c1 = new Choice();
		tree = new Tree<Choice>(c1);
		root = tree.root();
		try 
		{
			Choice c2 = new Choice();
			Choice c3 = new Choice();
			Choice c4 = new Choice();
			Choice c5 = new Choice();
			Choice c6 = new Choice();

			
			Position<Choice> a1 = tree.addElementAsChild(root, c2);
			Position<Choice> a2 = tree.addElementAsChild(root, c3);
			//Position<Choice> a3 =tree.addElementAsChild(root, c4);

			//ArrayList<Position<Choice>> aL = new ArrayList<Position<Choice>>();
			//aL.add(a1);
			//aL.add(a2);
			////aL.add(a3);
			
			Position<Choice> b1 =tree.addElementAsChild(a1, c5);
			//Position<Choice> b1 =tree.addListParents(aL, c5);
			//Position<Choice> d1 =tree.addElementAsChild(b1, c6);

			displayNodes(tree, root);
			System.out.println(tree.preOrderElementTraversal(tree, root));
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		////
		
	}
	
	final static int nodeSize = 50;
	final static int edgeSize = 50;
	public static void addNode(int x, int y, Choice elem)
	{
		Button button = new Button(""+elem.getID());
		button.setShape(new Circle(10));
		button.setPrefSize(nodeSize,nodeSize);
		button.setLayoutX(x);
		button.setLayoutY(y);
		pane.getChildren().add(button);
		button.setTextFill(null);
		button.setOnAction(new EventHandler <ActionEvent>()
		{
			
			@Override
			public void handle(ActionEvent event) 
			{
				//total += elem;
				txtTotal.setText(""+total);
				graphPane.setVisible(false);
				
				//this is to search if parent has been visisted
				searchResult = false;
				//this is to search if a fellow child has been visited
				searchChildResult = true;
				try 
				{
					searchParentVisited(tree,  root, Integer.parseInt(button.getText()));
					searchFellowChildVisited(tree,  root, Integer.parseInt(button.getText()));
	
				} catch (Exception e) 
				{
					e.printStackTrace();
				}
				
				

				
				//if parent not visited yet
				if(!searchResult)
				{
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: Parent of Choice not selected yet.", graphPane);
					Stage secondStage = new Stage();
					
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
			        return;
					
				}else
				if(!searchChildResult)//now check if a fellow child has already been chosen
				{
								
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: You cannot choose more than one choice at the same depth", graphPane);
					Stage secondStage = new Stage();
					
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
			        return;
					
					
				}else
				if(button.getTextFill() == null)//if button viable
				{
					//opens main menu
					InfoPane root = new InfoPane(elem, button, graphPane);
					Stage secondStage = new Stage();
					
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Info");
			        secondStage.show();
					
				}else
				if(button.getTextFill().equals(Color.BLUE))//if buttons already been selected
				{
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: This option has already been selected.", graphPane);
					Stage secondStage = new Stage();
					
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
				}else
				{

					
				}
			}			
		});
	}
	
	public static void addEdge(int xP, int yP,int x, int y, Position<Choice> choice)
	{	
		//System.out.println(xP +"-"+yP+"-"+x+"-"+y);
		//create line/edge from start to end
		Line line = new Line(xP+30, yP+30, x+30, y+30);
		Label lblWeight = new Label(""+choice.element().getWeight());
		lblWeight.setLayoutX((xP+30+x+30)/2);
		lblWeight.setLayoutY((yP+30+y+30)/2);
		
		//create directional arrow on line
		//Line arrowUp = new Line(x+15, y+25, x+30, y+30);
		//Line arrowDown = new Line(x+25, y+15, x+30, y+30);
		
		//add line to pane
		//pane.getChildren().add(arrowUp);
		//pane.getChildren().add(arrowDown);
		pane.getChildren().add(line);
		pane.getChildren().add(lblWeight);
	}
	

	static int loop = 0;

	private static void displayNodes(Tree<Choice> tree, Position<Choice> choice) throws Exception 
	{
		
		Iterator<Position<Choice>> iterator = tree.children(choice);

		if(tree.parent(choice).get(0) == null)
		{
			choice.element().setX(0);
			choice.element().setY((int)scrollPane.getPrefHeight()/2);

			addNode(0, choice.element().getY(), choice.element());
		}
		
		while(iterator.hasNext())
		{
			//counts at which child you are currently at
			loop++;
			
			Position<Choice> position = iterator.next();
			
			//get depth which is the x axis
			int depth = tree.depth(tree, position)+1;
			
			//calcuate y
			double numChild = tree.getNumChildren(tree.parent(position).get(0));
			
			int parentChoice = 0;
			//determines how a child of one parents should look
			if(tree.parent(position).size() == 1)
			{
				parentChoice = 0;
			}else
			if(tree.parent(position).size() % 2 == 0)//determines how a child of many parents should look - if even
			{
				parentChoice = tree.getNumChildren(tree.parent(position).get(0))/2;
				
			}else//determines how a child of many parents should look - if odd
			{
				parentChoice = (int)(tree.getNumChildren(tree.parent(position).get(0))/2+0.5);
			}
			
			//these 3 if child nodes out evenly
			if(numChild/2 > loop || loop==1)//in lower bound of loop
			{
				//set above parent
				position.element().setY(tree.parent(position).get(parentChoice).element().getY()-200/loop);
			}else
			if(numChild/2 == loop || numChild/2 == loop-0.5)//at centre of loop
			{
				//set same as parent Y axis
				position.element().setY(tree.parent(position).get(parentChoice).element().getY());
			}else
			{
				//set below parent
				position.element().setY((int)(tree.parent(position).get(parentChoice).element().getY()+200/(numChild+1-loop)));
				System.out.println("ID " + position.element().getID()+"   Y: "(tree.parent(position).get(parentChoice).element().getY()+200/(numChild+1-loop));
			}
					
				
			//}
			
			if(loop == numChild)
			{
				loop = 0;
			}
			
			position.element().setX(depth*100);
			System.out.println("ID " + position.element().getID()+"   X: "+ position.element().getX()+"   Y: "+position.element().getY());
			
			//add nodes
			addNode(position.element().getX(), position.element().getY(),position.element());
			
			//add all edges - can have many parents
			for(Position<Choice> c : tree.parent(position))
			{
				addEdge(c.element().getX(),c.element().getY(),position.element().getX(),position.element().getY(),position);
			}
			
			displayNodes(tree, position);
			
		}
		
	}

	static boolean searchResult;
	private static void searchParentVisited(Tree<Choice> tree, Position<Choice> choice, int id) throws Exception 
	{
		Iterator<Position<Choice>> iterator = tree.children(choice);
		//checks if root
		if(tree.parent(choice).get(0) == null)
		{
			//checks if root is search id
			if(id == root.element().id)
			{
				searchResult = true;
				return;
			}
		}
		
		while(iterator.hasNext())
		{
			Position<Choice> position = iterator.next();

			//checks if correct node is found
			if(id == position.element().getID())
			{
				//checks if parent node has been visited before
				for(Position<Choice> c : tree.parent(position))
				{
					searchResult = c.element().getVisited();
					
					if(searchResult)
					{
						return;
					}
				}
				
			}
			
			searchParentVisited(tree, position, id);	
		}	
	}
	
	static boolean searchChildResult;
	private static void searchFellowChildVisited(Tree<Choice> tree, Position<Choice> choice, int id) throws Exception 
	{

		Iterator<Position<Choice>> iterator = tree.children(choice);
		//checks if root
		if(tree.parent(choice).get(0) == null)
		{
			//checks if root is search id
			if(id == root.element().id)
			{
				searchChildResult = true;
				return;
			}
		}
		
		while(iterator.hasNext())
		{
			
			Position<Choice> position = iterator.next();
			//checks if correct node is found
			if(id == position.element().getID())
			{

				//goes over all children of that paren
				Iterator<Position<Choice>> iteratorChild = tree.children(tree.parent(position).get(0));
				
				while(iteratorChild.hasNext())
				{
					
					Position<Choice> positionChild = iteratorChild.next();
					System.out.println(positionChild.element().getID() + "  "+ positionChild.element().getVisited());
					//if child visited, return false
					if(positionChild.element().getVisited())
					{

						searchChildResult = false;
						return;
					}
				}
					

				
			}
			
			searchFellowChildVisited(tree, position, id);	
		}	
		System.out.println("failure");
		
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jface.text 4 0 2023-04-12 17:35:42.555
!MESSAGE Unexpected runtime error while computing a text hover
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-12 17:35:42.760
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------


import java.util.ArrayList;
import java.util.Iterator;

import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.TextArea;
import javafx.scene.input.MouseDragEvent;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.Pane;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Line;
import javafx.scene.shape.Shape;
import javafx.stage.Stage;

public class GraphPane extends StackPane
{
	static Pane pane;
	static int total;
	static TextArea txtTotal;
	static TextArea txtDisplay;
	static GridPane gridPane;
	static GraphPane graphPane;
	static Tree<Choice> tree;
	static Position<Choice> root;
	static ScrollPane scrollPane;
	
	public GraphPane()
	{
		
		graphPane = this;
		gridPane = new GridPane();
		//setting vbox/controls
		VBox vbox = new VBox();
		vbox.setMaxSize(200, 200);
		//setting pane/graph
		pane = new Pane();
		pane.setPrefSize(2000, 2000);
		
		//scrollpane
		scrollPane = new ScrollPane();
		scrollPane.setContent(pane);
		scrollPane.setPrefSize(600, 600);
		//adding both to main borderpane for layout
		gridPane.add(vbox, 0, 0);
		gridPane.add(scrollPane, 0, 1);

		
		//adding controls to vbox
		Label lblTotal = new Label("Total:");
		txtTotal = new TextArea();
		txtTotal.setPrefSize(getPrefWidth(), 20);
		
		Label lblDisplay = new Label("Display:");
		txtDisplay = new TextArea();
		txtDisplay.setPrefSize(getPrefWidth(), 20);
		
		vbox.setPadding(getInsets());
		
		vbox.getChildren().add(lblTotal);
		vbox.getChildren().add(txtTotal);
		vbox.getChildren().add(lblDisplay);
		vbox.getChildren().add(txtDisplay);
		

		this.getChildren().add(gridPane);
		Choice c1 = new Choice();
		tree = new Tree<Choice>(c1);
		root = tree.root();
		try 
		{
			Choice c2 = new Choice();
			Choice c3 = new Choice();
			Choice c4 = new Choice();
			Choice c5 = new Choice();
			Choice c6 = new Choice();

			
			Position<Choice> a1 = tree.addElementAsChild(root, c2);
			Position<Choice> a2 = tree.addElementAsChild(root, c3);
			//Position<Choice> a3 =tree.addElementAsChild(root, c4);

			//ArrayList<Position<Choice>> aL = new ArrayList<Position<Choice>>();
			//aL.add(a1);
			//aL.add(a2);
			////aL.add(a3);
			
			Position<Choice> b1 =tree.addElementAsChild(a1, c5);
			//Position<Choice> b1 =tree.addListParents(aL, c5);
			//Position<Choice> d1 =tree.addElementAsChild(b1, c6);

			displayNodes(tree, root);
			System.out.println(tree.preOrderElementTraversal(tree, root));
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		////
		
	}
	
	final static int nodeSize = 50;
	final static int edgeSize = 50;
	public static void addNode(int x, int y, Choice elem)
	{
		Button button = new Button(""+elem.getID());
		button.setShape(new Circle(10));
		button.setPrefSize(nodeSize,nodeSize);
		button.setLayoutX(x);
		button.setLayoutY(y);
		pane.getChildren().add(button);
		button.setTextFill(null);
		button.setOnAction(new EventHandler <ActionEvent>()
		{
			
			@Override
			public void handle(ActionEvent event) 
			{
				//total += elem;
				txtTotal.setText(""+total);
				graphPane.setVisible(false);
				
				//this is to search if parent has been visisted
				searchResult = false;
				//this is to search if a fellow child has been visited
				searchChildResult = true;
				try 
				{
					searchParentVisited(tree,  root, Integer.parseInt(button.getText()));
					searchFellowChildVisited(tree,  root, Integer.parseInt(button.getText()));
	
				} catch (Exception e) 
				{
					e.printStackTrace();
				}
				
				

				
				//if parent not visited yet
				if(!searchResult)
				{
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: Parent of Choice not selected yet.", graphPane);
					Stage secondStage = new Stage();
					
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
			        return;
					
				}else
				if(!searchChildResult)//now check if a fellow child has already been chosen
				{
								
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: You cannot choose more than one choice at the same depth", graphPane);
					Stage secondStage = new Stage();
					
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
			        return;
					
					
				}else
				if(button.getTextFill() == null)//if button viable
				{
					//opens main menu
					InfoPane root = new InfoPane(elem, button, graphPane);
					Stage secondStage = new Stage();
					
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Info");
			        secondStage.show();
					
				}else
				if(button.getTextFill().equals(Color.BLUE))//if buttons already been selected
				{
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: This option has already been selected.", graphPane);
					Stage secondStage = new Stage();
					
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
				}else
				{

					
				}
			}			
		});
	}
	
	public static void addEdge(int xP, int yP,int x, int y, Position<Choice> choice)
	{	
		//System.out.println(xP +"-"+yP+"-"+x+"-"+y);
		//create line/edge from start to end
		Line line = new Line(xP+30, yP+30, x+30, y+30);
		Label lblWeight = new Label(""+choice.element().getWeight());
		lblWeight.setLayoutX((xP+30+x+30)/2);
		lblWeight.setLayoutY((yP+30+y+30)/2);
		
		//create directional arrow on line
		//Line arrowUp = new Line(x+15, y+25, x+30, y+30);
		//Line arrowDown = new Line(x+25, y+15, x+30, y+30);
		
		//add line to pane
		//pane.getChildren().add(arrowUp);
		//pane.getChildren().add(arrowDown);
		pane.getChildren().add(line);
		pane.getChildren().add(lblWeight);
	}
	

	static int loop = 0;

	private static void displayNodes(Tree<Choice> tree, Position<Choice> choice) throws Exception 
	{
		
		Iterator<Position<Choice>> iterator = tree.children(choice);

		if(tree.parent(choice).get(0) == null)
		{
			choice.element().setX(0);
			choice.element().setY((int)scrollPane.getPrefHeight()/2);

			addNode(0, choice.element().getY(), choice.element());
		}
		
		while(iterator.hasNext())
		{
			//counts at which child you are currently at
			loop++;
			
			Position<Choice> position = iterator.next();
			
			//get depth which is the x axis
			int depth = tree.depth(tree, position)+1;
			
			//calcuate y
			double numChild = tree.getNumChildren(tree.parent(position).get(0));
			
			int parentChoice = 0;
			//determines how a child of one parents should look
			if(tree.parent(position).size() == 1)
			{
				parentChoice = 0;
			}else
			if(tree.parent(position).size() % 2 == 0)//determines how a child of many parents should look - if even
			{
				parentChoice = tree.getNumChildren(tree.parent(position).get(0))/2;
				
			}else//determines how a child of many parents should look - if odd
			{
				parentChoice = (int)(tree.getNumChildren(tree.parent(position).get(0))/2+0.5);
			}
			
			//these 3 if child nodes out evenly
			if(numChild/2 > loop || loop==1)//in lower bound of loop
			{
				//set above parent
				position.element().setY(tree.parent(position).get(parentChoice).element().getY()-200/loop);
			}else
			if(numChild/2 == loop || numChild/2 == loop-0.5)//at centre of loop
			{
				//set same as parent Y axis
				position.element().setY(tree.parent(position).get(parentChoice).element().getY());
			}else
			{
				//set below parent
				position.element().setY((int)(tree.parent(position).get(parentChoice).element().getY()+200/(numChild+1-loop)));
				System.out.println("ID " + position.element().getID()+"   Y: "(tree.parent(position).get(parentChoice).element().getY()+200/(numChild+1-loop));
			}
					
				
			//}
			
			if(loop == numChild)
			{
				loop = 0;
			}
			
			position.element().setX(depth*100);
			System.out.println("ID " + position.element().getID()+"   X: "+ position.element().getX()+"   Y: "+position.element().getY());
			
			//add nodes
			addNode(position.element().getX(), position.element().getY(),position.element());
			
			//add all edges - can have many parents
			for(Position<Choice> c : tree.parent(position))
			{
				addEdge(c.element().getX(),c.element().getY(),position.element().getX(),position.element().getY(),position);
			}
			
			displayNodes(tree, position);
			
		}
		
	}

	static boolean searchResult;
	private static void searchParentVisited(Tree<Choice> tree, Position<Choice> choice, int id) throws Exception 
	{
		Iterator<Position<Choice>> iterator = tree.children(choice);
		//checks if root
		if(tree.parent(choice).get(0) == null)
		{
			//checks if root is search id
			if(id == root.element().id)
			{
				searchResult = true;
				return;
			}
		}
		
		while(iterator.hasNext())
		{
			Position<Choice> position = iterator.next();

			//checks if correct node is found
			if(id == position.element().getID())
			{
				//checks if parent node has been visited before
				for(Position<Choice> c : tree.parent(position))
				{
					searchResult = c.element().getVisited();
					
					if(searchResult)
					{
						return;
					}
				}
				
			}
			
			searchParentVisited(tree, position, id);	
		}	
	}
	
	static boolean searchChildResult;
	private static void searchFellowChildVisited(Tree<Choice> tree, Position<Choice> choice, int id) throws Exception 
	{

		Iterator<Position<Choice>> iterator = tree.children(choice);
		//checks if root
		if(tree.parent(choice).get(0) == null)
		{
			//checks if root is search id
			if(id == root.element().id)
			{
				searchChildResult = true;
				return;
			}
		}
		
		while(iterator.hasNext())
		{
			
			Position<Choice> position = iterator.next();
			//checks if correct node is found
			if(id == position.element().getID())
			{

				//goes over all children of that paren
				Iterator<Position<Choice>> iteratorChild = tree.children(tree.parent(position).get(0));
				
				while(iteratorChild.hasNext())
				{
					
					Position<Choice> positionChild = iteratorChild.next();
					System.out.println(positionChild.element().getID() + "  "+ positionChild.element().getVisited());
					//if child visited, return false
					if(positionChild.element().getVisited())
					{

						searchChildResult = false;
						return;
					}
				}
					

				
			}
			
			searchFellowChildVisited(tree, position, id);	
		}	
		System.out.println("failure");
		
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-12 17:35:42.763
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-12 17:35:42.764
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2023-04-12 22:28:12.749 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_ZA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-04-12 22:28:35.467
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-12 22:28:35.467
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-12 22:28:35.467
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-12 22:28:41.743
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\redth'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-04-13 10:19:33.056 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_ZA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-04-13 10:20:03.919
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-13 10:20:03.919
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-13 10:20:03.919
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-13 10:20:10.075
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\redth'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-04-13 11:39:13.244 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_ZA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-04-13 11:39:25.953
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-13 11:39:25.953
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-13 11:39:25.953
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-13 11:39:29.205
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\redth'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2023-04-13 13:51:26.526
!MESSAGE Failed to index /221003350_P07/__MACOSX/._jarFile.jar
!STACK 0
java.util.zip.ZipException: zip END header not found
	at java.base/java.util.zip.ZipFile$Source.findEND(ZipFile.java:1469)
	at java.base/java.util.zip.ZipFile$Source.initCEN(ZipFile.java:1477)
	at java.base/java.util.zip.ZipFile$Source.<init>(ZipFile.java:1315)
	at java.base/java.util.zip.ZipFile$Source.get(ZipFile.java:1277)
	at java.base/java.util.zip.ZipFile$CleanableResource.<init>(ZipFile.java:709)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:243)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:172)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:186)
	at org.eclipse.jdt.internal.core.search.indexing.AddJarFileToIndex.execute(AddJarFileToIndex.java:154)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.run(JobManager.java:478)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.jdt.core 4 0 2023-04-13 13:51:48.074
!MESSAGE Invalid ZIP archive: __MACOSX/._jarFile.jar [in 221003350_P07]

!ENTRY org.eclipse.jdt.core 4 0 2023-04-13 13:51:50.130
!MESSAGE Invalid ZIP archive: __MACOSX/._jarFile.jar [in 221003350_P07]

!ENTRY org.eclipse.jdt.core 4 4 2023-04-13 13:54:20.050
!MESSAGE Failed to index /221003350_P07/__MACOSX/._jarFile.jar
!STACK 0
java.util.zip.ZipException: zip END header not found
	at java.base/java.util.zip.ZipFile$Source.findEND(ZipFile.java:1469)
	at java.base/java.util.zip.ZipFile$Source.initCEN(ZipFile.java:1477)
	at java.base/java.util.zip.ZipFile$Source.<init>(ZipFile.java:1315)
	at java.base/java.util.zip.ZipFile$Source.get(ZipFile.java:1277)
	at java.base/java.util.zip.ZipFile$CleanableResource.<init>(ZipFile.java:709)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:243)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:172)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:186)
	at org.eclipse.jdt.internal.core.search.indexing.AddJarFileToIndex.execute(AddJarFileToIndex.java:154)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.run(JobManager.java:478)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.jdt.core 4 0 2023-04-13 13:54:29.190
!MESSAGE Invalid ZIP archive: __MACOSX/._jarFile.jar [in 221003350_P07]

!ENTRY org.eclipse.jdt.core 4 4 2023-04-13 13:54:29.818
!MESSAGE Failed to index /221003350_P07/__MACOSX/._jarFile.jar
!STACK 0
java.util.zip.ZipException: zip END header not found
	at java.base/java.util.zip.ZipFile$Source.findEND(ZipFile.java:1469)
	at java.base/java.util.zip.ZipFile$Source.initCEN(ZipFile.java:1477)
	at java.base/java.util.zip.ZipFile$Source.<init>(ZipFile.java:1315)
	at java.base/java.util.zip.ZipFile$Source.get(ZipFile.java:1277)
	at java.base/java.util.zip.ZipFile$CleanableResource.<init>(ZipFile.java:709)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:243)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:172)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:186)
	at org.eclipse.jdt.internal.core.search.indexing.AddJarFileToIndex.execute(AddJarFileToIndex.java:154)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.run(JobManager.java:478)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-13 13:55:11.354
!MESSAGE Failed to index /221003350_P07/__MACOSX/._jarFile.jar
!STACK 0
java.util.zip.ZipException: zip END header not found
	at java.base/java.util.zip.ZipFile$Source.findEND(ZipFile.java:1469)
	at java.base/java.util.zip.ZipFile$Source.initCEN(ZipFile.java:1477)
	at java.base/java.util.zip.ZipFile$Source.<init>(ZipFile.java:1315)
	at java.base/java.util.zip.ZipFile$Source.get(ZipFile.java:1277)
	at java.base/java.util.zip.ZipFile$CleanableResource.<init>(ZipFile.java:709)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:243)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:172)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:186)
	at org.eclipse.jdt.internal.core.search.indexing.AddJarFileToIndex.execute(AddJarFileToIndex.java:154)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.run(JobManager.java:478)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-13 13:56:45.806
!MESSAGE Failed to index /221003350_P07/__MACOSX/._jarFile.jar
!STACK 0
java.util.zip.ZipException: zip END header not found
	at java.base/java.util.zip.ZipFile$Source.findEND(ZipFile.java:1469)
	at java.base/java.util.zip.ZipFile$Source.initCEN(ZipFile.java:1477)
	at java.base/java.util.zip.ZipFile$Source.<init>(ZipFile.java:1315)
	at java.base/java.util.zip.ZipFile$Source.get(ZipFile.java:1277)
	at java.base/java.util.zip.ZipFile$CleanableResource.<init>(ZipFile.java:709)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:243)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:172)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:186)
	at org.eclipse.jdt.internal.core.search.indexing.AddJarFileToIndex.execute(AddJarFileToIndex.java:154)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.run(JobManager.java:478)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-13 13:56:47.098
!MESSAGE Failed to index /221003350_P07/__MACOSX/._jarFile.jar
!STACK 0
java.util.zip.ZipException: zip END header not found
	at java.base/java.util.zip.ZipFile$Source.findEND(ZipFile.java:1469)
	at java.base/java.util.zip.ZipFile$Source.initCEN(ZipFile.java:1477)
	at java.base/java.util.zip.ZipFile$Source.<init>(ZipFile.java:1315)
	at java.base/java.util.zip.ZipFile$Source.get(ZipFile.java:1277)
	at java.base/java.util.zip.ZipFile$CleanableResource.<init>(ZipFile.java:709)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:243)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:172)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:186)
	at org.eclipse.jdt.internal.core.search.indexing.AddJarFileToIndex.execute(AddJarFileToIndex.java:154)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.run(JobManager.java:478)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-13 13:57:12.285
!MESSAGE Failed to index /221003350_P07/__MACOSX/._jarFile.jar
!STACK 0
java.util.zip.ZipException: zip END header not found
	at java.base/java.util.zip.ZipFile$Source.findEND(ZipFile.java:1469)
	at java.base/java.util.zip.ZipFile$Source.initCEN(ZipFile.java:1477)
	at java.base/java.util.zip.ZipFile$Source.<init>(ZipFile.java:1315)
	at java.base/java.util.zip.ZipFile$Source.get(ZipFile.java:1277)
	at java.base/java.util.zip.ZipFile$CleanableResource.<init>(ZipFile.java:709)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:243)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:172)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:186)
	at org.eclipse.jdt.internal.core.search.indexing.AddJarFileToIndex.execute(AddJarFileToIndex.java:154)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.run(JobManager.java:478)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-13 13:57:26.909
!MESSAGE Failed to index /221003350_P07/__MACOSX/._jarFile.jar
!STACK 0
java.util.zip.ZipException: zip END header not found
	at java.base/java.util.zip.ZipFile$Source.findEND(ZipFile.java:1469)
	at java.base/java.util.zip.ZipFile$Source.initCEN(ZipFile.java:1477)
	at java.base/java.util.zip.ZipFile$Source.<init>(ZipFile.java:1315)
	at java.base/java.util.zip.ZipFile$Source.get(ZipFile.java:1277)
	at java.base/java.util.zip.ZipFile$CleanableResource.<init>(ZipFile.java:709)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:243)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:172)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:186)
	at org.eclipse.jdt.internal.core.search.indexing.AddJarFileToIndex.execute(AddJarFileToIndex.java:154)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.run(JobManager.java:478)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-13 13:57:53.306
!MESSAGE Failed to index /221003350_P07/__MACOSX/._jarFile.jar
!STACK 0
java.util.zip.ZipException: zip END header not found
	at java.base/java.util.zip.ZipFile$Source.findEND(ZipFile.java:1469)
	at java.base/java.util.zip.ZipFile$Source.initCEN(ZipFile.java:1477)
	at java.base/java.util.zip.ZipFile$Source.<init>(ZipFile.java:1315)
	at java.base/java.util.zip.ZipFile$Source.get(ZipFile.java:1277)
	at java.base/java.util.zip.ZipFile$CleanableResource.<init>(ZipFile.java:709)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:243)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:172)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:186)
	at org.eclipse.jdt.internal.core.search.indexing.AddJarFileToIndex.execute(AddJarFileToIndex.java:154)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.run(JobManager.java:478)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-13 13:58:17.129
!MESSAGE Failed to index /221003350_P07/__MACOSX/._jarFile.jar
!STACK 0
java.util.zip.ZipException: zip END header not found
	at java.base/java.util.zip.ZipFile$Source.findEND(ZipFile.java:1469)
	at java.base/java.util.zip.ZipFile$Source.initCEN(ZipFile.java:1477)
	at java.base/java.util.zip.ZipFile$Source.<init>(ZipFile.java:1315)
	at java.base/java.util.zip.ZipFile$Source.get(ZipFile.java:1277)
	at java.base/java.util.zip.ZipFile$CleanableResource.<init>(ZipFile.java:709)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:243)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:172)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:186)
	at org.eclipse.jdt.internal.core.search.indexing.AddJarFileToIndex.execute(AddJarFileToIndex.java:154)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.run(JobManager.java:478)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-13 13:58:27.827
!MESSAGE Failed to index /221003350_P07/__MACOSX/._jarFile.jar
!STACK 0
java.util.zip.ZipException: zip END header not found
	at java.base/java.util.zip.ZipFile$Source.findEND(ZipFile.java:1469)
	at java.base/java.util.zip.ZipFile$Source.initCEN(ZipFile.java:1477)
	at java.base/java.util.zip.ZipFile$Source.<init>(ZipFile.java:1315)
	at java.base/java.util.zip.ZipFile$Source.get(ZipFile.java:1277)
	at java.base/java.util.zip.ZipFile$CleanableResource.<init>(ZipFile.java:709)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:243)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:172)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:186)
	at org.eclipse.jdt.internal.core.search.indexing.AddJarFileToIndex.execute(AddJarFileToIndex.java:154)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.run(JobManager.java:478)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-13 13:58:48.097
!MESSAGE Failed to index /221003350_P07/__MACOSX/._jarFile.jar
!STACK 0
java.util.zip.ZipException: zip END header not found
	at java.base/java.util.zip.ZipFile$Source.findEND(ZipFile.java:1469)
	at java.base/java.util.zip.ZipFile$Source.initCEN(ZipFile.java:1477)
	at java.base/java.util.zip.ZipFile$Source.<init>(ZipFile.java:1315)
	at java.base/java.util.zip.ZipFile$Source.get(ZipFile.java:1277)
	at java.base/java.util.zip.ZipFile$CleanableResource.<init>(ZipFile.java:709)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:243)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:172)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:186)
	at org.eclipse.jdt.internal.core.search.indexing.AddJarFileToIndex.execute(AddJarFileToIndex.java:154)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.run(JobManager.java:478)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-13 13:59:23.247
!MESSAGE Failed to index /221003350_P07/__MACOSX/._jarFile.jar
!STACK 0
java.util.zip.ZipException: zip END header not found
	at java.base/java.util.zip.ZipFile$Source.findEND(ZipFile.java:1469)
	at java.base/java.util.zip.ZipFile$Source.initCEN(ZipFile.java:1477)
	at java.base/java.util.zip.ZipFile$Source.<init>(ZipFile.java:1315)
	at java.base/java.util.zip.ZipFile$Source.get(ZipFile.java:1277)
	at java.base/java.util.zip.ZipFile$CleanableResource.<init>(ZipFile.java:709)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:243)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:172)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:186)
	at org.eclipse.jdt.internal.core.search.indexing.AddJarFileToIndex.execute(AddJarFileToIndex.java:154)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.run(JobManager.java:478)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-13 13:59:27.012
!MESSAGE Failed to index /221003350_P07/__MACOSX/._jarFile.jar
!STACK 0
java.util.zip.ZipException: zip END header not found
	at java.base/java.util.zip.ZipFile$Source.findEND(ZipFile.java:1469)
	at java.base/java.util.zip.ZipFile$Source.initCEN(ZipFile.java:1477)
	at java.base/java.util.zip.ZipFile$Source.<init>(ZipFile.java:1315)
	at java.base/java.util.zip.ZipFile$Source.get(ZipFile.java:1277)
	at java.base/java.util.zip.ZipFile$CleanableResource.<init>(ZipFile.java:709)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:243)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:172)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:186)
	at org.eclipse.jdt.internal.core.search.indexing.AddJarFileToIndex.execute(AddJarFileToIndex.java:154)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.run(JobManager.java:478)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-13 13:59:38.666
!MESSAGE Failed to index /221003350_P07/__MACOSX/._jarFile.jar
!STACK 0
java.util.zip.ZipException: zip END header not found
	at java.base/java.util.zip.ZipFile$Source.findEND(ZipFile.java:1469)
	at java.base/java.util.zip.ZipFile$Source.initCEN(ZipFile.java:1477)
	at java.base/java.util.zip.ZipFile$Source.<init>(ZipFile.java:1315)
	at java.base/java.util.zip.ZipFile$Source.get(ZipFile.java:1277)
	at java.base/java.util.zip.ZipFile$CleanableResource.<init>(ZipFile.java:709)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:243)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:172)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:186)
	at org.eclipse.jdt.internal.core.search.indexing.AddJarFileToIndex.execute(AddJarFileToIndex.java:154)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.run(JobManager.java:478)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-13 13:59:49.685
!MESSAGE Failed to index /221003350_P07/__MACOSX/._jarFile.jar
!STACK 0
java.util.zip.ZipException: zip END header not found
	at java.base/java.util.zip.ZipFile$Source.findEND(ZipFile.java:1469)
	at java.base/java.util.zip.ZipFile$Source.initCEN(ZipFile.java:1477)
	at java.base/java.util.zip.ZipFile$Source.<init>(ZipFile.java:1315)
	at java.base/java.util.zip.ZipFile$Source.get(ZipFile.java:1277)
	at java.base/java.util.zip.ZipFile$CleanableResource.<init>(ZipFile.java:709)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:243)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:172)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:186)
	at org.eclipse.jdt.internal.core.search.indexing.AddJarFileToIndex.execute(AddJarFileToIndex.java:154)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.run(JobManager.java:478)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-13 14:00:46.644
!MESSAGE Failed to index /221003350_P07/__MACOSX/._jarFile.jar
!STACK 0
java.util.zip.ZipException: zip END header not found
	at java.base/java.util.zip.ZipFile$Source.findEND(ZipFile.java:1469)
	at java.base/java.util.zip.ZipFile$Source.initCEN(ZipFile.java:1477)
	at java.base/java.util.zip.ZipFile$Source.<init>(ZipFile.java:1315)
	at java.base/java.util.zip.ZipFile$Source.get(ZipFile.java:1277)
	at java.base/java.util.zip.ZipFile$CleanableResource.<init>(ZipFile.java:709)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:243)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:172)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:186)
	at org.eclipse.jdt.internal.core.search.indexing.AddJarFileToIndex.execute(AddJarFileToIndex.java:154)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.run(JobManager.java:478)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-13 14:05:13.903
!MESSAGE Failed to index /221003350_P07/__MACOSX/._jarFile.jar
!STACK 0
java.util.zip.ZipException: zip END header not found
	at java.base/java.util.zip.ZipFile$Source.findEND(ZipFile.java:1469)
	at java.base/java.util.zip.ZipFile$Source.initCEN(ZipFile.java:1477)
	at java.base/java.util.zip.ZipFile$Source.<init>(ZipFile.java:1315)
	at java.base/java.util.zip.ZipFile$Source.get(ZipFile.java:1277)
	at java.base/java.util.zip.ZipFile$CleanableResource.<init>(ZipFile.java:709)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:243)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:172)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:186)
	at org.eclipse.jdt.internal.core.search.indexing.AddJarFileToIndex.execute(AddJarFileToIndex.java:154)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.run(JobManager.java:478)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-13 14:05:16.447
!MESSAGE Failed to index /221003350_P07/__MACOSX/._jarFile.jar
!STACK 0
java.util.zip.ZipException: zip END header not found
	at java.base/java.util.zip.ZipFile$Source.findEND(ZipFile.java:1469)
	at java.base/java.util.zip.ZipFile$Source.initCEN(ZipFile.java:1477)
	at java.base/java.util.zip.ZipFile$Source.<init>(ZipFile.java:1315)
	at java.base/java.util.zip.ZipFile$Source.get(ZipFile.java:1277)
	at java.base/java.util.zip.ZipFile$CleanableResource.<init>(ZipFile.java:709)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:243)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:172)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:186)
	at org.eclipse.jdt.internal.core.search.indexing.AddJarFileToIndex.execute(AddJarFileToIndex.java:154)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.run(JobManager.java:478)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-13 14:05:35.582
!MESSAGE Failed to index /221003350_P07/__MACOSX/._jarFile.jar
!STACK 0
java.util.zip.ZipException: zip END header not found
	at java.base/java.util.zip.ZipFile$Source.findEND(ZipFile.java:1469)
	at java.base/java.util.zip.ZipFile$Source.initCEN(ZipFile.java:1477)
	at java.base/java.util.zip.ZipFile$Source.<init>(ZipFile.java:1315)
	at java.base/java.util.zip.ZipFile$Source.get(ZipFile.java:1277)
	at java.base/java.util.zip.ZipFile$CleanableResource.<init>(ZipFile.java:709)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:243)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:172)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:186)
	at org.eclipse.jdt.internal.core.search.indexing.AddJarFileToIndex.execute(AddJarFileToIndex.java:154)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.run(JobManager.java:478)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-13 14:05:56.391
!MESSAGE Failed to index /221003350_P07/__MACOSX/._jarFile.jar
!STACK 0
java.util.zip.ZipException: zip END header not found
	at java.base/java.util.zip.ZipFile$Source.findEND(ZipFile.java:1469)
	at java.base/java.util.zip.ZipFile$Source.initCEN(ZipFile.java:1477)
	at java.base/java.util.zip.ZipFile$Source.<init>(ZipFile.java:1315)
	at java.base/java.util.zip.ZipFile$Source.get(ZipFile.java:1277)
	at java.base/java.util.zip.ZipFile$CleanableResource.<init>(ZipFile.java:709)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:243)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:172)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:186)
	at org.eclipse.jdt.internal.core.search.indexing.AddJarFileToIndex.execute(AddJarFileToIndex.java:154)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.run(JobManager.java:478)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-13 14:06:22.084
!MESSAGE Failed to index /221003350_P07/__MACOSX/._jarFile.jar
!STACK 0
java.util.zip.ZipException: zip END header not found
	at java.base/java.util.zip.ZipFile$Source.findEND(ZipFile.java:1469)
	at java.base/java.util.zip.ZipFile$Source.initCEN(ZipFile.java:1477)
	at java.base/java.util.zip.ZipFile$Source.<init>(ZipFile.java:1315)
	at java.base/java.util.zip.ZipFile$Source.get(ZipFile.java:1277)
	at java.base/java.util.zip.ZipFile$CleanableResource.<init>(ZipFile.java:709)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:243)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:172)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:186)
	at org.eclipse.jdt.internal.core.search.indexing.AddJarFileToIndex.execute(AddJarFileToIndex.java:154)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.run(JobManager.java:478)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-13 14:07:03.809
!MESSAGE Failed to index /221003350_P07/__MACOSX/._jarFile.jar
!STACK 0
java.util.zip.ZipException: zip END header not found
	at java.base/java.util.zip.ZipFile$Source.findEND(ZipFile.java:1469)
	at java.base/java.util.zip.ZipFile$Source.initCEN(ZipFile.java:1477)
	at java.base/java.util.zip.ZipFile$Source.<init>(ZipFile.java:1315)
	at java.base/java.util.zip.ZipFile$Source.get(ZipFile.java:1277)
	at java.base/java.util.zip.ZipFile$CleanableResource.<init>(ZipFile.java:709)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:243)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:172)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:186)
	at org.eclipse.jdt.internal.core.search.indexing.AddJarFileToIndex.execute(AddJarFileToIndex.java:154)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.run(JobManager.java:478)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-13 14:08:58.984
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
//Overall PriorityQueue class: 15 marks ***********************************************

public class PriorityQueue<K extends Comparable <? super K>,V>{
	private PositionList<Entry<K,V>> list = null;
	
	/*
	 * Default constructor
	 */
	public PriorityQueue(){
		this.list = new PositionList<Entry<K,V>>();
	}
	
	/*
	 * Insert method that store the entry in an unordered manner (you can add it at the end)	 
	 */
	public void insert(Entry<K,V> entry){
		list.addLast(entry);		
	}
	
	/*
	 * Remove the entry with the highest priority (typically close to 0 as an integer)
	 * by searching for the lowest key
	 * 8 marks ***********************************************
	 */
	public Entry<K,V> removeMin()
	{
		Entry<K,V> minEntry = min();
		Entry<K,V> removeEntry = minEntry;
		

		 PositionListIterator<Entry<K,V>> iterator =  entries();
		{

			(PositionListIterator<Entry<K, V>>) list.iterator();
		}
		
		
		for(Entry<K,V> entry : list)
		{
			public PositionListIterator<Entry<K,V>> entries()
			{

				return (PositionListIterator<Entry<K, V>>) list.iterator();
			}
			
			if(entry.equals(removeEntry))
			{
				
			}
		}
		
		
		return minEntry;		
	}
	
	/*
	 * Returns the entry with the highest priority (typically close to 0 as an integer) 
	 * by searching for the lowest key
	 * 5 marks
	 */
	public Entry<K,V> min()
	{
		
		Entry<K,V> minEntry = null;
		
		for(Entry<K,V> entry : list)
		{
			//first element in list
			if(minEntry == null)
			{
				minEntry = entry;
			}
			
			//compare entries
			if(minEntry.compareTo(entry) == 1)
			{
				minEntry = entry;
			}
			
			
		}
		//TODO: Implement the unsorted list min function
		return minEntry;
	}	
	
	
	/*
	 * Returns the size of the Priority Queue
	 */
	public Integer size(){
		return this.list.size();
	}
	
	/*
	 * Returns whether the Priority Queue is empty or not.
	 */
	public boolean isEmpty(){
		return this.list.isEmpty();
	}
	
	/*
	 * The overridden toString method
	 */
	public String toString(){
		return list.toString();
	}
	
	/*
	 * Returns the iterator containing all the Entries in the PriorityQueue
	 * 2 marks  ***********************************************
	 */
	
	public PositionListIterator<Entry<K,V>> entries()
	{

		return (PositionListIterator<Entry<K, V>>) list.iterator();
	}
	
	/**
	 * Convert a Position<T> into a Entry<K,V>
	 * @param p a Position<T> to convert
	 * @return the corresponding Entry<K,V>
	 */
	@SuppressWarnings("unchecked")
	private Entry<K,V> checkPosition(Position<Entry<K,V>> p) {
		if (!(p instanceof Entry<?,?>)) {
			throw new PositionException("Invalid Position");
		}
		
		return (Entry<K,V>)p;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-04-13 14:08:58.987
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-04-13 14:08:58.988
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-13 14:08:59.050
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
//Overall PriorityQueue class: 15 marks ***********************************************

public class PriorityQueue<K extends Comparable <? super K>,V>{
	private PositionList<Entry<K,V>> list = null;
	
	/*
	 * Default constructor
	 */
	public PriorityQueue(){
		this.list = new PositionList<Entry<K,V>>();
	}
	
	/*
	 * Insert method that store the entry in an unordered manner (you can add it at the end)	 
	 */
	public void insert(Entry<K,V> entry){
		list.addLast(entry);		
	}
	
	/*
	 * Remove the entry with the highest priority (typically close to 0 as an integer)
	 * by searching for the lowest key
	 * 8 marks ***********************************************
	 */
	public Entry<K,V> removeMin()
	{
		Entry<K,V> minEntry = min();
		Entry<K,V> removeEntry = minEntry;
		

		 PositionListIterator<Entry<K,V>> iterator =  entries();
		{

			(PositionListIterator<Entry<K, V>>) list.iterator();
		}
		
		
		for(Entry<K,V> entry : list)
		{
			public PositionListIterator<Entry<K,V>> entries()
			{

				return (PositionListIterator<Entry<K, V>>) list.iterator();
			}
			
			if(entry.equals(removeEntry))
			{
				
			}
		}
		
		
		return minEntry;		
	}
	
	/*
	 * Returns the entry with the highest priority (typically close to 0 as an integer) 
	 * by searching for the lowest key
	 * 5 marks
	 */
	public Entry<K,V> min()
	{
		
		Entry<K,V> minEntry = null;
		
		for(Entry<K,V> entry : list)
		{
			//first element in list
			if(minEntry == null)
			{
				minEntry = entry;
			}
			
			//compare entries
			if(minEntry.compareTo(entry) == 1)
			{
				minEntry = entry;
			}
			
			
		}
		//TODO: Implement the unsorted list min function
		return minEntry;
	}	
	
	
	/*
	 * Returns the size of the Priority Queue
	 */
	public Integer size(){
		return this.list.size();
	}
	
	/*
	 * Returns whether the Priority Queue is empty or not.
	 */
	public boolean isEmpty(){
		return this.list.isEmpty();
	}
	
	/*
	 * The overridden toString method
	 */
	public String toString(){
		return list.toString();
	}
	
	/*
	 * Returns the iterator containing all the Entries in the PriorityQueue
	 * 2 marks  ***********************************************
	 */
	
	public PositionListIterator<Entry<K,V>> entries()
	{

		return (PositionListIterator<Entry<K, V>>) list.iterator();
	}
	
	/**
	 * Convert a Position<T> into a Entry<K,V>
	 * @param p a Position<T> to convert
	 * @return the corresponding Entry<K,V>
	 */
	@SuppressWarnings("unchecked")
	private Entry<K,V> checkPosition(Position<Entry<K,V>> p) {
		if (!(p instanceof Entry<?,?>)) {
			throw new PositionException("Invalid Position");
		}
		
		return (Entry<K,V>)p;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-13 14:08:59.051
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-13 14:08:59.052
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-13 14:09:01.673
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
//Overall PriorityQueue class: 15 marks ***********************************************

public class PriorityQueue<K extends Comparable <? super K>,V>{
	private PositionList<Entry<K,V>> list = null;
	
	/*
	 * Default constructor
	 */
	public PriorityQueue(){
		this.list = new PositionList<Entry<K,V>>();
	}
	
	/*
	 * Insert method that store the entry in an unordered manner (you can add it at the end)	 
	 */
	public void insert(Entry<K,V> entry){
		list.addLast(entry);		
	}
	
	/*
	 * Remove the entry with the highest priority (typically close to 0 as an integer)
	 * by searching for the lowest key
	 * 8 marks ***********************************************
	 */
	public Entry<K,V> removeMin()
	{
		Entry<K,V> minEntry = min();
		Entry<K,V> removeEntry = minEntry;
		

		 PositionListIterator<Entry<K,V>> iterator =  entries();
		{

			(PositionListIterator<Entry<K, V>>) list.iterator();
		}
		
		
		for(Entry<K,V> entry : list)
		{
			public PositionListIterator<Entry<K,V>> entries()
			{

				return (PositionListIterator<Entry<K, V>>) list.iterator();
			}
			
			if(entry.equals(removeEntry))
			{
				
			}
		}
		
		
		return minEntry;		
	}
	
	/*
	 * Returns the entry with the highest priority (typically close to 0 as an integer) 
	 * by searching for the lowest key
	 * 5 marks
	 */
	public Entry<K,V> min()
	{
		
		Entry<K,V> minEntry = null;
		
		for(Entry<K,V> entry : list)
		{
			//first element in list
			if(minEntry == null)
			{
				minEntry = entry;
			}
			
			//compare entries
			if(minEntry.compareTo(entry) == 1)
			{
				minEntry = entry;
			}
			
			
		}
		//TODO: Implement the unsorted list min function
		return minEntry;
	}	
	
	
	/*
	 * Returns the size of the Priority Queue
	 */
	public Integer size(){
		return this.list.size();
	}
	
	/*
	 * Returns whether the Priority Queue is empty or not.
	 */
	public boolean isEmpty(){
		return this.list.isEmpty();
	}
	
	/*
	 * The overridden toString method
	 */
	public String toString(){
		return list.toString();
	}
	
	/*
	 * Returns the iterator containing all the Entries in the PriorityQueue
	 * 2 marks  ***********************************************
	 */
	
	public PositionListIterator<Entry<K,V>> entries()
	{

		return (PositionListIterator<Entry<K, V>>) list.iterator();
	}
	
	/**
	 * Convert a Position<T> into a Entry<K,V>
	 * @param p a Position<T> to convert
	 * @return the corresponding Entry<K,V>
	 */
	@SuppressWarnings("unchecked")
	private Entry<K,V> checkPosition(Position<Entry<K,V>> p) {
		if (!(p instanceof Entry<?,?>)) {
			throw new PositionException("Invalid Position");
		}
		
		return (Entry<K,V>)p;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-13 14:09:01.675
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-13 14:09:01.677
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-13 14:11:06.046
!MESSAGE Failed to index /221003350_P07/__MACOSX/._jarFile.jar
!STACK 0
java.util.zip.ZipException: zip END header not found
	at java.base/java.util.zip.ZipFile$Source.findEND(ZipFile.java:1469)
	at java.base/java.util.zip.ZipFile$Source.initCEN(ZipFile.java:1477)
	at java.base/java.util.zip.ZipFile$Source.<init>(ZipFile.java:1315)
	at java.base/java.util.zip.ZipFile$Source.get(ZipFile.java:1277)
	at java.base/java.util.zip.ZipFile$CleanableResource.<init>(ZipFile.java:709)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:243)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:172)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:186)
	at org.eclipse.jdt.internal.core.search.indexing.AddJarFileToIndex.execute(AddJarFileToIndex.java:154)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.run(JobManager.java:478)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-13 14:11:17.197
!MESSAGE Failed to index /221003350_P07/__MACOSX/._jarFile.jar
!STACK 0
java.util.zip.ZipException: zip END header not found
	at java.base/java.util.zip.ZipFile$Source.findEND(ZipFile.java:1469)
	at java.base/java.util.zip.ZipFile$Source.initCEN(ZipFile.java:1477)
	at java.base/java.util.zip.ZipFile$Source.<init>(ZipFile.java:1315)
	at java.base/java.util.zip.ZipFile$Source.get(ZipFile.java:1277)
	at java.base/java.util.zip.ZipFile$CleanableResource.<init>(ZipFile.java:709)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:243)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:172)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:186)
	at org.eclipse.jdt.internal.core.search.indexing.AddJarFileToIndex.execute(AddJarFileToIndex.java:154)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.run(JobManager.java:478)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-13 14:15:59.910
!MESSAGE Failed to index /221003350_P07/__MACOSX/._jarFile.jar
!STACK 0
java.util.zip.ZipException: zip END header not found
	at java.base/java.util.zip.ZipFile$Source.findEND(ZipFile.java:1469)
	at java.base/java.util.zip.ZipFile$Source.initCEN(ZipFile.java:1477)
	at java.base/java.util.zip.ZipFile$Source.<init>(ZipFile.java:1315)
	at java.base/java.util.zip.ZipFile$Source.get(ZipFile.java:1277)
	at java.base/java.util.zip.ZipFile$CleanableResource.<init>(ZipFile.java:709)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:243)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:172)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:186)
	at org.eclipse.jdt.internal.core.search.indexing.AddJarFileToIndex.execute(AddJarFileToIndex.java:154)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.run(JobManager.java:478)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-13 14:16:20.265
!MESSAGE Failed to index /221003350_P07/__MACOSX/._jarFile.jar
!STACK 0
java.util.zip.ZipException: zip END header not found
	at java.base/java.util.zip.ZipFile$Source.findEND(ZipFile.java:1469)
	at java.base/java.util.zip.ZipFile$Source.initCEN(ZipFile.java:1477)
	at java.base/java.util.zip.ZipFile$Source.<init>(ZipFile.java:1315)
	at java.base/java.util.zip.ZipFile$Source.get(ZipFile.java:1277)
	at java.base/java.util.zip.ZipFile$CleanableResource.<init>(ZipFile.java:709)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:243)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:172)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:186)
	at org.eclipse.jdt.internal.core.search.indexing.AddJarFileToIndex.execute(AddJarFileToIndex.java:154)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.run(JobManager.java:478)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-13 14:16:47.433
!MESSAGE Failed to index /221003350_P07/__MACOSX/._jarFile.jar
!STACK 0
java.util.zip.ZipException: zip END header not found
	at java.base/java.util.zip.ZipFile$Source.findEND(ZipFile.java:1469)
	at java.base/java.util.zip.ZipFile$Source.initCEN(ZipFile.java:1477)
	at java.base/java.util.zip.ZipFile$Source.<init>(ZipFile.java:1315)
	at java.base/java.util.zip.ZipFile$Source.get(ZipFile.java:1277)
	at java.base/java.util.zip.ZipFile$CleanableResource.<init>(ZipFile.java:709)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:243)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:172)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:186)
	at org.eclipse.jdt.internal.core.search.indexing.AddJarFileToIndex.execute(AddJarFileToIndex.java:154)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.run(JobManager.java:478)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-13 14:17:07.227
!MESSAGE Failed to index /221003350_P07/__MACOSX/._jarFile.jar
!STACK 0
java.util.zip.ZipException: zip END header not found
	at java.base/java.util.zip.ZipFile$Source.findEND(ZipFile.java:1469)
	at java.base/java.util.zip.ZipFile$Source.initCEN(ZipFile.java:1477)
	at java.base/java.util.zip.ZipFile$Source.<init>(ZipFile.java:1315)
	at java.base/java.util.zip.ZipFile$Source.get(ZipFile.java:1277)
	at java.base/java.util.zip.ZipFile$CleanableResource.<init>(ZipFile.java:709)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:243)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:172)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:186)
	at org.eclipse.jdt.internal.core.search.indexing.AddJarFileToIndex.execute(AddJarFileToIndex.java:154)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.run(JobManager.java:478)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-13 14:17:17.025
!MESSAGE Failed to index /221003350_P07/__MACOSX/._jarFile.jar
!STACK 0
java.util.zip.ZipException: zip END header not found
	at java.base/java.util.zip.ZipFile$Source.findEND(ZipFile.java:1469)
	at java.base/java.util.zip.ZipFile$Source.initCEN(ZipFile.java:1477)
	at java.base/java.util.zip.ZipFile$Source.<init>(ZipFile.java:1315)
	at java.base/java.util.zip.ZipFile$Source.get(ZipFile.java:1277)
	at java.base/java.util.zip.ZipFile$CleanableResource.<init>(ZipFile.java:709)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:243)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:172)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:186)
	at org.eclipse.jdt.internal.core.search.indexing.AddJarFileToIndex.execute(AddJarFileToIndex.java:154)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.run(JobManager.java:478)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-13 14:20:49.018
!MESSAGE Failed to index /221003350_P07/__MACOSX/._jarFile.jar
!STACK 0
java.util.zip.ZipException: zip END header not found
	at java.base/java.util.zip.ZipFile$Source.findEND(ZipFile.java:1469)
	at java.base/java.util.zip.ZipFile$Source.initCEN(ZipFile.java:1477)
	at java.base/java.util.zip.ZipFile$Source.<init>(ZipFile.java:1315)
	at java.base/java.util.zip.ZipFile$Source.get(ZipFile.java:1277)
	at java.base/java.util.zip.ZipFile$CleanableResource.<init>(ZipFile.java:709)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:243)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:172)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:186)
	at org.eclipse.jdt.internal.core.search.indexing.AddJarFileToIndex.execute(AddJarFileToIndex.java:154)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.run(JobManager.java:478)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-13 14:21:23.628
!MESSAGE Failed to index /221003350_P07/__MACOSX/._jarFile.jar
!STACK 0
java.util.zip.ZipException: zip END header not found
	at java.base/java.util.zip.ZipFile$Source.findEND(ZipFile.java:1469)
	at java.base/java.util.zip.ZipFile$Source.initCEN(ZipFile.java:1477)
	at java.base/java.util.zip.ZipFile$Source.<init>(ZipFile.java:1315)
	at java.base/java.util.zip.ZipFile$Source.get(ZipFile.java:1277)
	at java.base/java.util.zip.ZipFile$CleanableResource.<init>(ZipFile.java:709)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:243)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:172)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:186)
	at org.eclipse.jdt.internal.core.search.indexing.AddJarFileToIndex.execute(AddJarFileToIndex.java:154)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.run(JobManager.java:478)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-13 14:21:48.686
!MESSAGE Failed to index /221003350_P07/__MACOSX/._jarFile.jar
!STACK 0
java.util.zip.ZipException: zip END header not found
	at java.base/java.util.zip.ZipFile$Source.findEND(ZipFile.java:1469)
	at java.base/java.util.zip.ZipFile$Source.initCEN(ZipFile.java:1477)
	at java.base/java.util.zip.ZipFile$Source.<init>(ZipFile.java:1315)
	at java.base/java.util.zip.ZipFile$Source.get(ZipFile.java:1277)
	at java.base/java.util.zip.ZipFile$CleanableResource.<init>(ZipFile.java:709)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:243)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:172)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:186)
	at org.eclipse.jdt.internal.core.search.indexing.AddJarFileToIndex.execute(AddJarFileToIndex.java:154)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.run(JobManager.java:478)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-13 14:21:51.405
!MESSAGE Failed to index /221003350_P07/__MACOSX/._jarFile.jar
!STACK 0
java.util.zip.ZipException: zip END header not found
	at java.base/java.util.zip.ZipFile$Source.findEND(ZipFile.java:1469)
	at java.base/java.util.zip.ZipFile$Source.initCEN(ZipFile.java:1477)
	at java.base/java.util.zip.ZipFile$Source.<init>(ZipFile.java:1315)
	at java.base/java.util.zip.ZipFile$Source.get(ZipFile.java:1277)
	at java.base/java.util.zip.ZipFile$CleanableResource.<init>(ZipFile.java:709)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:243)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:172)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:186)
	at org.eclipse.jdt.internal.core.search.indexing.AddJarFileToIndex.execute(AddJarFileToIndex.java:154)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.run(JobManager.java:478)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-13 14:22:27.157
!MESSAGE Failed to index /221003350_P07/__MACOSX/._jarFile.jar
!STACK 0
java.util.zip.ZipException: zip END header not found
	at java.base/java.util.zip.ZipFile$Source.findEND(ZipFile.java:1469)
	at java.base/java.util.zip.ZipFile$Source.initCEN(ZipFile.java:1477)
	at java.base/java.util.zip.ZipFile$Source.<init>(ZipFile.java:1315)
	at java.base/java.util.zip.ZipFile$Source.get(ZipFile.java:1277)
	at java.base/java.util.zip.ZipFile$CleanableResource.<init>(ZipFile.java:709)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:243)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:172)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:186)
	at org.eclipse.jdt.internal.core.search.indexing.AddJarFileToIndex.execute(AddJarFileToIndex.java:154)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.run(JobManager.java:478)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-13 14:22:57.864
!MESSAGE Failed to index /221003350_P07/__MACOSX/._jarFile.jar
!STACK 0
java.util.zip.ZipException: zip END header not found
	at java.base/java.util.zip.ZipFile$Source.findEND(ZipFile.java:1469)
	at java.base/java.util.zip.ZipFile$Source.initCEN(ZipFile.java:1477)
	at java.base/java.util.zip.ZipFile$Source.<init>(ZipFile.java:1315)
	at java.base/java.util.zip.ZipFile$Source.get(ZipFile.java:1277)
	at java.base/java.util.zip.ZipFile$CleanableResource.<init>(ZipFile.java:709)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:243)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:172)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:186)
	at org.eclipse.jdt.internal.core.search.indexing.AddJarFileToIndex.execute(AddJarFileToIndex.java:154)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.run(JobManager.java:478)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-13 14:25:08.514
!MESSAGE Failed to index /221003350_P07/__MACOSX/._jarFile.jar
!STACK 0
java.util.zip.ZipException: zip END header not found
	at java.base/java.util.zip.ZipFile$Source.findEND(ZipFile.java:1469)
	at java.base/java.util.zip.ZipFile$Source.initCEN(ZipFile.java:1477)
	at java.base/java.util.zip.ZipFile$Source.<init>(ZipFile.java:1315)
	at java.base/java.util.zip.ZipFile$Source.get(ZipFile.java:1277)
	at java.base/java.util.zip.ZipFile$CleanableResource.<init>(ZipFile.java:709)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:243)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:172)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:186)
	at org.eclipse.jdt.internal.core.search.indexing.AddJarFileToIndex.execute(AddJarFileToIndex.java:154)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.run(JobManager.java:478)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-13 14:25:13.625
!MESSAGE Failed to index /221003350_P07/__MACOSX/._jarFile.jar
!STACK 0
java.util.zip.ZipException: zip END header not found
	at java.base/java.util.zip.ZipFile$Source.findEND(ZipFile.java:1469)
	at java.base/java.util.zip.ZipFile$Source.initCEN(ZipFile.java:1477)
	at java.base/java.util.zip.ZipFile$Source.<init>(ZipFile.java:1315)
	at java.base/java.util.zip.ZipFile$Source.get(ZipFile.java:1277)
	at java.base/java.util.zip.ZipFile$CleanableResource.<init>(ZipFile.java:709)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:243)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:172)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:186)
	at org.eclipse.jdt.internal.core.search.indexing.AddJarFileToIndex.execute(AddJarFileToIndex.java:154)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.run(JobManager.java:478)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-13 14:28:56.247
!MESSAGE Failed to index /221003350_P07/__MACOSX/._jarFile.jar
!STACK 0
java.util.zip.ZipException: zip END header not found
	at java.base/java.util.zip.ZipFile$Source.findEND(ZipFile.java:1469)
	at java.base/java.util.zip.ZipFile$Source.initCEN(ZipFile.java:1477)
	at java.base/java.util.zip.ZipFile$Source.<init>(ZipFile.java:1315)
	at java.base/java.util.zip.ZipFile$Source.get(ZipFile.java:1277)
	at java.base/java.util.zip.ZipFile$CleanableResource.<init>(ZipFile.java:709)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:243)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:172)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:186)
	at org.eclipse.jdt.internal.core.search.indexing.AddJarFileToIndex.execute(AddJarFileToIndex.java:154)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.run(JobManager.java:478)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-13 14:30:22.955
!MESSAGE Failed to index /221003350_P07/__MACOSX/._jarFile.jar
!STACK 0
java.util.zip.ZipException: zip END header not found
	at java.base/java.util.zip.ZipFile$Source.findEND(ZipFile.java:1469)
	at java.base/java.util.zip.ZipFile$Source.initCEN(ZipFile.java:1477)
	at java.base/java.util.zip.ZipFile$Source.<init>(ZipFile.java:1315)
	at java.base/java.util.zip.ZipFile$Source.get(ZipFile.java:1277)
	at java.base/java.util.zip.ZipFile$CleanableResource.<init>(ZipFile.java:709)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:243)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:172)
	at java.base/java.util.zip.ZipFile.<init>(ZipFile.java:186)
	at org.eclipse.jdt.internal.core.search.indexing.AddJarFileToIndex.execute(AddJarFileToIndex.java:154)
	at org.eclipse.jdt.internal.core.search.processing.JobManager.run(JobManager.java:478)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.jdt.core 4 0 2023-04-13 14:30:28.245
!MESSAGE Invalid ZIP archive: __MACOSX/._jarFile.jar [in 221003350_P07]

!ENTRY org.eclipse.jdt.core 4 0 2023-04-13 14:30:31.623
!MESSAGE Invalid ZIP archive: __MACOSX/._jarFile.jar [in 221003350_P07]
!SESSION 2023-04-13 16:55:08.500 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_ZA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-04-13 16:55:20.485
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-13 16:55:20.485
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-13 16:55:20.485
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-13 16:55:26.906
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\redth'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-04-13 18:33:21.896 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_ZA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-04-13 18:33:27.974
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-13 18:33:27.974
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-13 18:33:27.974
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-13 18:33:31.149
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\redth'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-04-14 10:26:32.938 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_ZA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-04-14 10:26:55.376
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-14 10:26:55.376
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-14 10:26:55.376
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-14 10:27:01.076
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\redth'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-04-17 11:28:31.635 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_ZA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-04-17 11:28:54.816
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-17 11:28:54.816
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-17 11:28:54.816
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-17 11:29:01.484
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\redth'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-04-17 11:42:53.264 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_ZA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-04-17 11:43:00.714
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-17 11:43:00.714
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-17 11:43:00.714
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-17 11:43:05.553
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\redth'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-04-19 12:03:01.502 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_ZA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-04-19 12:03:23.578
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-19 12:03:23.578
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-19 12:03:23.578
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-19 12:03:27.605
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\redth'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-04-19 12:49:27.699 -----------------------------------------------
eclipse.buildId=4.25.0.I20220831-1800
java.version=17.0.4.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_ZA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-04-19 12:49:34.563
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-19 12:49:34.563
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-19 12:49:34.563
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.edit.text.java.rename.element"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.ui.edit.rename"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-19 12:49:38.878
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\redth'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2023-04-19 12:54:13.781
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------


import java.util.ArrayList;
import java.util.Iterator;

import com.jwetherell.algorithms.data_structures.Graph;
import com.jwetherell.algorithms.data_structures.Graph.Vertex;

import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.TextArea;
import javafx.scene.input.MouseDragEvent;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.Pane;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Line;
import javafx.scene.shape.Polygon;
import javafx.scene.shape.Shape;
import javafx.stage.Stage;
import javafx.stage.StageStyle;

public class GraphPane extends StackPane
{
	static Pane pane;
	static int total;
	static TextArea txtTotal;
	static TextArea txtDisplay;
	static GridPane gridPane;
	static GraphPane graphPane;
	static Tree<Vertex<Choice>> tree;
	static Position<Vertex<Choice>> root;
	static ScrollPane scrollPane;
	
	static ArrayList<Position<Vertex<Choice>>> vertexPath = new ArrayList<Position<Vertex<Choice>>>();
	static ArrayList<Button> choicePath = new ArrayList<Button>();
	static int choiceNumber = -1;
	
	public GraphPane()
	{
		
		graphPane = this;
		gridPane = new GridPane();
		//setting vbox/controls
		VBox vbox = new VBox();
		vbox.setMaxSize(800, 800);
		//setting pane/graph
		pane = new Pane();
		pane.setPrefSize(2000, 2000);
		
		//scrollpane
		scrollPane = new ScrollPane();
		scrollPane.setContent(pane);
		scrollPane.setPrefSize(600, 600);
		//adding both to main borderpane for layout



		
		//adding controls to vbox
		Label lblTotal = new Label("Total:");
		txtTotal = new TextArea();
		txtTotal.setPrefSize(getPrefWidth(), 20);
		
		Label lblDisplay = new Label("Display:");
		txtDisplay = new TextArea();
		txtDisplay.setPrefSize(getPrefWidth(), 20);
		
		//add buttons
		
		Button btnGoBack = new Button("Go Back One Choice");
		btnGoBack.setPrefSize(200, 30);
		
		Button btnDisplayChoices = new Button("Display Current Choices Info");
		btnDisplayChoices.setPrefSize(200, 30);


		
		gridPane.add(lblTotal, 0, 0);
		gridPane.add(txtTotal, 0, 1);
		gridPane.add(lblDisplay, 0, 2);
		gridPane.add(txtDisplay, 0, 3);
		gridPane.add(btnGoBack, 0, 4);
		gridPane.add(btnDisplayChoices, 1, 4);
		
		vbox.getChildren().add(gridPane);
		vbox.getChildren().add(scrollPane);
		
		this.getChildren().add(vbox);
		
		//generate tree and fill it
		ModifyTree modifyTree = new ModifyTree();
		
		tree = modifyTree.getTree();
		root = modifyTree.getRoot();
		
		try 
		{
			displayNodes(tree, root);
			displayEdge(tree, root);
			//System.out.println(tree.preOrderElementTraversal(tree, root));
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		//set buttons actipns
		
		btnGoBack.setOnAction(new EventHandler <ActionEvent>()
		{
			@Override
			public void handle(ActionEvent event) 
			{
				goBack();
			}		
		});
		
		btnDisplayChoices.setOnAction(new EventHandler <ActionEvent>()
		{
			@Override
			public void handle(ActionEvent event) 
			{
				//shortestPath();
				printChoices();
			}		
		});
		

		////
		
	}
	
	public static void goBack()
	{
		
		//if choice exists
		if(choiceNumber > -1)
		{
			//go back one on button
			Button button = choicePath.get(choiceNumber);
			button.setTextFill(null);
			button.setStyle("-fx-background-color: BLACK");
			System.out.println(button.getText());
			//go back on 
			Position<Vertex<Choice>> vertex = vertexPath.get(choiceNumber);
			vertex.element().getValue().setDisplayed(false);
			vertex.element().getValue().setVisited(false);
			
			//now get rid of button and vertex from list
			vertexPath.remove(choiceNumber);
			choicePath.remove(choiceNumber);
			
			total -= vertex.element().getWeight();
			txtTotal.setText("R"+total);
			choiceNumber--;
			
			
		}else
		{
			graphPane.setVisible(false);
			//go to error pane
			ErrorPane root = new ErrorPane("ERROR: There is no node selected to undo.", graphPane);
			Stage secondStage = new Stage();
			
			//secondStage.initStyle(StageStyle.UNDECORATED);
	        secondStage.setScene(new Scene(root));
	        secondStage.setTitle("Error");
	        secondStage.show();
	        return;
		}

	}
	
	public void addToPath(Position<Vertex<Choice>> elem,Button button)
	{
		vertexPath.add(elem);
		choicePath.add(button);
		choiceNumber++;
		
		total += elem.element().getWeight();
		txtTotal.setText("R"+total);
	}
	
	final static int nodeSize = 50;
	final static int edgeSize = 50;
	public static void addNode(int x, int y, Position<Vertex<Choice>> elem)
	{
		
		Button button = new Button(""+elem.element().getValue().getID());
		button.setShape(new Circle(10));
		button.setPrefSize(nodeSize,nodeSize);
		button.setLayoutX(x);
		button.setLayoutY(y);
		button.setTextFill(null);
		button.setStyle("-fx-background-color: BLACK");
		
		Label lblName = new Label(elem.element().getValue().getName());
		lblName.setLayoutX(x);
		lblName.setLayoutY(y-15);
		
		pane.getChildren().add(lblName);
		pane.getChildren().add(button);
		

		button.setOnAction(new EventHandler <ActionEvent>()
		{
			
			@Override
			public void handle(ActionEvent event) 
			{
				//total += elem;
				txtTotal.setText(""+total);
				graphPane.setVisible(false);
				
				//this is to search if parent has been visisted
				searchResult = false;
				//this is to search if a fellow child has been visited
				searchChildResult = true;
				try 
				{
					searchParentVisited(tree,  root, Integer.parseInt(button.getText()));
					searchFellowChildVisited(tree,  root, Integer.parseInt(button.getText()));
	
				} catch (Exception e) 
				{
					e.printStackTrace();
				}
				
				
				//if parent not visited yet
				if(!searchResult)
				{
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: Parent of Choice not selected yet.", graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
			        return;
					
				}else
				if(!searchChildResult)//now check if a fellow child has already been chosen
				{
								
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: You cannot choose more than one choice at the same depth", graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
			        return;
					
					
				}else
				if(button.getTextFill() == null)//if button viable
				{
					//opens main menu
					InfoPane root = new InfoPane(elem, button, graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Info");
			        secondStage.show();
					
				}else
				if(button.getTextFill().equals(Color.BLUE))//if buttons already been selected
				{
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: This option has already been selected.", graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
				}else
				{

					
				}
			}			
		});
	}
	
	public static void addEdge(int xP, int yP,int x, int y, Position<Vertex<Choice>> choice, int arrowPlacement)
	{	

		int posChange = 30;
		int midpointX = (xP+x+2*posChange)/2;
		int midpointY = (yP+y+2*posChange)/2;
		//System.out.println(xP +"-"+yP+"-"+x+"-"+y);
		//create line/edge from start to end
		Line line = new Line(xP+posChange, yP+posChange, x+posChange, y+posChange);
		Label lblWeight = new Label(""+choice.element().getWeight());
		lblWeight.setLayoutX(midpointX);
		lblWeight.setLayoutY(midpointY);
		
		//create directional arrow on line
		//Line arrowUp = new Line(x+15, y+25, x+30, y+30);
		//Line arrowDown = new Line(x+25, y+15, x+30, y+30);
		

		//if(xP != x && yP != y)
		{
			if(arrowPlacement > choice.element().getValue().getArrow())//upper bound
			{
				Polygon polygon = new Polygon();
		        polygon.getPoints().addAll(new Double[]{
		        		(double) (midpointX-15),(double) midpointY+10,
		        		(double) midpointX,(double) midpointY+15,
		        		(double) midpointX, (double) midpointY,
		        });

				pane.getChildren().add(polygon);

	
			}else
			if(arrowPlacement == choice.element().getValue().getArrow())//middle bound
			{

				Polygon polygon = new Polygon();
		        polygon.getPoints().addAll(new Double[]{
		        		(double) (midpointX-20),(double) midpointY-10,
		        		(double) midpointX,(double) midpointY,
		        		(double) midpointX-20, (double) midpointY+10,
		        });

				pane.getChildren().add(polygon);
				
			}else
			if(arrowPlacement < choice.element().getValue().getArrow())//lower bound
			{
				
				Polygon polygon = new Polygon();
		        polygon.getPoints().addAll(new Double[]{
		        		(double) (midpointX),(double) midpointY-20,
		        		(double) midpointX,(double) midpointY,
		        		(double) midpointX-20, (double) midpointY-10,
		        });

				pane.getChildren().add(polygon);
			}
		}
		//add line to pane
		//pane.getChildren().add(arrowUp);
		//pane.getChildren().add(arrowDown);
		pane.getChildren().add(line);
		pane.getChildren().add(lblWeight);
	}
	

	static int loop = 0;
	static int iteration = 1;
	static boolean endFound = false;

	private static void displayNodes(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice) throws Exception 
	{
		
		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);

		if(tree.parent(choice).get(0) == null)
		{
			choice.element().getValue().setX(0);
			choice.element().getValue().setY((int)scrollPane.getPrefHeight()/2);
			choice.element().getValue().setArrow(0);
			
			addNode(0, choice.element().getValue().getY(), choice);
		}
		
		while(iterator.hasNext())
		{
			//counts at which child you are currently at
			loop++;
			
			if(loop==3)
			{
				loop = 1;
			}
			
			Position<Vertex<Choice>> position = iterator.next();
			
			if(position.element().getValue().getDisplayed())
			{
				//System.out.println(position.toString() +"    ddddddd");
			}	
			else
			{
			
			//get depth which is the x axis
			int depth = tree.depth(tree, position);
			
			//calcuate y
			double numChild = tree.getNumChildren(tree.parent(position).get(0));


			
			int parentChoice = 0;
			//determines how a child of one parents should look

			if(tree.parent(position).size() == 1)
			{
				parentChoice = 0;
			}else
			if(tree.parent(position).size() % 2 == 0)//determines how a child of many parents should look - if even
			{
					parentChoice = tree.getNumChildren(tree.parent(position).get(0))/2;
					
				}else//determines how a child of many parents should look - if odd
				{
					
					parentChoice = (int)(tree.getNumChildren(tree.parent(position).get(0))/2+0.5);
					
				}
				
				//this is the # in order ofwhen the child was added to a parent
				int childNum = position.element().getValue().getChildNum();
				if(numChild <= 1)
				{
					
					position.element().getValue().setY(root.element().getValue().getY());
					position.element().getValue().setArrow(0);
				}
				else
				if(numChild/2 >= childNum || childNum==1)//in lower bound of loop
				{
					
					//set above parent
					position.element().getValue().setY(tree.parent(position).get(0).element().getValue().getY()-200/childNum);
					position.element().getValue().setArrow(-1);
					
				}else
				if(numChild/2 == childNum || numChild/2 == childNum-0.5)//at centre of loop
				{
	
					//set same as parent Y axis
					position.element().getValue().setY(tree.parent(position).get(0).element().getValue().getY());
					position.element().getValue().setArrow(0);
	
				}else
				{
					if((numChild+1-childNum) <= 0)
					{
						//set below parent
						position.element().getValue().setY((int)(tree.parent(position).get(0).element().getValue().getY()+200/(-numChild+1+childNum)));
						position.element().getValue().setArrow(1);
					}else
					{
						//set below parent
						position.element().getValue().setY((int)(tree.parent(position).get(0).element().getValue().getY()+200/(numChild+1-childNum)));
						position.element().getValue().setArrow(1);
					}
					
					
				}
						
	
				/*if(position.element().getValue().getID() == 7)
				{
					System.out.println("numPdasdasasdsad "+ tree.parent(position).size());
				}*/
				
				position.element().getValue().setX(depth*100);
				if(position.element().getValue().getY() > 1000)
				{
					System.out.println("\nID " + position.element().getValue().getID()+"   X: "+ position.element().getValue().getX()+"   Y: "+position.element().getValue().getY());
					System.out.println("loop " + loop+"   numChild: "+numChild+"\n");
				}
				
				
				//add nodes
				addNode(position.element().getValue().getX(), position.element().getValue().getY(),position);
				position.element().getValue().setDisplayed(true);
				//add all edges - can have many parents
				/*
				if(tree.getNumChildren(position) == 0)
				{
					loop = 0;
					endFound = true;
					iteration++;
				}*/
			}
			

			
			displayNodes(tree, position);
			
		}
		
	}
	
	
	
	private static void displayEdge(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice) throws Exception 
	{
		
		
		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);
		
		while(iterator.hasNext())
		{	
			Position<Vertex<Choice>> position = iterator.next();
			
			Iterator<Position<Vertex<Choice>>> iteratorC = tree.children(position);
			//to add root
			if(tree.parent(choice).get(0) == null)
			{

				addEdge(position.element().getValue().getX(),position.element().getValue().getY(),choice.element().getValue().getX(),choice.element().getValue().getY(),position,choice.element().getValue().getArrow());
			}
			
			while(iteratorC.hasNext())
			{		
				Position<Vertex<Choice>> c = iteratorC.next();
				addEdge(c.element().getValue().getX(),c.element().getValue().getY(),position.element().getValue().getX(),position.element().getValue().getY(),c,position.element().getValue().getArrow());
			}
			
				displayEdge(tree, position);
			
		}
		
	}

	static boolean searchResult;
	private static void searchParentVisited(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice, int id) throws Exception 
	{
		if(searchResult)
		{
			return;
		}
		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);
		//checks if root
		/*if(tree.parent(choice).get(0) == null)
		{
			//checks if root is search id
			if(id == root.element().id)
			{
				searchResult = true;
				return;
			}
		}*/
		
		while(iterator.hasNext())
		{
			if(searchResult)
			{
				return;
			}
			
			if(id == root.element().getValue().getID())
			{
				searchResult = true;
				return;
			}

			Position<Vertex<Choice>> position = iterator.next();
			
			//checks if correct node is found
			
			
			
			if(id == position.element().getValue().getID())
			{
				

				//checks if parent node has been visited before

				for(Position<Vertex<Choice>> c : tree.parent(position))
				{
					//searchResult = c.element().getVisited();

					if(c.element().getValue().getVisited())
					{
						searchResult = true;
						return;
					}
				}
				
			}
			
			searchParentVisited(tree, position, id);	
		}	
	}
	
	static boolean searchChildResult;
	private static void searchFellowChildVisited(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice, int id) throws Exception 
	{

		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);
		//checks if root
		if(tree.parent(choice).get(0) == null)
		{
			//checks if root is search id
			if(id == root.element().getValue().getID())
			{
				//System.out.println("root found");
				searchChildResult = true;
				return;
			}
		}
		
		while(iterator.hasNext())
		{
			
			Position<Vertex<Choice>> position = iterator.next();
			//checks if correct node is found
			if(id == position.element().getValue().getID())
			{

				//goes over all children of that paren
				Iterator<Position<Vertex<Choice>>> iteratorChild = tree.children(tree.parent(position).get(0));
				
				while(iteratorChild.hasNext())
				{
					
					Position<Vertex<Choice>> positionChild = iteratorChild.next();
					//System.out.println(positionChild.element().getID() + "  "+ positionChild.element().getVisited());
					//if child visited, return false
					if(positionChild.element().getValue().getVisited())
					{
						searchChildResult = false;
						return;
					}
				}
					

				
			}
			
			searchFellowChildVisited(tree, position, id);	
		}	
		//System.out.println("failure");
		
	}

	
	private static void printChoices()
	{
		for(Position<Vertex<Choice>> p : vertexPath)
		{
			
			System.out.println(p.element().getValue().toString() + "\n");
		}
	}
	
	private static void shortestPath(Position<Vertex<Choice>> lastPosition) throws Exception
	{
		

		Iterator<Position<Vertex<Choice>>> childPosition = tree.children(lastPosition);
		
		while(childPosition.hasNext())
		{
			Vertex<Choice>>> childPosition
		}
		if(!vertexPath.isEmpty())
		{
			
			Position<Vertex<Choice>> lastVertex = vertexPath.get(vertexPath.size()-1);
			
		}

	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-04-19 12:54:13.788
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-04-19 12:54:13.791
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-19 12:54:13.918
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------


import java.util.ArrayList;
import java.util.Iterator;

import com.jwetherell.algorithms.data_structures.Graph;
import com.jwetherell.algorithms.data_structures.Graph.Vertex;

import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.TextArea;
import javafx.scene.input.MouseDragEvent;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.Pane;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Line;
import javafx.scene.shape.Polygon;
import javafx.scene.shape.Shape;
import javafx.stage.Stage;
import javafx.stage.StageStyle;

public class GraphPane extends StackPane
{
	static Pane pane;
	static int total;
	static TextArea txtTotal;
	static TextArea txtDisplay;
	static GridPane gridPane;
	static GraphPane graphPane;
	static Tree<Vertex<Choice>> tree;
	static Position<Vertex<Choice>> root;
	static ScrollPane scrollPane;
	
	static ArrayList<Position<Vertex<Choice>>> vertexPath = new ArrayList<Position<Vertex<Choice>>>();
	static ArrayList<Button> choicePath = new ArrayList<Button>();
	static int choiceNumber = -1;
	
	public GraphPane()
	{
		
		graphPane = this;
		gridPane = new GridPane();
		//setting vbox/controls
		VBox vbox = new VBox();
		vbox.setMaxSize(800, 800);
		//setting pane/graph
		pane = new Pane();
		pane.setPrefSize(2000, 2000);
		
		//scrollpane
		scrollPane = new ScrollPane();
		scrollPane.setContent(pane);
		scrollPane.setPrefSize(600, 600);
		//adding both to main borderpane for layout



		
		//adding controls to vbox
		Label lblTotal = new Label("Total:");
		txtTotal = new TextArea();
		txtTotal.setPrefSize(getPrefWidth(), 20);
		
		Label lblDisplay = new Label("Display:");
		txtDisplay = new TextArea();
		txtDisplay.setPrefSize(getPrefWidth(), 20);
		
		//add buttons
		
		Button btnGoBack = new Button("Go Back One Choice");
		btnGoBack.setPrefSize(200, 30);
		
		Button btnDisplayChoices = new Button("Display Current Choices Info");
		btnDisplayChoices.setPrefSize(200, 30);


		
		gridPane.add(lblTotal, 0, 0);
		gridPane.add(txtTotal, 0, 1);
		gridPane.add(lblDisplay, 0, 2);
		gridPane.add(txtDisplay, 0, 3);
		gridPane.add(btnGoBack, 0, 4);
		gridPane.add(btnDisplayChoices, 1, 4);
		
		vbox.getChildren().add(gridPane);
		vbox.getChildren().add(scrollPane);
		
		this.getChildren().add(vbox);
		
		//generate tree and fill it
		ModifyTree modifyTree = new ModifyTree();
		
		tree = modifyTree.getTree();
		root = modifyTree.getRoot();
		
		try 
		{
			displayNodes(tree, root);
			displayEdge(tree, root);
			//System.out.println(tree.preOrderElementTraversal(tree, root));
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		//set buttons actipns
		
		btnGoBack.setOnAction(new EventHandler <ActionEvent>()
		{
			@Override
			public void handle(ActionEvent event) 
			{
				goBack();
			}		
		});
		
		btnDisplayChoices.setOnAction(new EventHandler <ActionEvent>()
		{
			@Override
			public void handle(ActionEvent event) 
			{
				//shortestPath();
				printChoices();
			}		
		});
		

		////
		
	}
	
	public static void goBack()
	{
		
		//if choice exists
		if(choiceNumber > -1)
		{
			//go back one on button
			Button button = choicePath.get(choiceNumber);
			button.setTextFill(null);
			button.setStyle("-fx-background-color: BLACK");
			System.out.println(button.getText());
			//go back on 
			Position<Vertex<Choice>> vertex = vertexPath.get(choiceNumber);
			vertex.element().getValue().setDisplayed(false);
			vertex.element().getValue().setVisited(false);
			
			//now get rid of button and vertex from list
			vertexPath.remove(choiceNumber);
			choicePath.remove(choiceNumber);
			
			total -= vertex.element().getWeight();
			txtTotal.setText("R"+total);
			choiceNumber--;
			
			
		}else
		{
			graphPane.setVisible(false);
			//go to error pane
			ErrorPane root = new ErrorPane("ERROR: There is no node selected to undo.", graphPane);
			Stage secondStage = new Stage();
			
			//secondStage.initStyle(StageStyle.UNDECORATED);
	        secondStage.setScene(new Scene(root));
	        secondStage.setTitle("Error");
	        secondStage.show();
	        return;
		}

	}
	
	public void addToPath(Position<Vertex<Choice>> elem,Button button)
	{
		vertexPath.add(elem);
		choicePath.add(button);
		choiceNumber++;
		
		total += elem.element().getWeight();
		txtTotal.setText("R"+total);
	}
	
	final static int nodeSize = 50;
	final static int edgeSize = 50;
	public static void addNode(int x, int y, Position<Vertex<Choice>> elem)
	{
		
		Button button = new Button(""+elem.element().getValue().getID());
		button.setShape(new Circle(10));
		button.setPrefSize(nodeSize,nodeSize);
		button.setLayoutX(x);
		button.setLayoutY(y);
		button.setTextFill(null);
		button.setStyle("-fx-background-color: BLACK");
		
		Label lblName = new Label(elem.element().getValue().getName());
		lblName.setLayoutX(x);
		lblName.setLayoutY(y-15);
		
		pane.getChildren().add(lblName);
		pane.getChildren().add(button);
		

		button.setOnAction(new EventHandler <ActionEvent>()
		{
			
			@Override
			public void handle(ActionEvent event) 
			{
				//total += elem;
				txtTotal.setText(""+total);
				graphPane.setVisible(false);
				
				//this is to search if parent has been visisted
				searchResult = false;
				//this is to search if a fellow child has been visited
				searchChildResult = true;
				try 
				{
					searchParentVisited(tree,  root, Integer.parseInt(button.getText()));
					searchFellowChildVisited(tree,  root, Integer.parseInt(button.getText()));
	
				} catch (Exception e) 
				{
					e.printStackTrace();
				}
				
				
				//if parent not visited yet
				if(!searchResult)
				{
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: Parent of Choice not selected yet.", graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
			        return;
					
				}else
				if(!searchChildResult)//now check if a fellow child has already been chosen
				{
								
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: You cannot choose more than one choice at the same depth", graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
			        return;
					
					
				}else
				if(button.getTextFill() == null)//if button viable
				{
					//opens main menu
					InfoPane root = new InfoPane(elem, button, graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Info");
			        secondStage.show();
					
				}else
				if(button.getTextFill().equals(Color.BLUE))//if buttons already been selected
				{
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: This option has already been selected.", graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
				}else
				{

					
				}
			}			
		});
	}
	
	public static void addEdge(int xP, int yP,int x, int y, Position<Vertex<Choice>> choice, int arrowPlacement)
	{	

		int posChange = 30;
		int midpointX = (xP+x+2*posChange)/2;
		int midpointY = (yP+y+2*posChange)/2;
		//System.out.println(xP +"-"+yP+"-"+x+"-"+y);
		//create line/edge from start to end
		Line line = new Line(xP+posChange, yP+posChange, x+posChange, y+posChange);
		Label lblWeight = new Label(""+choice.element().getWeight());
		lblWeight.setLayoutX(midpointX);
		lblWeight.setLayoutY(midpointY);
		
		//create directional arrow on line
		//Line arrowUp = new Line(x+15, y+25, x+30, y+30);
		//Line arrowDown = new Line(x+25, y+15, x+30, y+30);
		

		//if(xP != x && yP != y)
		{
			if(arrowPlacement > choice.element().getValue().getArrow())//upper bound
			{
				Polygon polygon = new Polygon();
		        polygon.getPoints().addAll(new Double[]{
		        		(double) (midpointX-15),(double) midpointY+10,
		        		(double) midpointX,(double) midpointY+15,
		        		(double) midpointX, (double) midpointY,
		        });

				pane.getChildren().add(polygon);

	
			}else
			if(arrowPlacement == choice.element().getValue().getArrow())//middle bound
			{

				Polygon polygon = new Polygon();
		        polygon.getPoints().addAll(new Double[]{
		        		(double) (midpointX-20),(double) midpointY-10,
		        		(double) midpointX,(double) midpointY,
		        		(double) midpointX-20, (double) midpointY+10,
		        });

				pane.getChildren().add(polygon);
				
			}else
			if(arrowPlacement < choice.element().getValue().getArrow())//lower bound
			{
				
				Polygon polygon = new Polygon();
		        polygon.getPoints().addAll(new Double[]{
		        		(double) (midpointX),(double) midpointY-20,
		        		(double) midpointX,(double) midpointY,
		        		(double) midpointX-20, (double) midpointY-10,
		        });

				pane.getChildren().add(polygon);
			}
		}
		//add line to pane
		//pane.getChildren().add(arrowUp);
		//pane.getChildren().add(arrowDown);
		pane.getChildren().add(line);
		pane.getChildren().add(lblWeight);
	}
	

	static int loop = 0;
	static int iteration = 1;
	static boolean endFound = false;

	private static void displayNodes(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice) throws Exception 
	{
		
		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);

		if(tree.parent(choice).get(0) == null)
		{
			choice.element().getValue().setX(0);
			choice.element().getValue().setY((int)scrollPane.getPrefHeight()/2);
			choice.element().getValue().setArrow(0);
			
			addNode(0, choice.element().getValue().getY(), choice);
		}
		
		while(iterator.hasNext())
		{
			//counts at which child you are currently at
			loop++;
			
			if(loop==3)
			{
				loop = 1;
			}
			
			Position<Vertex<Choice>> position = iterator.next();
			
			if(position.element().getValue().getDisplayed())
			{
				//System.out.println(position.toString() +"    ddddddd");
			}	
			else
			{
			
			//get depth which is the x axis
			int depth = tree.depth(tree, position);
			
			//calcuate y
			double numChild = tree.getNumChildren(tree.parent(position).get(0));


			
			int parentChoice = 0;
			//determines how a child of one parents should look

			if(tree.parent(position).size() == 1)
			{
				parentChoice = 0;
			}else
			if(tree.parent(position).size() % 2 == 0)//determines how a child of many parents should look - if even
			{
					parentChoice = tree.getNumChildren(tree.parent(position).get(0))/2;
					
				}else//determines how a child of many parents should look - if odd
				{
					
					parentChoice = (int)(tree.getNumChildren(tree.parent(position).get(0))/2+0.5);
					
				}
				
				//this is the # in order ofwhen the child was added to a parent
				int childNum = position.element().getValue().getChildNum();
				if(numChild <= 1)
				{
					
					position.element().getValue().setY(root.element().getValue().getY());
					position.element().getValue().setArrow(0);
				}
				else
				if(numChild/2 >= childNum || childNum==1)//in lower bound of loop
				{
					
					//set above parent
					position.element().getValue().setY(tree.parent(position).get(0).element().getValue().getY()-200/childNum);
					position.element().getValue().setArrow(-1);
					
				}else
				if(numChild/2 == childNum || numChild/2 == childNum-0.5)//at centre of loop
				{
	
					//set same as parent Y axis
					position.element().getValue().setY(tree.parent(position).get(0).element().getValue().getY());
					position.element().getValue().setArrow(0);
	
				}else
				{
					if((numChild+1-childNum) <= 0)
					{
						//set below parent
						position.element().getValue().setY((int)(tree.parent(position).get(0).element().getValue().getY()+200/(-numChild+1+childNum)));
						position.element().getValue().setArrow(1);
					}else
					{
						//set below parent
						position.element().getValue().setY((int)(tree.parent(position).get(0).element().getValue().getY()+200/(numChild+1-childNum)));
						position.element().getValue().setArrow(1);
					}
					
					
				}
						
	
				/*if(position.element().getValue().getID() == 7)
				{
					System.out.println("numPdasdasasdsad "+ tree.parent(position).size());
				}*/
				
				position.element().getValue().setX(depth*100);
				if(position.element().getValue().getY() > 1000)
				{
					System.out.println("\nID " + position.element().getValue().getID()+"   X: "+ position.element().getValue().getX()+"   Y: "+position.element().getValue().getY());
					System.out.println("loop " + loop+"   numChild: "+numChild+"\n");
				}
				
				
				//add nodes
				addNode(position.element().getValue().getX(), position.element().getValue().getY(),position);
				position.element().getValue().setDisplayed(true);
				//add all edges - can have many parents
				/*
				if(tree.getNumChildren(position) == 0)
				{
					loop = 0;
					endFound = true;
					iteration++;
				}*/
			}
			

			
			displayNodes(tree, position);
			
		}
		
	}
	
	
	
	private static void displayEdge(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice) throws Exception 
	{
		
		
		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);
		
		while(iterator.hasNext())
		{	
			Position<Vertex<Choice>> position = iterator.next();
			
			Iterator<Position<Vertex<Choice>>> iteratorC = tree.children(position);
			//to add root
			if(tree.parent(choice).get(0) == null)
			{

				addEdge(position.element().getValue().getX(),position.element().getValue().getY(),choice.element().getValue().getX(),choice.element().getValue().getY(),position,choice.element().getValue().getArrow());
			}
			
			while(iteratorC.hasNext())
			{		
				Position<Vertex<Choice>> c = iteratorC.next();
				addEdge(c.element().getValue().getX(),c.element().getValue().getY(),position.element().getValue().getX(),position.element().getValue().getY(),c,position.element().getValue().getArrow());
			}
			
				displayEdge(tree, position);
			
		}
		
	}

	static boolean searchResult;
	private static void searchParentVisited(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice, int id) throws Exception 
	{
		if(searchResult)
		{
			return;
		}
		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);
		//checks if root
		/*if(tree.parent(choice).get(0) == null)
		{
			//checks if root is search id
			if(id == root.element().id)
			{
				searchResult = true;
				return;
			}
		}*/
		
		while(iterator.hasNext())
		{
			if(searchResult)
			{
				return;
			}
			
			if(id == root.element().getValue().getID())
			{
				searchResult = true;
				return;
			}

			Position<Vertex<Choice>> position = iterator.next();
			
			//checks if correct node is found
			
			
			
			if(id == position.element().getValue().getID())
			{
				

				//checks if parent node has been visited before

				for(Position<Vertex<Choice>> c : tree.parent(position))
				{
					//searchResult = c.element().getVisited();

					if(c.element().getValue().getVisited())
					{
						searchResult = true;
						return;
					}
				}
				
			}
			
			searchParentVisited(tree, position, id);	
		}	
	}
	
	static boolean searchChildResult;
	private static void searchFellowChildVisited(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice, int id) throws Exception 
	{

		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);
		//checks if root
		if(tree.parent(choice).get(0) == null)
		{
			//checks if root is search id
			if(id == root.element().getValue().getID())
			{
				//System.out.println("root found");
				searchChildResult = true;
				return;
			}
		}
		
		while(iterator.hasNext())
		{
			
			Position<Vertex<Choice>> position = iterator.next();
			//checks if correct node is found
			if(id == position.element().getValue().getID())
			{

				//goes over all children of that paren
				Iterator<Position<Vertex<Choice>>> iteratorChild = tree.children(tree.parent(position).get(0));
				
				while(iteratorChild.hasNext())
				{
					
					Position<Vertex<Choice>> positionChild = iteratorChild.next();
					//System.out.println(positionChild.element().getID() + "  "+ positionChild.element().getVisited());
					//if child visited, return false
					if(positionChild.element().getValue().getVisited())
					{
						searchChildResult = false;
						return;
					}
				}
					

				
			}
			
			searchFellowChildVisited(tree, position, id);	
		}	
		//System.out.println("failure");
		
	}

	
	private static void printChoices()
	{
		for(Position<Vertex<Choice>> p : vertexPath)
		{
			
			System.out.println(p.element().getValue().toString() + "\n");
		}
	}
	
	private static void shortestPath(Position<Vertex<Choice>> lastPosition) throws Exception
	{
		

		Iterator<Position<Vertex<Choice>>> childPosition = tree.children(lastPosition);
		
		while(childPosition.hasNext())
		{
			Vertex<Choice>>> childPosition
		}
		if(!vertexPath.isEmpty())
		{
			
			Position<Vertex<Choice>> lastVertex = vertexPath.get(vertexPath.size()-1);
			
		}

	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-19 12:54:13.921
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-19 12:54:13.922
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-19 12:54:15.029
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------


import java.util.ArrayList;
import java.util.Iterator;

import com.jwetherell.algorithms.data_structures.Graph;
import com.jwetherell.algorithms.data_structures.Graph.Vertex;

import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.TextArea;
import javafx.scene.input.MouseDragEvent;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.Pane;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Line;
import javafx.scene.shape.Polygon;
import javafx.scene.shape.Shape;
import javafx.stage.Stage;
import javafx.stage.StageStyle;

public class GraphPane extends StackPane
{
	static Pane pane;
	static int total;
	static TextArea txtTotal;
	static TextArea txtDisplay;
	static GridPane gridPane;
	static GraphPane graphPane;
	static Tree<Vertex<Choice>> tree;
	static Position<Vertex<Choice>> root;
	static ScrollPane scrollPane;
	
	static ArrayList<Position<Vertex<Choice>>> vertexPath = new ArrayList<Position<Vertex<Choice>>>();
	static ArrayList<Button> choicePath = new ArrayList<Button>();
	static int choiceNumber = -1;
	
	public GraphPane()
	{
		
		graphPane = this;
		gridPane = new GridPane();
		//setting vbox/controls
		VBox vbox = new VBox();
		vbox.setMaxSize(800, 800);
		//setting pane/graph
		pane = new Pane();
		pane.setPrefSize(2000, 2000);
		
		//scrollpane
		scrollPane = new ScrollPane();
		scrollPane.setContent(pane);
		scrollPane.setPrefSize(600, 600);
		//adding both to main borderpane for layout



		
		//adding controls to vbox
		Label lblTotal = new Label("Total:");
		txtTotal = new TextArea();
		txtTotal.setPrefSize(getPrefWidth(), 20);
		
		Label lblDisplay = new Label("Display:");
		txtDisplay = new TextArea();
		txtDisplay.setPrefSize(getPrefWidth(), 20);
		
		//add buttons
		
		Button btnGoBack = new Button("Go Back One Choice");
		btnGoBack.setPrefSize(200, 30);
		
		Button btnDisplayChoices = new Button("Display Current Choices Info");
		btnDisplayChoices.setPrefSize(200, 30);


		
		gridPane.add(lblTotal, 0, 0);
		gridPane.add(txtTotal, 0, 1);
		gridPane.add(lblDisplay, 0, 2);
		gridPane.add(txtDisplay, 0, 3);
		gridPane.add(btnGoBack, 0, 4);
		gridPane.add(btnDisplayChoices, 1, 4);
		
		vbox.getChildren().add(gridPane);
		vbox.getChildren().add(scrollPane);
		
		this.getChildren().add(vbox);
		
		//generate tree and fill it
		ModifyTree modifyTree = new ModifyTree();
		
		tree = modifyTree.getTree();
		root = modifyTree.getRoot();
		
		try 
		{
			displayNodes(tree, root);
			displayEdge(tree, root);
			//System.out.println(tree.preOrderElementTraversal(tree, root));
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		//set buttons actipns
		
		btnGoBack.setOnAction(new EventHandler <ActionEvent>()
		{
			@Override
			public void handle(ActionEvent event) 
			{
				goBack();
			}		
		});
		
		btnDisplayChoices.setOnAction(new EventHandler <ActionEvent>()
		{
			@Override
			public void handle(ActionEvent event) 
			{
				//shortestPath();
				printChoices();
			}		
		});
		

		////
		
	}
	
	public static void goBack()
	{
		
		//if choice exists
		if(choiceNumber > -1)
		{
			//go back one on button
			Button button = choicePath.get(choiceNumber);
			button.setTextFill(null);
			button.setStyle("-fx-background-color: BLACK");
			System.out.println(button.getText());
			//go back on 
			Position<Vertex<Choice>> vertex = vertexPath.get(choiceNumber);
			vertex.element().getValue().setDisplayed(false);
			vertex.element().getValue().setVisited(false);
			
			//now get rid of button and vertex from list
			vertexPath.remove(choiceNumber);
			choicePath.remove(choiceNumber);
			
			total -= vertex.element().getWeight();
			txtTotal.setText("R"+total);
			choiceNumber--;
			
			
		}else
		{
			graphPane.setVisible(false);
			//go to error pane
			ErrorPane root = new ErrorPane("ERROR: There is no node selected to undo.", graphPane);
			Stage secondStage = new Stage();
			
			//secondStage.initStyle(StageStyle.UNDECORATED);
	        secondStage.setScene(new Scene(root));
	        secondStage.setTitle("Error");
	        secondStage.show();
	        return;
		}

	}
	
	public void addToPath(Position<Vertex<Choice>> elem,Button button)
	{
		vertexPath.add(elem);
		choicePath.add(button);
		choiceNumber++;
		
		total += elem.element().getWeight();
		txtTotal.setText("R"+total);
	}
	
	final static int nodeSize = 50;
	final static int edgeSize = 50;
	public static void addNode(int x, int y, Position<Vertex<Choice>> elem)
	{
		
		Button button = new Button(""+elem.element().getValue().getID());
		button.setShape(new Circle(10));
		button.setPrefSize(nodeSize,nodeSize);
		button.setLayoutX(x);
		button.setLayoutY(y);
		button.setTextFill(null);
		button.setStyle("-fx-background-color: BLACK");
		
		Label lblName = new Label(elem.element().getValue().getName());
		lblName.setLayoutX(x);
		lblName.setLayoutY(y-15);
		
		pane.getChildren().add(lblName);
		pane.getChildren().add(button);
		

		button.setOnAction(new EventHandler <ActionEvent>()
		{
			
			@Override
			public void handle(ActionEvent event) 
			{
				//total += elem;
				txtTotal.setText(""+total);
				graphPane.setVisible(false);
				
				//this is to search if parent has been visisted
				searchResult = false;
				//this is to search if a fellow child has been visited
				searchChildResult = true;
				try 
				{
					searchParentVisited(tree,  root, Integer.parseInt(button.getText()));
					searchFellowChildVisited(tree,  root, Integer.parseInt(button.getText()));
	
				} catch (Exception e) 
				{
					e.printStackTrace();
				}
				
				
				//if parent not visited yet
				if(!searchResult)
				{
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: Parent of Choice not selected yet.", graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
			        return;
					
				}else
				if(!searchChildResult)//now check if a fellow child has already been chosen
				{
								
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: You cannot choose more than one choice at the same depth", graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
			        return;
					
					
				}else
				if(button.getTextFill() == null)//if button viable
				{
					//opens main menu
					InfoPane root = new InfoPane(elem, button, graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Info");
			        secondStage.show();
					
				}else
				if(button.getTextFill().equals(Color.BLUE))//if buttons already been selected
				{
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: This option has already been selected.", graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
				}else
				{

					
				}
			}			
		});
	}
	
	public static void addEdge(int xP, int yP,int x, int y, Position<Vertex<Choice>> choice, int arrowPlacement)
	{	

		int posChange = 30;
		int midpointX = (xP+x+2*posChange)/2;
		int midpointY = (yP+y+2*posChange)/2;
		//System.out.println(xP +"-"+yP+"-"+x+"-"+y);
		//create line/edge from start to end
		Line line = new Line(xP+posChange, yP+posChange, x+posChange, y+posChange);
		Label lblWeight = new Label(""+choice.element().getWeight());
		lblWeight.setLayoutX(midpointX);
		lblWeight.setLayoutY(midpointY);
		
		//create directional arrow on line
		//Line arrowUp = new Line(x+15, y+25, x+30, y+30);
		//Line arrowDown = new Line(x+25, y+15, x+30, y+30);
		

		//if(xP != x && yP != y)
		{
			if(arrowPlacement > choice.element().getValue().getArrow())//upper bound
			{
				Polygon polygon = new Polygon();
		        polygon.getPoints().addAll(new Double[]{
		        		(double) (midpointX-15),(double) midpointY+10,
		        		(double) midpointX,(double) midpointY+15,
		        		(double) midpointX, (double) midpointY,
		        });

				pane.getChildren().add(polygon);

	
			}else
			if(arrowPlacement == choice.element().getValue().getArrow())//middle bound
			{

				Polygon polygon = new Polygon();
		        polygon.getPoints().addAll(new Double[]{
		        		(double) (midpointX-20),(double) midpointY-10,
		        		(double) midpointX,(double) midpointY,
		        		(double) midpointX-20, (double) midpointY+10,
		        });

				pane.getChildren().add(polygon);
				
			}else
			if(arrowPlacement < choice.element().getValue().getArrow())//lower bound
			{
				
				Polygon polygon = new Polygon();
		        polygon.getPoints().addAll(new Double[]{
		        		(double) (midpointX),(double) midpointY-20,
		        		(double) midpointX,(double) midpointY,
		        		(double) midpointX-20, (double) midpointY-10,
		        });

				pane.getChildren().add(polygon);
			}
		}
		//add line to pane
		//pane.getChildren().add(arrowUp);
		//pane.getChildren().add(arrowDown);
		pane.getChildren().add(line);
		pane.getChildren().add(lblWeight);
	}
	

	static int loop = 0;
	static int iteration = 1;
	static boolean endFound = false;

	private static void displayNodes(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice) throws Exception 
	{
		
		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);

		if(tree.parent(choice).get(0) == null)
		{
			choice.element().getValue().setX(0);
			choice.element().getValue().setY((int)scrollPane.getPrefHeight()/2);
			choice.element().getValue().setArrow(0);
			
			addNode(0, choice.element().getValue().getY(), choice);
		}
		
		while(iterator.hasNext())
		{
			//counts at which child you are currently at
			loop++;
			
			if(loop==3)
			{
				loop = 1;
			}
			
			Position<Vertex<Choice>> position = iterator.next();
			
			if(position.element().getValue().getDisplayed())
			{
				//System.out.println(position.toString() +"    ddddddd");
			}	
			else
			{
			
			//get depth which is the x axis
			int depth = tree.depth(tree, position);
			
			//calcuate y
			double numChild = tree.getNumChildren(tree.parent(position).get(0));


			
			int parentChoice = 0;
			//determines how a child of one parents should look

			if(tree.parent(position).size() == 1)
			{
				parentChoice = 0;
			}else
			if(tree.parent(position).size() % 2 == 0)//determines how a child of many parents should look - if even
			{
					parentChoice = tree.getNumChildren(tree.parent(position).get(0))/2;
					
				}else//determines how a child of many parents should look - if odd
				{
					
					parentChoice = (int)(tree.getNumChildren(tree.parent(position).get(0))/2+0.5);
					
				}
				
				//this is the # in order ofwhen the child was added to a parent
				int childNum = position.element().getValue().getChildNum();
				if(numChild <= 1)
				{
					
					position.element().getValue().setY(root.element().getValue().getY());
					position.element().getValue().setArrow(0);
				}
				else
				if(numChild/2 >= childNum || childNum==1)//in lower bound of loop
				{
					
					//set above parent
					position.element().getValue().setY(tree.parent(position).get(0).element().getValue().getY()-200/childNum);
					position.element().getValue().setArrow(-1);
					
				}else
				if(numChild/2 == childNum || numChild/2 == childNum-0.5)//at centre of loop
				{
	
					//set same as parent Y axis
					position.element().getValue().setY(tree.parent(position).get(0).element().getValue().getY());
					position.element().getValue().setArrow(0);
	
				}else
				{
					if((numChild+1-childNum) <= 0)
					{
						//set below parent
						position.element().getValue().setY((int)(tree.parent(position).get(0).element().getValue().getY()+200/(-numChild+1+childNum)));
						position.element().getValue().setArrow(1);
					}else
					{
						//set below parent
						position.element().getValue().setY((int)(tree.parent(position).get(0).element().getValue().getY()+200/(numChild+1-childNum)));
						position.element().getValue().setArrow(1);
					}
					
					
				}
						
	
				/*if(position.element().getValue().getID() == 7)
				{
					System.out.println("numPdasdasasdsad "+ tree.parent(position).size());
				}*/
				
				position.element().getValue().setX(depth*100);
				if(position.element().getValue().getY() > 1000)
				{
					System.out.println("\nID " + position.element().getValue().getID()+"   X: "+ position.element().getValue().getX()+"   Y: "+position.element().getValue().getY());
					System.out.println("loop " + loop+"   numChild: "+numChild+"\n");
				}
				
				
				//add nodes
				addNode(position.element().getValue().getX(), position.element().getValue().getY(),position);
				position.element().getValue().setDisplayed(true);
				//add all edges - can have many parents
				/*
				if(tree.getNumChildren(position) == 0)
				{
					loop = 0;
					endFound = true;
					iteration++;
				}*/
			}
			

			
			displayNodes(tree, position);
			
		}
		
	}
	
	
	
	private static void displayEdge(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice) throws Exception 
	{
		
		
		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);
		
		while(iterator.hasNext())
		{	
			Position<Vertex<Choice>> position = iterator.next();
			
			Iterator<Position<Vertex<Choice>>> iteratorC = tree.children(position);
			//to add root
			if(tree.parent(choice).get(0) == null)
			{

				addEdge(position.element().getValue().getX(),position.element().getValue().getY(),choice.element().getValue().getX(),choice.element().getValue().getY(),position,choice.element().getValue().getArrow());
			}
			
			while(iteratorC.hasNext())
			{		
				Position<Vertex<Choice>> c = iteratorC.next();
				addEdge(c.element().getValue().getX(),c.element().getValue().getY(),position.element().getValue().getX(),position.element().getValue().getY(),c,position.element().getValue().getArrow());
			}
			
				displayEdge(tree, position);
			
		}
		
	}

	static boolean searchResult;
	private static void searchParentVisited(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice, int id) throws Exception 
	{
		if(searchResult)
		{
			return;
		}
		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);
		//checks if root
		/*if(tree.parent(choice).get(0) == null)
		{
			//checks if root is search id
			if(id == root.element().id)
			{
				searchResult = true;
				return;
			}
		}*/
		
		while(iterator.hasNext())
		{
			if(searchResult)
			{
				return;
			}
			
			if(id == root.element().getValue().getID())
			{
				searchResult = true;
				return;
			}

			Position<Vertex<Choice>> position = iterator.next();
			
			//checks if correct node is found
			
			
			
			if(id == position.element().getValue().getID())
			{
				

				//checks if parent node has been visited before

				for(Position<Vertex<Choice>> c : tree.parent(position))
				{
					//searchResult = c.element().getVisited();

					if(c.element().getValue().getVisited())
					{
						searchResult = true;
						return;
					}
				}
				
			}
			
			searchParentVisited(tree, position, id);	
		}	
	}
	
	static boolean searchChildResult;
	private static void searchFellowChildVisited(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice, int id) throws Exception 
	{

		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);
		//checks if root
		if(tree.parent(choice).get(0) == null)
		{
			//checks if root is search id
			if(id == root.element().getValue().getID())
			{
				//System.out.println("root found");
				searchChildResult = true;
				return;
			}
		}
		
		while(iterator.hasNext())
		{
			
			Position<Vertex<Choice>> position = iterator.next();
			//checks if correct node is found
			if(id == position.element().getValue().getID())
			{

				//goes over all children of that paren
				Iterator<Position<Vertex<Choice>>> iteratorChild = tree.children(tree.parent(position).get(0));
				
				while(iteratorChild.hasNext())
				{
					
					Position<Vertex<Choice>> positionChild = iteratorChild.next();
					//System.out.println(positionChild.element().getID() + "  "+ positionChild.element().getVisited());
					//if child visited, return false
					if(positionChild.element().getValue().getVisited())
					{
						searchChildResult = false;
						return;
					}
				}
					

				
			}
			
			searchFellowChildVisited(tree, position, id);	
		}	
		//System.out.println("failure");
		
	}

	
	private static void printChoices()
	{
		for(Position<Vertex<Choice>> p : vertexPath)
		{
			
			System.out.println(p.element().getValue().toString() + "\n");
		}
	}
	
	private static void shortestPath(Position<Vertex<Choice>> lastPosition) throws Exception
	{
		

		Iterator<Position<Vertex<Choice>>> childPosition = tree.children(lastPosition);
		
		while(childPosition.hasNext())
		{
			Vertex<Choice>>> childPosition
		}
		if(!vertexPath.isEmpty())
		{
			
			Position<Vertex<Choice>> lastVertex = vertexPath.get(vertexPath.size()-1);
			
		}

	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-19 12:54:15.033
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-19 12:54:15.034
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-19 12:54:16.125
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------


import java.util.ArrayList;
import java.util.Iterator;

import com.jwetherell.algorithms.data_structures.Graph;
import com.jwetherell.algorithms.data_structures.Graph.Vertex;

import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.TextArea;
import javafx.scene.input.MouseDragEvent;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.Pane;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Line;
import javafx.scene.shape.Polygon;
import javafx.scene.shape.Shape;
import javafx.stage.Stage;
import javafx.stage.StageStyle;

public class GraphPane extends StackPane
{
	static Pane pane;
	static int total;
	static TextArea txtTotal;
	static TextArea txtDisplay;
	static GridPane gridPane;
	static GraphPane graphPane;
	static Tree<Vertex<Choice>> tree;
	static Position<Vertex<Choice>> root;
	static ScrollPane scrollPane;
	
	static ArrayList<Position<Vertex<Choice>>> vertexPath = new ArrayList<Position<Vertex<Choice>>>();
	static ArrayList<Button> choicePath = new ArrayList<Button>();
	static int choiceNumber = -1;
	
	public GraphPane()
	{
		
		graphPane = this;
		gridPane = new GridPane();
		//setting vbox/controls
		VBox vbox = new VBox();
		vbox.setMaxSize(800, 800);
		//setting pane/graph
		pane = new Pane();
		pane.setPrefSize(2000, 2000);
		
		//scrollpane
		scrollPane = new ScrollPane();
		scrollPane.setContent(pane);
		scrollPane.setPrefSize(600, 600);
		//adding both to main borderpane for layout



		
		//adding controls to vbox
		Label lblTotal = new Label("Total:");
		txtTotal = new TextArea();
		txtTotal.setPrefSize(getPrefWidth(), 20);
		
		Label lblDisplay = new Label("Display:");
		txtDisplay = new TextArea();
		txtDisplay.setPrefSize(getPrefWidth(), 20);
		
		//add buttons
		
		Button btnGoBack = new Button("Go Back One Choice");
		btnGoBack.setPrefSize(200, 30);
		
		Button btnDisplayChoices = new Button("Display Current Choices Info");
		btnDisplayChoices.setPrefSize(200, 30);


		
		gridPane.add(lblTotal, 0, 0);
		gridPane.add(txtTotal, 0, 1);
		gridPane.add(lblDisplay, 0, 2);
		gridPane.add(txtDisplay, 0, 3);
		gridPane.add(btnGoBack, 0, 4);
		gridPane.add(btnDisplayChoices, 1, 4);
		
		vbox.getChildren().add(gridPane);
		vbox.getChildren().add(scrollPane);
		
		this.getChildren().add(vbox);
		
		//generate tree and fill it
		ModifyTree modifyTree = new ModifyTree();
		
		tree = modifyTree.getTree();
		root = modifyTree.getRoot();
		
		try 
		{
			displayNodes(tree, root);
			displayEdge(tree, root);
			//System.out.println(tree.preOrderElementTraversal(tree, root));
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		//set buttons actipns
		
		btnGoBack.setOnAction(new EventHandler <ActionEvent>()
		{
			@Override
			public void handle(ActionEvent event) 
			{
				goBack();
			}		
		});
		
		btnDisplayChoices.setOnAction(new EventHandler <ActionEvent>()
		{
			@Override
			public void handle(ActionEvent event) 
			{
				//shortestPath();
				printChoices();
			}		
		});
		

		////
		
	}
	
	public static void goBack()
	{
		
		//if choice exists
		if(choiceNumber > -1)
		{
			//go back one on button
			Button button = choicePath.get(choiceNumber);
			button.setTextFill(null);
			button.setStyle("-fx-background-color: BLACK");
			System.out.println(button.getText());
			//go back on 
			Position<Vertex<Choice>> vertex = vertexPath.get(choiceNumber);
			vertex.element().getValue().setDisplayed(false);
			vertex.element().getValue().setVisited(false);
			
			//now get rid of button and vertex from list
			vertexPath.remove(choiceNumber);
			choicePath.remove(choiceNumber);
			
			total -= vertex.element().getWeight();
			txtTotal.setText("R"+total);
			choiceNumber--;
			
			
		}else
		{
			graphPane.setVisible(false);
			//go to error pane
			ErrorPane root = new ErrorPane("ERROR: There is no node selected to undo.", graphPane);
			Stage secondStage = new Stage();
			
			//secondStage.initStyle(StageStyle.UNDECORATED);
	        secondStage.setScene(new Scene(root));
	        secondStage.setTitle("Error");
	        secondStage.show();
	        return;
		}

	}
	
	public void addToPath(Position<Vertex<Choice>> elem,Button button)
	{
		vertexPath.add(elem);
		choicePath.add(button);
		choiceNumber++;
		
		total += elem.element().getWeight();
		txtTotal.setText("R"+total);
	}
	
	final static int nodeSize = 50;
	final static int edgeSize = 50;
	public static void addNode(int x, int y, Position<Vertex<Choice>> elem)
	{
		
		Button button = new Button(""+elem.element().getValue().getID());
		button.setShape(new Circle(10));
		button.setPrefSize(nodeSize,nodeSize);
		button.setLayoutX(x);
		button.setLayoutY(y);
		button.setTextFill(null);
		button.setStyle("-fx-background-color: BLACK");
		
		Label lblName = new Label(elem.element().getValue().getName());
		lblName.setLayoutX(x);
		lblName.setLayoutY(y-15);
		
		pane.getChildren().add(lblName);
		pane.getChildren().add(button);
		

		button.setOnAction(new EventHandler <ActionEvent>()
		{
			
			@Override
			public void handle(ActionEvent event) 
			{
				//total += elem;
				txtTotal.setText(""+total);
				graphPane.setVisible(false);
				
				//this is to search if parent has been visisted
				searchResult = false;
				//this is to search if a fellow child has been visited
				searchChildResult = true;
				try 
				{
					searchParentVisited(tree,  root, Integer.parseInt(button.getText()));
					searchFellowChildVisited(tree,  root, Integer.parseInt(button.getText()));
	
				} catch (Exception e) 
				{
					e.printStackTrace();
				}
				
				
				//if parent not visited yet
				if(!searchResult)
				{
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: Parent of Choice not selected yet.", graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
			        return;
					
				}else
				if(!searchChildResult)//now check if a fellow child has already been chosen
				{
								
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: You cannot choose more than one choice at the same depth", graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
			        return;
					
					
				}else
				if(button.getTextFill() == null)//if button viable
				{
					//opens main menu
					InfoPane root = new InfoPane(elem, button, graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Info");
			        secondStage.show();
					
				}else
				if(button.getTextFill().equals(Color.BLUE))//if buttons already been selected
				{
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: This option has already been selected.", graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
				}else
				{

					
				}
			}			
		});
	}
	
	public static void addEdge(int xP, int yP,int x, int y, Position<Vertex<Choice>> choice, int arrowPlacement)
	{	

		int posChange = 30;
		int midpointX = (xP+x+2*posChange)/2;
		int midpointY = (yP+y+2*posChange)/2;
		//System.out.println(xP +"-"+yP+"-"+x+"-"+y);
		//create line/edge from start to end
		Line line = new Line(xP+posChange, yP+posChange, x+posChange, y+posChange);
		Label lblWeight = new Label(""+choice.element().getWeight());
		lblWeight.setLayoutX(midpointX);
		lblWeight.setLayoutY(midpointY);
		
		//create directional arrow on line
		//Line arrowUp = new Line(x+15, y+25, x+30, y+30);
		//Line arrowDown = new Line(x+25, y+15, x+30, y+30);
		

		//if(xP != x && yP != y)
		{
			if(arrowPlacement > choice.element().getValue().getArrow())//upper bound
			{
				Polygon polygon = new Polygon();
		        polygon.getPoints().addAll(new Double[]{
		        		(double) (midpointX-15),(double) midpointY+10,
		        		(double) midpointX,(double) midpointY+15,
		        		(double) midpointX, (double) midpointY,
		        });

				pane.getChildren().add(polygon);

	
			}else
			if(arrowPlacement == choice.element().getValue().getArrow())//middle bound
			{

				Polygon polygon = new Polygon();
		        polygon.getPoints().addAll(new Double[]{
		        		(double) (midpointX-20),(double) midpointY-10,
		        		(double) midpointX,(double) midpointY,
		        		(double) midpointX-20, (double) midpointY+10,
		        });

				pane.getChildren().add(polygon);
				
			}else
			if(arrowPlacement < choice.element().getValue().getArrow())//lower bound
			{
				
				Polygon polygon = new Polygon();
		        polygon.getPoints().addAll(new Double[]{
		        		(double) (midpointX),(double) midpointY-20,
		        		(double) midpointX,(double) midpointY,
		        		(double) midpointX-20, (double) midpointY-10,
		        });

				pane.getChildren().add(polygon);
			}
		}
		//add line to pane
		//pane.getChildren().add(arrowUp);
		//pane.getChildren().add(arrowDown);
		pane.getChildren().add(line);
		pane.getChildren().add(lblWeight);
	}
	

	static int loop = 0;
	static int iteration = 1;
	static boolean endFound = false;

	private static void displayNodes(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice) throws Exception 
	{
		
		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);

		if(tree.parent(choice).get(0) == null)
		{
			choice.element().getValue().setX(0);
			choice.element().getValue().setY((int)scrollPane.getPrefHeight()/2);
			choice.element().getValue().setArrow(0);
			
			addNode(0, choice.element().getValue().getY(), choice);
		}
		
		while(iterator.hasNext())
		{
			//counts at which child you are currently at
			loop++;
			
			if(loop==3)
			{
				loop = 1;
			}
			
			Position<Vertex<Choice>> position = iterator.next();
			
			if(position.element().getValue().getDisplayed())
			{
				//System.out.println(position.toString() +"    ddddddd");
			}	
			else
			{
			
			//get depth which is the x axis
			int depth = tree.depth(tree, position);
			
			//calcuate y
			double numChild = tree.getNumChildren(tree.parent(position).get(0));


			
			int parentChoice = 0;
			//determines how a child of one parents should look

			if(tree.parent(position).size() == 1)
			{
				parentChoice = 0;
			}else
			if(tree.parent(position).size() % 2 == 0)//determines how a child of many parents should look - if even
			{
					parentChoice = tree.getNumChildren(tree.parent(position).get(0))/2;
					
				}else//determines how a child of many parents should look - if odd
				{
					
					parentChoice = (int)(tree.getNumChildren(tree.parent(position).get(0))/2+0.5);
					
				}
				
				//this is the # in order ofwhen the child was added to a parent
				int childNum = position.element().getValue().getChildNum();
				if(numChild <= 1)
				{
					
					position.element().getValue().setY(root.element().getValue().getY());
					position.element().getValue().setArrow(0);
				}
				else
				if(numChild/2 >= childNum || childNum==1)//in lower bound of loop
				{
					
					//set above parent
					position.element().getValue().setY(tree.parent(position).get(0).element().getValue().getY()-200/childNum);
					position.element().getValue().setArrow(-1);
					
				}else
				if(numChild/2 == childNum || numChild/2 == childNum-0.5)//at centre of loop
				{
	
					//set same as parent Y axis
					position.element().getValue().setY(tree.parent(position).get(0).element().getValue().getY());
					position.element().getValue().setArrow(0);
	
				}else
				{
					if((numChild+1-childNum) <= 0)
					{
						//set below parent
						position.element().getValue().setY((int)(tree.parent(position).get(0).element().getValue().getY()+200/(-numChild+1+childNum)));
						position.element().getValue().setArrow(1);
					}else
					{
						//set below parent
						position.element().getValue().setY((int)(tree.parent(position).get(0).element().getValue().getY()+200/(numChild+1-childNum)));
						position.element().getValue().setArrow(1);
					}
					
					
				}
						
	
				/*if(position.element().getValue().getID() == 7)
				{
					System.out.println("numPdasdasasdsad "+ tree.parent(position).size());
				}*/
				
				position.element().getValue().setX(depth*100);
				if(position.element().getValue().getY() > 1000)
				{
					System.out.println("\nID " + position.element().getValue().getID()+"   X: "+ position.element().getValue().getX()+"   Y: "+position.element().getValue().getY());
					System.out.println("loop " + loop+"   numChild: "+numChild+"\n");
				}
				
				
				//add nodes
				addNode(position.element().getValue().getX(), position.element().getValue().getY(),position);
				position.element().getValue().setDisplayed(true);
				//add all edges - can have many parents
				/*
				if(tree.getNumChildren(position) == 0)
				{
					loop = 0;
					endFound = true;
					iteration++;
				}*/
			}
			

			
			displayNodes(tree, position);
			
		}
		
	}
	
	
	
	private static void displayEdge(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice) throws Exception 
	{
		
		
		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);
		
		while(iterator.hasNext())
		{	
			Position<Vertex<Choice>> position = iterator.next();
			
			Iterator<Position<Vertex<Choice>>> iteratorC = tree.children(position);
			//to add root
			if(tree.parent(choice).get(0) == null)
			{

				addEdge(position.element().getValue().getX(),position.element().getValue().getY(),choice.element().getValue().getX(),choice.element().getValue().getY(),position,choice.element().getValue().getArrow());
			}
			
			while(iteratorC.hasNext())
			{		
				Position<Vertex<Choice>> c = iteratorC.next();
				addEdge(c.element().getValue().getX(),c.element().getValue().getY(),position.element().getValue().getX(),position.element().getValue().getY(),c,position.element().getValue().getArrow());
			}
			
				displayEdge(tree, position);
			
		}
		
	}

	static boolean searchResult;
	private static void searchParentVisited(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice, int id) throws Exception 
	{
		if(searchResult)
		{
			return;
		}
		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);
		//checks if root
		/*if(tree.parent(choice).get(0) == null)
		{
			//checks if root is search id
			if(id == root.element().id)
			{
				searchResult = true;
				return;
			}
		}*/
		
		while(iterator.hasNext())
		{
			if(searchResult)
			{
				return;
			}
			
			if(id == root.element().getValue().getID())
			{
				searchResult = true;
				return;
			}

			Position<Vertex<Choice>> position = iterator.next();
			
			//checks if correct node is found
			
			
			
			if(id == position.element().getValue().getID())
			{
				

				//checks if parent node has been visited before

				for(Position<Vertex<Choice>> c : tree.parent(position))
				{
					//searchResult = c.element().getVisited();

					if(c.element().getValue().getVisited())
					{
						searchResult = true;
						return;
					}
				}
				
			}
			
			searchParentVisited(tree, position, id);	
		}	
	}
	
	static boolean searchChildResult;
	private static void searchFellowChildVisited(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice, int id) throws Exception 
	{

		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);
		//checks if root
		if(tree.parent(choice).get(0) == null)
		{
			//checks if root is search id
			if(id == root.element().getValue().getID())
			{
				//System.out.println("root found");
				searchChildResult = true;
				return;
			}
		}
		
		while(iterator.hasNext())
		{
			
			Position<Vertex<Choice>> position = iterator.next();
			//checks if correct node is found
			if(id == position.element().getValue().getID())
			{

				//goes over all children of that paren
				Iterator<Position<Vertex<Choice>>> iteratorChild = tree.children(tree.parent(position).get(0));
				
				while(iteratorChild.hasNext())
				{
					
					Position<Vertex<Choice>> positionChild = iteratorChild.next();
					//System.out.println(positionChild.element().getID() + "  "+ positionChild.element().getVisited());
					//if child visited, return false
					if(positionChild.element().getValue().getVisited())
					{
						searchChildResult = false;
						return;
					}
				}
					

				
			}
			
			searchFellowChildVisited(tree, position, id);	
		}	
		//System.out.println("failure");
		
	}

	
	private static void printChoices()
	{
		for(Position<Vertex<Choice>> p : vertexPath)
		{
			
			System.out.println(p.element().getValue().toString() + "\n");
		}
	}
	
	private static void shortestPath(Position<Vertex<Choice>> lastPosition) throws Exception
	{
		

		Iterator<Position<Vertex<Choice>>> it = tree.children(lastPosition);
		
		while(childPosition.hasNext())
		{
			Vertex<Choice>>> childPosition
		}
		if(!vertexPath.isEmpty())
		{
			
			Position<Vertex<Choice>> lastVertex = vertexPath.get(vertexPath.size()-1);
			
		}

	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-19 12:54:16.126
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------


import java.util.ArrayList;
import java.util.Iterator;

import com.jwetherell.algorithms.data_structures.Graph;
import com.jwetherell.algorithms.data_structures.Graph.Vertex;

import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.TextArea;
import javafx.scene.input.MouseDragEvent;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.Pane;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Line;
import javafx.scene.shape.Polygon;
import javafx.scene.shape.Shape;
import javafx.stage.Stage;
import javafx.stage.StageStyle;

public class GraphPane extends StackPane
{
	static Pane pane;
	static int total;
	static TextArea txtTotal;
	static TextArea txtDisplay;
	static GridPane gridPane;
	static GraphPane graphPane;
	static Tree<Vertex<Choice>> tree;
	static Position<Vertex<Choice>> root;
	static ScrollPane scrollPane;
	
	static ArrayList<Position<Vertex<Choice>>> vertexPath = new ArrayList<Position<Vertex<Choice>>>();
	static ArrayList<Button> choicePath = new ArrayList<Button>();
	static int choiceNumber = -1;
	
	public GraphPane()
	{
		
		graphPane = this;
		gridPane = new GridPane();
		//setting vbox/controls
		VBox vbox = new VBox();
		vbox.setMaxSize(800, 800);
		//setting pane/graph
		pane = new Pane();
		pane.setPrefSize(2000, 2000);
		
		//scrollpane
		scrollPane = new ScrollPane();
		scrollPane.setContent(pane);
		scrollPane.setPrefSize(600, 600);
		//adding both to main borderpane for layout



		
		//adding controls to vbox
		Label lblTotal = new Label("Total:");
		txtTotal = new TextArea();
		txtTotal.setPrefSize(getPrefWidth(), 20);
		
		Label lblDisplay = new Label("Display:");
		txtDisplay = new TextArea();
		txtDisplay.setPrefSize(getPrefWidth(), 20);
		
		//add buttons
		
		Button btnGoBack = new Button("Go Back One Choice");
		btnGoBack.setPrefSize(200, 30);
		
		Button btnDisplayChoices = new Button("Display Current Choices Info");
		btnDisplayChoices.setPrefSize(200, 30);


		
		gridPane.add(lblTotal, 0, 0);
		gridPane.add(txtTotal, 0, 1);
		gridPane.add(lblDisplay, 0, 2);
		gridPane.add(txtDisplay, 0, 3);
		gridPane.add(btnGoBack, 0, 4);
		gridPane.add(btnDisplayChoices, 1, 4);
		
		vbox.getChildren().add(gridPane);
		vbox.getChildren().add(scrollPane);
		
		this.getChildren().add(vbox);
		
		//generate tree and fill it
		ModifyTree modifyTree = new ModifyTree();
		
		tree = modifyTree.getTree();
		root = modifyTree.getRoot();
		
		try 
		{
			displayNodes(tree, root);
			displayEdge(tree, root);
			//System.out.println(tree.preOrderElementTraversal(tree, root));
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		//set buttons actipns
		
		btnGoBack.setOnAction(new EventHandler <ActionEvent>()
		{
			@Override
			public void handle(ActionEvent event) 
			{
				goBack();
			}		
		});
		
		btnDisplayChoices.setOnAction(new EventHandler <ActionEvent>()
		{
			@Override
			public void handle(ActionEvent event) 
			{
				//shortestPath();
				printChoices();
			}		
		});
		

		////
		
	}
	
	public static void goBack()
	{
		
		//if choice exists
		if(choiceNumber > -1)
		{
			//go back one on button
			Button button = choicePath.get(choiceNumber);
			button.setTextFill(null);
			button.setStyle("-fx-background-color: BLACK");
			System.out.println(button.getText());
			//go back on 
			Position<Vertex<Choice>> vertex = vertexPath.get(choiceNumber);
			vertex.element().getValue().setDisplayed(false);
			vertex.element().getValue().setVisited(false);
			
			//now get rid of button and vertex from list
			vertexPath.remove(choiceNumber);
			choicePath.remove(choiceNumber);
			
			total -= vertex.element().getWeight();
			txtTotal.setText("R"+total);
			choiceNumber--;
			
			
		}else
		{
			graphPane.setVisible(false);
			//go to error pane
			ErrorPane root = new ErrorPane("ERROR: There is no node selected to undo.", graphPane);
			Stage secondStage = new Stage();
			
			//secondStage.initStyle(StageStyle.UNDECORATED);
	        secondStage.setScene(new Scene(root));
	        secondStage.setTitle("Error");
	        secondStage.show();
	        return;
		}

	}
	
	public void addToPath(Position<Vertex<Choice>> elem,Button button)
	{
		vertexPath.add(elem);
		choicePath.add(button);
		choiceNumber++;
		
		total += elem.element().getWeight();
		txtTotal.setText("R"+total);
	}
	
	final static int nodeSize = 50;
	final static int edgeSize = 50;
	public static void addNode(int x, int y, Position<Vertex<Choice>> elem)
	{
		
		Button button = new Button(""+elem.element().getValue().getID());
		button.setShape(new Circle(10));
		button.setPrefSize(nodeSize,nodeSize);
		button.setLayoutX(x);
		button.setLayoutY(y);
		button.setTextFill(null);
		button.setStyle("-fx-background-color: BLACK");
		
		Label lblName = new Label(elem.element().getValue().getName());
		lblName.setLayoutX(x);
		lblName.setLayoutY(y-15);
		
		pane.getChildren().add(lblName);
		pane.getChildren().add(button);
		

		button.setOnAction(new EventHandler <ActionEvent>()
		{
			
			@Override
			public void handle(ActionEvent event) 
			{
				//total += elem;
				txtTotal.setText(""+total);
				graphPane.setVisible(false);
				
				//this is to search if parent has been visisted
				searchResult = false;
				//this is to search if a fellow child has been visited
				searchChildResult = true;
				try 
				{
					searchParentVisited(tree,  root, Integer.parseInt(button.getText()));
					searchFellowChildVisited(tree,  root, Integer.parseInt(button.getText()));
	
				} catch (Exception e) 
				{
					e.printStackTrace();
				}
				
				
				//if parent not visited yet
				if(!searchResult)
				{
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: Parent of Choice not selected yet.", graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
			        return;
					
				}else
				if(!searchChildResult)//now check if a fellow child has already been chosen
				{
								
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: You cannot choose more than one choice at the same depth", graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
			        return;
					
					
				}else
				if(button.getTextFill() == null)//if button viable
				{
					//opens main menu
					InfoPane root = new InfoPane(elem, button, graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Info");
			        secondStage.show();
					
				}else
				if(button.getTextFill().equals(Color.BLUE))//if buttons already been selected
				{
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: This option has already been selected.", graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
				}else
				{

					
				}
			}			
		});
	}
	
	public static void addEdge(int xP, int yP,int x, int y, Position<Vertex<Choice>> choice, int arrowPlacement)
	{	

		int posChange = 30;
		int midpointX = (xP+x+2*posChange)/2;
		int midpointY = (yP+y+2*posChange)/2;
		//System.out.println(xP +"-"+yP+"-"+x+"-"+y);
		//create line/edge from start to end
		Line line = new Line(xP+posChange, yP+posChange, x+posChange, y+posChange);
		Label lblWeight = new Label(""+choice.element().getWeight());
		lblWeight.setLayoutX(midpointX);
		lblWeight.setLayoutY(midpointY);
		
		//create directional arrow on line
		//Line arrowUp = new Line(x+15, y+25, x+30, y+30);
		//Line arrowDown = new Line(x+25, y+15, x+30, y+30);
		

		//if(xP != x && yP != y)
		{
			if(arrowPlacement > choice.element().getValue().getArrow())//upper bound
			{
				Polygon polygon = new Polygon();
		        polygon.getPoints().addAll(new Double[]{
		        		(double) (midpointX-15),(double) midpointY+10,
		        		(double) midpointX,(double) midpointY+15,
		        		(double) midpointX, (double) midpointY,
		        });

				pane.getChildren().add(polygon);

	
			}else
			if(arrowPlacement == choice.element().getValue().getArrow())//middle bound
			{

				Polygon polygon = new Polygon();
		        polygon.getPoints().addAll(new Double[]{
		        		(double) (midpointX-20),(double) midpointY-10,
		        		(double) midpointX,(double) midpointY,
		        		(double) midpointX-20, (double) midpointY+10,
		        });

				pane.getChildren().add(polygon);
				
			}else
			if(arrowPlacement < choice.element().getValue().getArrow())//lower bound
			{
				
				Polygon polygon = new Polygon();
		        polygon.getPoints().addAll(new Double[]{
		        		(double) (midpointX),(double) midpointY-20,
		        		(double) midpointX,(double) midpointY,
		        		(double) midpointX-20, (double) midpointY-10,
		        });

				pane.getChildren().add(polygon);
			}
		}
		//add line to pane
		//pane.getChildren().add(arrowUp);
		//pane.getChildren().add(arrowDown);
		pane.getChildren().add(line);
		pane.getChildren().add(lblWeight);
	}
	

	static int loop = 0;
	static int iteration = 1;
	static boolean endFound = false;

	private static void displayNodes(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice) throws Exception 
	{
		
		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);

		if(tree.parent(choice).get(0) == null)
		{
			choice.element().getValue().setX(0);
			choice.element().getValue().setY((int)scrollPane.getPrefHeight()/2);
			choice.element().getValue().setArrow(0);
			
			addNode(0, choice.element().getValue().getY(), choice);
		}
		
		while(iterator.hasNext())
		{
			//counts at which child you are currently at
			loop++;
			
			if(loop==3)
			{
				loop = 1;
			}
			
			Position<Vertex<Choice>> position = iterator.next();
			
			if(position.element().getValue().getDisplayed())
			{
				//System.out.println(position.toString() +"    ddddddd");
			}	
			else
			{
			
			//get depth which is the x axis
			int depth = tree.depth(tree, position);
			
			//calcuate y
			double numChild = tree.getNumChildren(tree.parent(position).get(0));


			
			int parentChoice = 0;
			//determines how a child of one parents should look

			if(tree.parent(position).size() == 1)
			{
				parentChoice = 0;
			}else
			if(tree.parent(position).size() % 2 == 0)//determines how a child of many parents should look - if even
			{
					parentChoice = tree.getNumChildren(tree.parent(position).get(0))/2;
					
				}else//determines how a child of many parents should look - if odd
				{
					
					parentChoice = (int)(tree.getNumChildren(tree.parent(position).get(0))/2+0.5);
					
				}
				
				//this is the # in order ofwhen the child was added to a parent
				int childNum = position.element().getValue().getChildNum();
				if(numChild <= 1)
				{
					
					position.element().getValue().setY(root.element().getValue().getY());
					position.element().getValue().setArrow(0);
				}
				else
				if(numChild/2 >= childNum || childNum==1)//in lower bound of loop
				{
					
					//set above parent
					position.element().getValue().setY(tree.parent(position).get(0).element().getValue().getY()-200/childNum);
					position.element().getValue().setArrow(-1);
					
				}else
				if(numChild/2 == childNum || numChild/2 == childNum-0.5)//at centre of loop
				{
	
					//set same as parent Y axis
					position.element().getValue().setY(tree.parent(position).get(0).element().getValue().getY());
					position.element().getValue().setArrow(0);
	
				}else
				{
					if((numChild+1-childNum) <= 0)
					{
						//set below parent
						position.element().getValue().setY((int)(tree.parent(position).get(0).element().getValue().getY()+200/(-numChild+1+childNum)));
						position.element().getValue().setArrow(1);
					}else
					{
						//set below parent
						position.element().getValue().setY((int)(tree.parent(position).get(0).element().getValue().getY()+200/(numChild+1-childNum)));
						position.element().getValue().setArrow(1);
					}
					
					
				}
						
	
				/*if(position.element().getValue().getID() == 7)
				{
					System.out.println("numPdasdasasdsad "+ tree.parent(position).size());
				}*/
				
				position.element().getValue().setX(depth*100);
				if(position.element().getValue().getY() > 1000)
				{
					System.out.println("\nID " + position.element().getValue().getID()+"   X: "+ position.element().getValue().getX()+"   Y: "+position.element().getValue().getY());
					System.out.println("loop " + loop+"   numChild: "+numChild+"\n");
				}
				
				
				//add nodes
				addNode(position.element().getValue().getX(), position.element().getValue().getY(),position);
				position.element().getValue().setDisplayed(true);
				//add all edges - can have many parents
				/*
				if(tree.getNumChildren(position) == 0)
				{
					loop = 0;
					endFound = true;
					iteration++;
				}*/
			}
			

			
			displayNodes(tree, position);
			
		}
		
	}
	
	
	
	private static void displayEdge(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice) throws Exception 
	{
		
		
		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);
		
		while(iterator.hasNext())
		{	
			Position<Vertex<Choice>> position = iterator.next();
			
			Iterator<Position<Vertex<Choice>>> iteratorC = tree.children(position);
			//to add root
			if(tree.parent(choice).get(0) == null)
			{

				addEdge(position.element().getValue().getX(),position.element().getValue().getY(),choice.element().getValue().getX(),choice.element().getValue().getY(),position,choice.element().getValue().getArrow());
			}
			
			while(iteratorC.hasNext())
			{		
				Position<Vertex<Choice>> c = iteratorC.next();
				addEdge(c.element().getValue().getX(),c.element().getValue().getY(),position.element().getValue().getX(),position.element().getValue().getY(),c,position.element().getValue().getArrow());
			}
			
				displayEdge(tree, position);
			
		}
		
	}

	static boolean searchResult;
	private static void searchParentVisited(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice, int id) throws Exception 
	{
		if(searchResult)
		{
			return;
		}
		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);
		//checks if root
		/*if(tree.parent(choice).get(0) == null)
		{
			//checks if root is search id
			if(id == root.element().id)
			{
				searchResult = true;
				return;
			}
		}*/
		
		while(iterator.hasNext())
		{
			if(searchResult)
			{
				return;
			}
			
			if(id == root.element().getValue().getID())
			{
				searchResult = true;
				return;
			}

			Position<Vertex<Choice>> position = iterator.next();
			
			//checks if correct node is found
			
			
			
			if(id == position.element().getValue().getID())
			{
				

				//checks if parent node has been visited before

				for(Position<Vertex<Choice>> c : tree.parent(position))
				{
					//searchResult = c.element().getVisited();

					if(c.element().getValue().getVisited())
					{
						searchResult = true;
						return;
					}
				}
				
			}
			
			searchParentVisited(tree, position, id);	
		}	
	}
	
	static boolean searchChildResult;
	private static void searchFellowChildVisited(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice, int id) throws Exception 
	{

		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);
		//checks if root
		if(tree.parent(choice).get(0) == null)
		{
			//checks if root is search id
			if(id == root.element().getValue().getID())
			{
				//System.out.println("root found");
				searchChildResult = true;
				return;
			}
		}
		
		while(iterator.hasNext())
		{
			
			Position<Vertex<Choice>> position = iterator.next();
			//checks if correct node is found
			if(id == position.element().getValue().getID())
			{

				//goes over all children of that paren
				Iterator<Position<Vertex<Choice>>> iteratorChild = tree.children(tree.parent(position).get(0));
				
				while(iteratorChild.hasNext())
				{
					
					Position<Vertex<Choice>> positionChild = iteratorChild.next();
					//System.out.println(positionChild.element().getID() + "  "+ positionChild.element().getVisited());
					//if child visited, return false
					if(positionChild.element().getValue().getVisited())
					{
						searchChildResult = false;
						return;
					}
				}
					

				
			}
			
			searchFellowChildVisited(tree, position, id);	
		}	
		//System.out.println("failure");
		
	}

	
	private static void printChoices()
	{
		for(Position<Vertex<Choice>> p : vertexPath)
		{
			
			System.out.println(p.element().getValue().toString() + "\n");
		}
	}
	
	private static void shortestPath(Position<Vertex<Choice>> lastPosition) throws Exception
	{
		

		Iterator<Position<Vertex<Choice>>> it = tree.children(lastPosition);
		
		while(childPosition.hasNext())
		{
			Vertex<Choice>>> childPosition
		}
		if(!vertexPath.isEmpty())
		{
			
			Position<Vertex<Choice>> lastVertex = vertexPath.get(vertexPath.size()-1);
			
		}

	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-19 12:54:16.128
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.ui 4 2 2023-04-19 12:54:16.129
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-19 12:54:16.129
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.ui 4 0 2023-04-19 12:54:16.130
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-19 12:54:17.711
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------


import java.util.ArrayList;
import java.util.Iterator;

import com.jwetherell.algorithms.data_structures.Graph;
import com.jwetherell.algorithms.data_structures.Graph.Vertex;

import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.TextArea;
import javafx.scene.input.MouseDragEvent;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.Pane;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Line;
import javafx.scene.shape.Polygon;
import javafx.scene.shape.Shape;
import javafx.stage.Stage;
import javafx.stage.StageStyle;

public class GraphPane extends StackPane
{
	static Pane pane;
	static int total;
	static TextArea txtTotal;
	static TextArea txtDisplay;
	static GridPane gridPane;
	static GraphPane graphPane;
	static Tree<Vertex<Choice>> tree;
	static Position<Vertex<Choice>> root;
	static ScrollPane scrollPane;
	
	static ArrayList<Position<Vertex<Choice>>> vertexPath = new ArrayList<Position<Vertex<Choice>>>();
	static ArrayList<Button> choicePath = new ArrayList<Button>();
	static int choiceNumber = -1;
	
	public GraphPane()
	{
		
		graphPane = this;
		gridPane = new GridPane();
		//setting vbox/controls
		VBox vbox = new VBox();
		vbox.setMaxSize(800, 800);
		//setting pane/graph
		pane = new Pane();
		pane.setPrefSize(2000, 2000);
		
		//scrollpane
		scrollPane = new ScrollPane();
		scrollPane.setContent(pane);
		scrollPane.setPrefSize(600, 600);
		//adding both to main borderpane for layout



		
		//adding controls to vbox
		Label lblTotal = new Label("Total:");
		txtTotal = new TextArea();
		txtTotal.setPrefSize(getPrefWidth(), 20);
		
		Label lblDisplay = new Label("Display:");
		txtDisplay = new TextArea();
		txtDisplay.setPrefSize(getPrefWidth(), 20);
		
		//add buttons
		
		Button btnGoBack = new Button("Go Back One Choice");
		btnGoBack.setPrefSize(200, 30);
		
		Button btnDisplayChoices = new Button("Display Current Choices Info");
		btnDisplayChoices.setPrefSize(200, 30);


		
		gridPane.add(lblTotal, 0, 0);
		gridPane.add(txtTotal, 0, 1);
		gridPane.add(lblDisplay, 0, 2);
		gridPane.add(txtDisplay, 0, 3);
		gridPane.add(btnGoBack, 0, 4);
		gridPane.add(btnDisplayChoices, 1, 4);
		
		vbox.getChildren().add(gridPane);
		vbox.getChildren().add(scrollPane);
		
		this.getChildren().add(vbox);
		
		//generate tree and fill it
		ModifyTree modifyTree = new ModifyTree();
		
		tree = modifyTree.getTree();
		root = modifyTree.getRoot();
		
		try 
		{
			displayNodes(tree, root);
			displayEdge(tree, root);
			//System.out.println(tree.preOrderElementTraversal(tree, root));
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		//set buttons actipns
		
		btnGoBack.setOnAction(new EventHandler <ActionEvent>()
		{
			@Override
			public void handle(ActionEvent event) 
			{
				goBack();
			}		
		});
		
		btnDisplayChoices.setOnAction(new EventHandler <ActionEvent>()
		{
			@Override
			public void handle(ActionEvent event) 
			{
				//shortestPath();
				printChoices();
			}		
		});
		

		////
		
	}
	
	public static void goBack()
	{
		
		//if choice exists
		if(choiceNumber > -1)
		{
			//go back one on button
			Button button = choicePath.get(choiceNumber);
			button.setTextFill(null);
			button.setStyle("-fx-background-color: BLACK");
			System.out.println(button.getText());
			//go back on 
			Position<Vertex<Choice>> vertex = vertexPath.get(choiceNumber);
			vertex.element().getValue().setDisplayed(false);
			vertex.element().getValue().setVisited(false);
			
			//now get rid of button and vertex from list
			vertexPath.remove(choiceNumber);
			choicePath.remove(choiceNumber);
			
			total -= vertex.element().getWeight();
			txtTotal.setText("R"+total);
			choiceNumber--;
			
			
		}else
		{
			graphPane.setVisible(false);
			//go to error pane
			ErrorPane root = new ErrorPane("ERROR: There is no node selected to undo.", graphPane);
			Stage secondStage = new Stage();
			
			//secondStage.initStyle(StageStyle.UNDECORATED);
	        secondStage.setScene(new Scene(root));
	        secondStage.setTitle("Error");
	        secondStage.show();
	        return;
		}

	}
	
	public void addToPath(Position<Vertex<Choice>> elem,Button button)
	{
		vertexPath.add(elem);
		choicePath.add(button);
		choiceNumber++;
		
		total += elem.element().getWeight();
		txtTotal.setText("R"+total);
	}
	
	final static int nodeSize = 50;
	final static int edgeSize = 50;
	public static void addNode(int x, int y, Position<Vertex<Choice>> elem)
	{
		
		Button button = new Button(""+elem.element().getValue().getID());
		button.setShape(new Circle(10));
		button.setPrefSize(nodeSize,nodeSize);
		button.setLayoutX(x);
		button.setLayoutY(y);
		button.setTextFill(null);
		button.setStyle("-fx-background-color: BLACK");
		
		Label lblName = new Label(elem.element().getValue().getName());
		lblName.setLayoutX(x);
		lblName.setLayoutY(y-15);
		
		pane.getChildren().add(lblName);
		pane.getChildren().add(button);
		

		button.setOnAction(new EventHandler <ActionEvent>()
		{
			
			@Override
			public void handle(ActionEvent event) 
			{
				//total += elem;
				txtTotal.setText(""+total);
				graphPane.setVisible(false);
				
				//this is to search if parent has been visisted
				searchResult = false;
				//this is to search if a fellow child has been visited
				searchChildResult = true;
				try 
				{
					searchParentVisited(tree,  root, Integer.parseInt(button.getText()));
					searchFellowChildVisited(tree,  root, Integer.parseInt(button.getText()));
	
				} catch (Exception e) 
				{
					e.printStackTrace();
				}
				
				
				//if parent not visited yet
				if(!searchResult)
				{
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: Parent of Choice not selected yet.", graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
			        return;
					
				}else
				if(!searchChildResult)//now check if a fellow child has already been chosen
				{
								
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: You cannot choose more than one choice at the same depth", graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
			        return;
					
					
				}else
				if(button.getTextFill() == null)//if button viable
				{
					//opens main menu
					InfoPane root = new InfoPane(elem, button, graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Info");
			        secondStage.show();
					
				}else
				if(button.getTextFill().equals(Color.BLUE))//if buttons already been selected
				{
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: This option has already been selected.", graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
				}else
				{

					
				}
			}			
		});
	}
	
	public static void addEdge(int xP, int yP,int x, int y, Position<Vertex<Choice>> choice, int arrowPlacement)
	{	

		int posChange = 30;
		int midpointX = (xP+x+2*posChange)/2;
		int midpointY = (yP+y+2*posChange)/2;
		//System.out.println(xP +"-"+yP+"-"+x+"-"+y);
		//create line/edge from start to end
		Line line = new Line(xP+posChange, yP+posChange, x+posChange, y+posChange);
		Label lblWeight = new Label(""+choice.element().getWeight());
		lblWeight.setLayoutX(midpointX);
		lblWeight.setLayoutY(midpointY);
		
		//create directional arrow on line
		//Line arrowUp = new Line(x+15, y+25, x+30, y+30);
		//Line arrowDown = new Line(x+25, y+15, x+30, y+30);
		

		//if(xP != x && yP != y)
		{
			if(arrowPlacement > choice.element().getValue().getArrow())//upper bound
			{
				Polygon polygon = new Polygon();
		        polygon.getPoints().addAll(new Double[]{
		        		(double) (midpointX-15),(double) midpointY+10,
		        		(double) midpointX,(double) midpointY+15,
		        		(double) midpointX, (double) midpointY,
		        });

				pane.getChildren().add(polygon);

	
			}else
			if(arrowPlacement == choice.element().getValue().getArrow())//middle bound
			{

				Polygon polygon = new Polygon();
		        polygon.getPoints().addAll(new Double[]{
		        		(double) (midpointX-20),(double) midpointY-10,
		        		(double) midpointX,(double) midpointY,
		        		(double) midpointX-20, (double) midpointY+10,
		        });

				pane.getChildren().add(polygon);
				
			}else
			if(arrowPlacement < choice.element().getValue().getArrow())//lower bound
			{
				
				Polygon polygon = new Polygon();
		        polygon.getPoints().addAll(new Double[]{
		        		(double) (midpointX),(double) midpointY-20,
		        		(double) midpointX,(double) midpointY,
		        		(double) midpointX-20, (double) midpointY-10,
		        });

				pane.getChildren().add(polygon);
			}
		}
		//add line to pane
		//pane.getChildren().add(arrowUp);
		//pane.getChildren().add(arrowDown);
		pane.getChildren().add(line);
		pane.getChildren().add(lblWeight);
	}
	

	static int loop = 0;
	static int iteration = 1;
	static boolean endFound = false;

	private static void displayNodes(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice) throws Exception 
	{
		
		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);

		if(tree.parent(choice).get(0) == null)
		{
			choice.element().getValue().setX(0);
			choice.element().getValue().setY((int)scrollPane.getPrefHeight()/2);
			choice.element().getValue().setArrow(0);
			
			addNode(0, choice.element().getValue().getY(), choice);
		}
		
		while(iterator.hasNext())
		{
			//counts at which child you are currently at
			loop++;
			
			if(loop==3)
			{
				loop = 1;
			}
			
			Position<Vertex<Choice>> position = iterator.next();
			
			if(position.element().getValue().getDisplayed())
			{
				//System.out.println(position.toString() +"    ddddddd");
			}	
			else
			{
			
			//get depth which is the x axis
			int depth = tree.depth(tree, position);
			
			//calcuate y
			double numChild = tree.getNumChildren(tree.parent(position).get(0));


			
			int parentChoice = 0;
			//determines how a child of one parents should look

			if(tree.parent(position).size() == 1)
			{
				parentChoice = 0;
			}else
			if(tree.parent(position).size() % 2 == 0)//determines how a child of many parents should look - if even
			{
					parentChoice = tree.getNumChildren(tree.parent(position).get(0))/2;
					
				}else//determines how a child of many parents should look - if odd
				{
					
					parentChoice = (int)(tree.getNumChildren(tree.parent(position).get(0))/2+0.5);
					
				}
				
				//this is the # in order ofwhen the child was added to a parent
				int childNum = position.element().getValue().getChildNum();
				if(numChild <= 1)
				{
					
					position.element().getValue().setY(root.element().getValue().getY());
					position.element().getValue().setArrow(0);
				}
				else
				if(numChild/2 >= childNum || childNum==1)//in lower bound of loop
				{
					
					//set above parent
					position.element().getValue().setY(tree.parent(position).get(0).element().getValue().getY()-200/childNum);
					position.element().getValue().setArrow(-1);
					
				}else
				if(numChild/2 == childNum || numChild/2 == childNum-0.5)//at centre of loop
				{
	
					//set same as parent Y axis
					position.element().getValue().setY(tree.parent(position).get(0).element().getValue().getY());
					position.element().getValue().setArrow(0);
	
				}else
				{
					if((numChild+1-childNum) <= 0)
					{
						//set below parent
						position.element().getValue().setY((int)(tree.parent(position).get(0).element().getValue().getY()+200/(-numChild+1+childNum)));
						position.element().getValue().setArrow(1);
					}else
					{
						//set below parent
						position.element().getValue().setY((int)(tree.parent(position).get(0).element().getValue().getY()+200/(numChild+1-childNum)));
						position.element().getValue().setArrow(1);
					}
					
					
				}
						
	
				/*if(position.element().getValue().getID() == 7)
				{
					System.out.println("numPdasdasasdsad "+ tree.parent(position).size());
				}*/
				
				position.element().getValue().setX(depth*100);
				if(position.element().getValue().getY() > 1000)
				{
					System.out.println("\nID " + position.element().getValue().getID()+"   X: "+ position.element().getValue().getX()+"   Y: "+position.element().getValue().getY());
					System.out.println("loop " + loop+"   numChild: "+numChild+"\n");
				}
				
				
				//add nodes
				addNode(position.element().getValue().getX(), position.element().getValue().getY(),position);
				position.element().getValue().setDisplayed(true);
				//add all edges - can have many parents
				/*
				if(tree.getNumChildren(position) == 0)
				{
					loop = 0;
					endFound = true;
					iteration++;
				}*/
			}
			

			
			displayNodes(tree, position);
			
		}
		
	}
	
	
	
	private static void displayEdge(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice) throws Exception 
	{
		
		
		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);
		
		while(iterator.hasNext())
		{	
			Position<Vertex<Choice>> position = iterator.next();
			
			Iterator<Position<Vertex<Choice>>> iteratorC = tree.children(position);
			//to add root
			if(tree.parent(choice).get(0) == null)
			{

				addEdge(position.element().getValue().getX(),position.element().getValue().getY(),choice.element().getValue().getX(),choice.element().getValue().getY(),position,choice.element().getValue().getArrow());
			}
			
			while(iteratorC.hasNext())
			{		
				Position<Vertex<Choice>> c = iteratorC.next();
				addEdge(c.element().getValue().getX(),c.element().getValue().getY(),position.element().getValue().getX(),position.element().getValue().getY(),c,position.element().getValue().getArrow());
			}
			
				displayEdge(tree, position);
			
		}
		
	}

	static boolean searchResult;
	private static void searchParentVisited(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice, int id) throws Exception 
	{
		if(searchResult)
		{
			return;
		}
		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);
		//checks if root
		/*if(tree.parent(choice).get(0) == null)
		{
			//checks if root is search id
			if(id == root.element().id)
			{
				searchResult = true;
				return;
			}
		}*/
		
		while(iterator.hasNext())
		{
			if(searchResult)
			{
				return;
			}
			
			if(id == root.element().getValue().getID())
			{
				searchResult = true;
				return;
			}

			Position<Vertex<Choice>> position = iterator.next();
			
			//checks if correct node is found
			
			
			
			if(id == position.element().getValue().getID())
			{
				

				//checks if parent node has been visited before

				for(Position<Vertex<Choice>> c : tree.parent(position))
				{
					//searchResult = c.element().getVisited();

					if(c.element().getValue().getVisited())
					{
						searchResult = true;
						return;
					}
				}
				
			}
			
			searchParentVisited(tree, position, id);	
		}	
	}
	
	static boolean searchChildResult;
	private static void searchFellowChildVisited(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice, int id) throws Exception 
	{

		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);
		//checks if root
		if(tree.parent(choice).get(0) == null)
		{
			//checks if root is search id
			if(id == root.element().getValue().getID())
			{
				//System.out.println("root found");
				searchChildResult = true;
				return;
			}
		}
		
		while(iterator.hasNext())
		{
			
			Position<Vertex<Choice>> position = iterator.next();
			//checks if correct node is found
			if(id == position.element().getValue().getID())
			{

				//goes over all children of that paren
				Iterator<Position<Vertex<Choice>>> iteratorChild = tree.children(tree.parent(position).get(0));
				
				while(iteratorChild.hasNext())
				{
					
					Position<Vertex<Choice>> positionChild = iteratorChild.next();
					//System.out.println(positionChild.element().getID() + "  "+ positionChild.element().getVisited());
					//if child visited, return false
					if(positionChild.element().getValue().getVisited())
					{
						searchChildResult = false;
						return;
					}
				}
					

				
			}
			
			searchFellowChildVisited(tree, position, id);	
		}	
		//System.out.println("failure");
		
	}

	
	private static void printChoices()
	{
		for(Position<Vertex<Choice>> p : vertexPath)
		{
			
			System.out.println(p.element().getValue().toString() + "\n");
		}
	}
	
	private static void shortestPath(Position<Vertex<Choice>> lastPosition) throws Exception
	{
		

		Iterator<Position<Vertex<Choice>>> iterator = tree.children(lastPosition);
		
		while(childPosition.hasNext())
		{
			Vertex<Choice>>> childPosition
		}
		if(!vertexPath.isEmpty())
		{
			
			Position<Vertex<Choice>> lastVertex = vertexPath.get(vertexPath.size()-1);
			
		}

	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-04-19 12:54:17.713
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-04-19 12:54:17.714
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-19 12:54:17.750
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------


import java.util.ArrayList;
import java.util.Iterator;

import com.jwetherell.algorithms.data_structures.Graph;
import com.jwetherell.algorithms.data_structures.Graph.Vertex;

import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.TextArea;
import javafx.scene.input.MouseDragEvent;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.Pane;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Line;
import javafx.scene.shape.Polygon;
import javafx.scene.shape.Shape;
import javafx.stage.Stage;
import javafx.stage.StageStyle;

public class GraphPane extends StackPane
{
	static Pane pane;
	static int total;
	static TextArea txtTotal;
	static TextArea txtDisplay;
	static GridPane gridPane;
	static GraphPane graphPane;
	static Tree<Vertex<Choice>> tree;
	static Position<Vertex<Choice>> root;
	static ScrollPane scrollPane;
	
	static ArrayList<Position<Vertex<Choice>>> vertexPath = new ArrayList<Position<Vertex<Choice>>>();
	static ArrayList<Button> choicePath = new ArrayList<Button>();
	static int choiceNumber = -1;
	
	public GraphPane()
	{
		
		graphPane = this;
		gridPane = new GridPane();
		//setting vbox/controls
		VBox vbox = new VBox();
		vbox.setMaxSize(800, 800);
		//setting pane/graph
		pane = new Pane();
		pane.setPrefSize(2000, 2000);
		
		//scrollpane
		scrollPane = new ScrollPane();
		scrollPane.setContent(pane);
		scrollPane.setPrefSize(600, 600);
		//adding both to main borderpane for layout



		
		//adding controls to vbox
		Label lblTotal = new Label("Total:");
		txtTotal = new TextArea();
		txtTotal.setPrefSize(getPrefWidth(), 20);
		
		Label lblDisplay = new Label("Display:");
		txtDisplay = new TextArea();
		txtDisplay.setPrefSize(getPrefWidth(), 20);
		
		//add buttons
		
		Button btnGoBack = new Button("Go Back One Choice");
		btnGoBack.setPrefSize(200, 30);
		
		Button btnDisplayChoices = new Button("Display Current Choices Info");
		btnDisplayChoices.setPrefSize(200, 30);


		
		gridPane.add(lblTotal, 0, 0);
		gridPane.add(txtTotal, 0, 1);
		gridPane.add(lblDisplay, 0, 2);
		gridPane.add(txtDisplay, 0, 3);
		gridPane.add(btnGoBack, 0, 4);
		gridPane.add(btnDisplayChoices, 1, 4);
		
		vbox.getChildren().add(gridPane);
		vbox.getChildren().add(scrollPane);
		
		this.getChildren().add(vbox);
		
		//generate tree and fill it
		ModifyTree modifyTree = new ModifyTree();
		
		tree = modifyTree.getTree();
		root = modifyTree.getRoot();
		
		try 
		{
			displayNodes(tree, root);
			displayEdge(tree, root);
			//System.out.println(tree.preOrderElementTraversal(tree, root));
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		//set buttons actipns
		
		btnGoBack.setOnAction(new EventHandler <ActionEvent>()
		{
			@Override
			public void handle(ActionEvent event) 
			{
				goBack();
			}		
		});
		
		btnDisplayChoices.setOnAction(new EventHandler <ActionEvent>()
		{
			@Override
			public void handle(ActionEvent event) 
			{
				//shortestPath();
				printChoices();
			}		
		});
		

		////
		
	}
	
	public static void goBack()
	{
		
		//if choice exists
		if(choiceNumber > -1)
		{
			//go back one on button
			Button button = choicePath.get(choiceNumber);
			button.setTextFill(null);
			button.setStyle("-fx-background-color: BLACK");
			System.out.println(button.getText());
			//go back on 
			Position<Vertex<Choice>> vertex = vertexPath.get(choiceNumber);
			vertex.element().getValue().setDisplayed(false);
			vertex.element().getValue().setVisited(false);
			
			//now get rid of button and vertex from list
			vertexPath.remove(choiceNumber);
			choicePath.remove(choiceNumber);
			
			total -= vertex.element().getWeight();
			txtTotal.setText("R"+total);
			choiceNumber--;
			
			
		}else
		{
			graphPane.setVisible(false);
			//go to error pane
			ErrorPane root = new ErrorPane("ERROR: There is no node selected to undo.", graphPane);
			Stage secondStage = new Stage();
			
			//secondStage.initStyle(StageStyle.UNDECORATED);
	        secondStage.setScene(new Scene(root));
	        secondStage.setTitle("Error");
	        secondStage.show();
	        return;
		}

	}
	
	public void addToPath(Position<Vertex<Choice>> elem,Button button)
	{
		vertexPath.add(elem);
		choicePath.add(button);
		choiceNumber++;
		
		total += elem.element().getWeight();
		txtTotal.setText("R"+total);
	}
	
	final static int nodeSize = 50;
	final static int edgeSize = 50;
	public static void addNode(int x, int y, Position<Vertex<Choice>> elem)
	{
		
		Button button = new Button(""+elem.element().getValue().getID());
		button.setShape(new Circle(10));
		button.setPrefSize(nodeSize,nodeSize);
		button.setLayoutX(x);
		button.setLayoutY(y);
		button.setTextFill(null);
		button.setStyle("-fx-background-color: BLACK");
		
		Label lblName = new Label(elem.element().getValue().getName());
		lblName.setLayoutX(x);
		lblName.setLayoutY(y-15);
		
		pane.getChildren().add(lblName);
		pane.getChildren().add(button);
		

		button.setOnAction(new EventHandler <ActionEvent>()
		{
			
			@Override
			public void handle(ActionEvent event) 
			{
				//total += elem;
				txtTotal.setText(""+total);
				graphPane.setVisible(false);
				
				//this is to search if parent has been visisted
				searchResult = false;
				//this is to search if a fellow child has been visited
				searchChildResult = true;
				try 
				{
					searchParentVisited(tree,  root, Integer.parseInt(button.getText()));
					searchFellowChildVisited(tree,  root, Integer.parseInt(button.getText()));
	
				} catch (Exception e) 
				{
					e.printStackTrace();
				}
				
				
				//if parent not visited yet
				if(!searchResult)
				{
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: Parent of Choice not selected yet.", graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
			        return;
					
				}else
				if(!searchChildResult)//now check if a fellow child has already been chosen
				{
								
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: You cannot choose more than one choice at the same depth", graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
			        return;
					
					
				}else
				if(button.getTextFill() == null)//if button viable
				{
					//opens main menu
					InfoPane root = new InfoPane(elem, button, graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Info");
			        secondStage.show();
					
				}else
				if(button.getTextFill().equals(Color.BLUE))//if buttons already been selected
				{
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: This option has already been selected.", graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
				}else
				{

					
				}
			}			
		});
	}
	
	public static void addEdge(int xP, int yP,int x, int y, Position<Vertex<Choice>> choice, int arrowPlacement)
	{	

		int posChange = 30;
		int midpointX = (xP+x+2*posChange)/2;
		int midpointY = (yP+y+2*posChange)/2;
		//System.out.println(xP +"-"+yP+"-"+x+"-"+y);
		//create line/edge from start to end
		Line line = new Line(xP+posChange, yP+posChange, x+posChange, y+posChange);
		Label lblWeight = new Label(""+choice.element().getWeight());
		lblWeight.setLayoutX(midpointX);
		lblWeight.setLayoutY(midpointY);
		
		//create directional arrow on line
		//Line arrowUp = new Line(x+15, y+25, x+30, y+30);
		//Line arrowDown = new Line(x+25, y+15, x+30, y+30);
		

		//if(xP != x && yP != y)
		{
			if(arrowPlacement > choice.element().getValue().getArrow())//upper bound
			{
				Polygon polygon = new Polygon();
		        polygon.getPoints().addAll(new Double[]{
		        		(double) (midpointX-15),(double) midpointY+10,
		        		(double) midpointX,(double) midpointY+15,
		        		(double) midpointX, (double) midpointY,
		        });

				pane.getChildren().add(polygon);

	
			}else
			if(arrowPlacement == choice.element().getValue().getArrow())//middle bound
			{

				Polygon polygon = new Polygon();
		        polygon.getPoints().addAll(new Double[]{
		        		(double) (midpointX-20),(double) midpointY-10,
		        		(double) midpointX,(double) midpointY,
		        		(double) midpointX-20, (double) midpointY+10,
		        });

				pane.getChildren().add(polygon);
				
			}else
			if(arrowPlacement < choice.element().getValue().getArrow())//lower bound
			{
				
				Polygon polygon = new Polygon();
		        polygon.getPoints().addAll(new Double[]{
		        		(double) (midpointX),(double) midpointY-20,
		        		(double) midpointX,(double) midpointY,
		        		(double) midpointX-20, (double) midpointY-10,
		        });

				pane.getChildren().add(polygon);
			}
		}
		//add line to pane
		//pane.getChildren().add(arrowUp);
		//pane.getChildren().add(arrowDown);
		pane.getChildren().add(line);
		pane.getChildren().add(lblWeight);
	}
	

	static int loop = 0;
	static int iteration = 1;
	static boolean endFound = false;

	private static void displayNodes(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice) throws Exception 
	{
		
		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);

		if(tree.parent(choice).get(0) == null)
		{
			choice.element().getValue().setX(0);
			choice.element().getValue().setY((int)scrollPane.getPrefHeight()/2);
			choice.element().getValue().setArrow(0);
			
			addNode(0, choice.element().getValue().getY(), choice);
		}
		
		while(iterator.hasNext())
		{
			//counts at which child you are currently at
			loop++;
			
			if(loop==3)
			{
				loop = 1;
			}
			
			Position<Vertex<Choice>> position = iterator.next();
			
			if(position.element().getValue().getDisplayed())
			{
				//System.out.println(position.toString() +"    ddddddd");
			}	
			else
			{
			
			//get depth which is the x axis
			int depth = tree.depth(tree, position);
			
			//calcuate y
			double numChild = tree.getNumChildren(tree.parent(position).get(0));


			
			int parentChoice = 0;
			//determines how a child of one parents should look

			if(tree.parent(position).size() == 1)
			{
				parentChoice = 0;
			}else
			if(tree.parent(position).size() % 2 == 0)//determines how a child of many parents should look - if even
			{
					parentChoice = tree.getNumChildren(tree.parent(position).get(0))/2;
					
				}else//determines how a child of many parents should look - if odd
				{
					
					parentChoice = (int)(tree.getNumChildren(tree.parent(position).get(0))/2+0.5);
					
				}
				
				//this is the # in order ofwhen the child was added to a parent
				int childNum = position.element().getValue().getChildNum();
				if(numChild <= 1)
				{
					
					position.element().getValue().setY(root.element().getValue().getY());
					position.element().getValue().setArrow(0);
				}
				else
				if(numChild/2 >= childNum || childNum==1)//in lower bound of loop
				{
					
					//set above parent
					position.element().getValue().setY(tree.parent(position).get(0).element().getValue().getY()-200/childNum);
					position.element().getValue().setArrow(-1);
					
				}else
				if(numChild/2 == childNum || numChild/2 == childNum-0.5)//at centre of loop
				{
	
					//set same as parent Y axis
					position.element().getValue().setY(tree.parent(position).get(0).element().getValue().getY());
					position.element().getValue().setArrow(0);
	
				}else
				{
					if((numChild+1-childNum) <= 0)
					{
						//set below parent
						position.element().getValue().setY((int)(tree.parent(position).get(0).element().getValue().getY()+200/(-numChild+1+childNum)));
						position.element().getValue().setArrow(1);
					}else
					{
						//set below parent
						position.element().getValue().setY((int)(tree.parent(position).get(0).element().getValue().getY()+200/(numChild+1-childNum)));
						position.element().getValue().setArrow(1);
					}
					
					
				}
						
	
				/*if(position.element().getValue().getID() == 7)
				{
					System.out.println("numPdasdasasdsad "+ tree.parent(position).size());
				}*/
				
				position.element().getValue().setX(depth*100);
				if(position.element().getValue().getY() > 1000)
				{
					System.out.println("\nID " + position.element().getValue().getID()+"   X: "+ position.element().getValue().getX()+"   Y: "+position.element().getValue().getY());
					System.out.println("loop " + loop+"   numChild: "+numChild+"\n");
				}
				
				
				//add nodes
				addNode(position.element().getValue().getX(), position.element().getValue().getY(),position);
				position.element().getValue().setDisplayed(true);
				//add all edges - can have many parents
				/*
				if(tree.getNumChildren(position) == 0)
				{
					loop = 0;
					endFound = true;
					iteration++;
				}*/
			}
			

			
			displayNodes(tree, position);
			
		}
		
	}
	
	
	
	private static void displayEdge(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice) throws Exception 
	{
		
		
		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);
		
		while(iterator.hasNext())
		{	
			Position<Vertex<Choice>> position = iterator.next();
			
			Iterator<Position<Vertex<Choice>>> iteratorC = tree.children(position);
			//to add root
			if(tree.parent(choice).get(0) == null)
			{

				addEdge(position.element().getValue().getX(),position.element().getValue().getY(),choice.element().getValue().getX(),choice.element().getValue().getY(),position,choice.element().getValue().getArrow());
			}
			
			while(iteratorC.hasNext())
			{		
				Position<Vertex<Choice>> c = iteratorC.next();
				addEdge(c.element().getValue().getX(),c.element().getValue().getY(),position.element().getValue().getX(),position.element().getValue().getY(),c,position.element().getValue().getArrow());
			}
			
				displayEdge(tree, position);
			
		}
		
	}

	static boolean searchResult;
	private static void searchParentVisited(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice, int id) throws Exception 
	{
		if(searchResult)
		{
			return;
		}
		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);
		//checks if root
		/*if(tree.parent(choice).get(0) == null)
		{
			//checks if root is search id
			if(id == root.element().id)
			{
				searchResult = true;
				return;
			}
		}*/
		
		while(iterator.hasNext())
		{
			if(searchResult)
			{
				return;
			}
			
			if(id == root.element().getValue().getID())
			{
				searchResult = true;
				return;
			}

			Position<Vertex<Choice>> position = iterator.next();
			
			//checks if correct node is found
			
			
			
			if(id == position.element().getValue().getID())
			{
				

				//checks if parent node has been visited before

				for(Position<Vertex<Choice>> c : tree.parent(position))
				{
					//searchResult = c.element().getVisited();

					if(c.element().getValue().getVisited())
					{
						searchResult = true;
						return;
					}
				}
				
			}
			
			searchParentVisited(tree, position, id);	
		}	
	}
	
	static boolean searchChildResult;
	private static void searchFellowChildVisited(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice, int id) throws Exception 
	{

		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);
		//checks if root
		if(tree.parent(choice).get(0) == null)
		{
			//checks if root is search id
			if(id == root.element().getValue().getID())
			{
				//System.out.println("root found");
				searchChildResult = true;
				return;
			}
		}
		
		while(iterator.hasNext())
		{
			
			Position<Vertex<Choice>> position = iterator.next();
			//checks if correct node is found
			if(id == position.element().getValue().getID())
			{

				//goes over all children of that paren
				Iterator<Position<Vertex<Choice>>> iteratorChild = tree.children(tree.parent(position).get(0));
				
				while(iteratorChild.hasNext())
				{
					
					Position<Vertex<Choice>> positionChild = iteratorChild.next();
					//System.out.println(positionChild.element().getID() + "  "+ positionChild.element().getVisited());
					//if child visited, return false
					if(positionChild.element().getValue().getVisited())
					{
						searchChildResult = false;
						return;
					}
				}
					

				
			}
			
			searchFellowChildVisited(tree, position, id);	
		}	
		//System.out.println("failure");
		
	}

	
	private static void printChoices()
	{
		for(Position<Vertex<Choice>> p : vertexPath)
		{
			
			System.out.println(p.element().getValue().toString() + "\n");
		}
	}
	
	private static void shortestPath(Position<Vertex<Choice>> lastPosition) throws Exception
	{
		

		Iterator<Position<Vertex<Choice>>> iterator = tree.children(lastPosition);
		
		while(childPosition.hasNext())
		{
			Vertex<Choice>>> childPosition
		}
		if(!vertexPath.isEmpty())
		{
			
			Position<Vertex<Choice>> lastVertex = vertexPath.get(vertexPath.size()-1);
			
		}

	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-19 12:54:17.751
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-19 12:54:17.753
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-19 12:54:19.237
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------


import java.util.ArrayList;
import java.util.Iterator;

import com.jwetherell.algorithms.data_structures.Graph;
import com.jwetherell.algorithms.data_structures.Graph.Vertex;

import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.TextArea;
import javafx.scene.input.MouseDragEvent;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.Pane;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Line;
import javafx.scene.shape.Polygon;
import javafx.scene.shape.Shape;
import javafx.stage.Stage;
import javafx.stage.StageStyle;

public class GraphPane extends StackPane
{
	static Pane pane;
	static int total;
	static TextArea txtTotal;
	static TextArea txtDisplay;
	static GridPane gridPane;
	static GraphPane graphPane;
	static Tree<Vertex<Choice>> tree;
	static Position<Vertex<Choice>> root;
	static ScrollPane scrollPane;
	
	static ArrayList<Position<Vertex<Choice>>> vertexPath = new ArrayList<Position<Vertex<Choice>>>();
	static ArrayList<Button> choicePath = new ArrayList<Button>();
	static int choiceNumber = -1;
	
	public GraphPane()
	{
		
		graphPane = this;
		gridPane = new GridPane();
		//setting vbox/controls
		VBox vbox = new VBox();
		vbox.setMaxSize(800, 800);
		//setting pane/graph
		pane = new Pane();
		pane.setPrefSize(2000, 2000);
		
		//scrollpane
		scrollPane = new ScrollPane();
		scrollPane.setContent(pane);
		scrollPane.setPrefSize(600, 600);
		//adding both to main borderpane for layout



		
		//adding controls to vbox
		Label lblTotal = new Label("Total:");
		txtTotal = new TextArea();
		txtTotal.setPrefSize(getPrefWidth(), 20);
		
		Label lblDisplay = new Label("Display:");
		txtDisplay = new TextArea();
		txtDisplay.setPrefSize(getPrefWidth(), 20);
		
		//add buttons
		
		Button btnGoBack = new Button("Go Back One Choice");
		btnGoBack.setPrefSize(200, 30);
		
		Button btnDisplayChoices = new Button("Display Current Choices Info");
		btnDisplayChoices.setPrefSize(200, 30);


		
		gridPane.add(lblTotal, 0, 0);
		gridPane.add(txtTotal, 0, 1);
		gridPane.add(lblDisplay, 0, 2);
		gridPane.add(txtDisplay, 0, 3);
		gridPane.add(btnGoBack, 0, 4);
		gridPane.add(btnDisplayChoices, 1, 4);
		
		vbox.getChildren().add(gridPane);
		vbox.getChildren().add(scrollPane);
		
		this.getChildren().add(vbox);
		
		//generate tree and fill it
		ModifyTree modifyTree = new ModifyTree();
		
		tree = modifyTree.getTree();
		root = modifyTree.getRoot();
		
		try 
		{
			displayNodes(tree, root);
			displayEdge(tree, root);
			//System.out.println(tree.preOrderElementTraversal(tree, root));
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		//set buttons actipns
		
		btnGoBack.setOnAction(new EventHandler <ActionEvent>()
		{
			@Override
			public void handle(ActionEvent event) 
			{
				goBack();
			}		
		});
		
		btnDisplayChoices.setOnAction(new EventHandler <ActionEvent>()
		{
			@Override
			public void handle(ActionEvent event) 
			{
				//shortestPath();
				printChoices();
			}		
		});
		

		////
		
	}
	
	public static void goBack()
	{
		
		//if choice exists
		if(choiceNumber > -1)
		{
			//go back one on button
			Button button = choicePath.get(choiceNumber);
			button.setTextFill(null);
			button.setStyle("-fx-background-color: BLACK");
			System.out.println(button.getText());
			//go back on 
			Position<Vertex<Choice>> vertex = vertexPath.get(choiceNumber);
			vertex.element().getValue().setDisplayed(false);
			vertex.element().getValue().setVisited(false);
			
			//now get rid of button and vertex from list
			vertexPath.remove(choiceNumber);
			choicePath.remove(choiceNumber);
			
			total -= vertex.element().getWeight();
			txtTotal.setText("R"+total);
			choiceNumber--;
			
			
		}else
		{
			graphPane.setVisible(false);
			//go to error pane
			ErrorPane root = new ErrorPane("ERROR: There is no node selected to undo.", graphPane);
			Stage secondStage = new Stage();
			
			//secondStage.initStyle(StageStyle.UNDECORATED);
	        secondStage.setScene(new Scene(root));
	        secondStage.setTitle("Error");
	        secondStage.show();
	        return;
		}

	}
	
	public void addToPath(Position<Vertex<Choice>> elem,Button button)
	{
		vertexPath.add(elem);
		choicePath.add(button);
		choiceNumber++;
		
		total += elem.element().getWeight();
		txtTotal.setText("R"+total);
	}
	
	final static int nodeSize = 50;
	final static int edgeSize = 50;
	public static void addNode(int x, int y, Position<Vertex<Choice>> elem)
	{
		
		Button button = new Button(""+elem.element().getValue().getID());
		button.setShape(new Circle(10));
		button.setPrefSize(nodeSize,nodeSize);
		button.setLayoutX(x);
		button.setLayoutY(y);
		button.setTextFill(null);
		button.setStyle("-fx-background-color: BLACK");
		
		Label lblName = new Label(elem.element().getValue().getName());
		lblName.setLayoutX(x);
		lblName.setLayoutY(y-15);
		
		pane.getChildren().add(lblName);
		pane.getChildren().add(button);
		

		button.setOnAction(new EventHandler <ActionEvent>()
		{
			
			@Override
			public void handle(ActionEvent event) 
			{
				//total += elem;
				txtTotal.setText(""+total);
				graphPane.setVisible(false);
				
				//this is to search if parent has been visisted
				searchResult = false;
				//this is to search if a fellow child has been visited
				searchChildResult = true;
				try 
				{
					searchParentVisited(tree,  root, Integer.parseInt(button.getText()));
					searchFellowChildVisited(tree,  root, Integer.parseInt(button.getText()));
	
				} catch (Exception e) 
				{
					e.printStackTrace();
				}
				
				
				//if parent not visited yet
				if(!searchResult)
				{
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: Parent of Choice not selected yet.", graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
			        return;
					
				}else
				if(!searchChildResult)//now check if a fellow child has already been chosen
				{
								
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: You cannot choose more than one choice at the same depth", graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
			        return;
					
					
				}else
				if(button.getTextFill() == null)//if button viable
				{
					//opens main menu
					InfoPane root = new InfoPane(elem, button, graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Info");
			        secondStage.show();
					
				}else
				if(button.getTextFill().equals(Color.BLUE))//if buttons already been selected
				{
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: This option has already been selected.", graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
				}else
				{

					
				}
			}			
		});
	}
	
	public static void addEdge(int xP, int yP,int x, int y, Position<Vertex<Choice>> choice, int arrowPlacement)
	{	

		int posChange = 30;
		int midpointX = (xP+x+2*posChange)/2;
		int midpointY = (yP+y+2*posChange)/2;
		//System.out.println(xP +"-"+yP+"-"+x+"-"+y);
		//create line/edge from start to end
		Line line = new Line(xP+posChange, yP+posChange, x+posChange, y+posChange);
		Label lblWeight = new Label(""+choice.element().getWeight());
		lblWeight.setLayoutX(midpointX);
		lblWeight.setLayoutY(midpointY);
		
		//create directional arrow on line
		//Line arrowUp = new Line(x+15, y+25, x+30, y+30);
		//Line arrowDown = new Line(x+25, y+15, x+30, y+30);
		

		//if(xP != x && yP != y)
		{
			if(arrowPlacement > choice.element().getValue().getArrow())//upper bound
			{
				Polygon polygon = new Polygon();
		        polygon.getPoints().addAll(new Double[]{
		        		(double) (midpointX-15),(double) midpointY+10,
		        		(double) midpointX,(double) midpointY+15,
		        		(double) midpointX, (double) midpointY,
		        });

				pane.getChildren().add(polygon);

	
			}else
			if(arrowPlacement == choice.element().getValue().getArrow())//middle bound
			{

				Polygon polygon = new Polygon();
		        polygon.getPoints().addAll(new Double[]{
		        		(double) (midpointX-20),(double) midpointY-10,
		        		(double) midpointX,(double) midpointY,
		        		(double) midpointX-20, (double) midpointY+10,
		        });

				pane.getChildren().add(polygon);
				
			}else
			if(arrowPlacement < choice.element().getValue().getArrow())//lower bound
			{
				
				Polygon polygon = new Polygon();
		        polygon.getPoints().addAll(new Double[]{
		        		(double) (midpointX),(double) midpointY-20,
		        		(double) midpointX,(double) midpointY,
		        		(double) midpointX-20, (double) midpointY-10,
		        });

				pane.getChildren().add(polygon);
			}
		}
		//add line to pane
		//pane.getChildren().add(arrowUp);
		//pane.getChildren().add(arrowDown);
		pane.getChildren().add(line);
		pane.getChildren().add(lblWeight);
	}
	

	static int loop = 0;
	static int iteration = 1;
	static boolean endFound = false;

	private static void displayNodes(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice) throws Exception 
	{
		
		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);

		if(tree.parent(choice).get(0) == null)
		{
			choice.element().getValue().setX(0);
			choice.element().getValue().setY((int)scrollPane.getPrefHeight()/2);
			choice.element().getValue().setArrow(0);
			
			addNode(0, choice.element().getValue().getY(), choice);
		}
		
		while(iterator.hasNext())
		{
			//counts at which child you are currently at
			loop++;
			
			if(loop==3)
			{
				loop = 1;
			}
			
			Position<Vertex<Choice>> position = iterator.next();
			
			if(position.element().getValue().getDisplayed())
			{
				//System.out.println(position.toString() +"    ddddddd");
			}	
			else
			{
			
			//get depth which is the x axis
			int depth = tree.depth(tree, position);
			
			//calcuate y
			double numChild = tree.getNumChildren(tree.parent(position).get(0));


			
			int parentChoice = 0;
			//determines how a child of one parents should look

			if(tree.parent(position).size() == 1)
			{
				parentChoice = 0;
			}else
			if(tree.parent(position).size() % 2 == 0)//determines how a child of many parents should look - if even
			{
					parentChoice = tree.getNumChildren(tree.parent(position).get(0))/2;
					
				}else//determines how a child of many parents should look - if odd
				{
					
					parentChoice = (int)(tree.getNumChildren(tree.parent(position).get(0))/2+0.5);
					
				}
				
				//this is the # in order ofwhen the child was added to a parent
				int childNum = position.element().getValue().getChildNum();
				if(numChild <= 1)
				{
					
					position.element().getValue().setY(root.element().getValue().getY());
					position.element().getValue().setArrow(0);
				}
				else
				if(numChild/2 >= childNum || childNum==1)//in lower bound of loop
				{
					
					//set above parent
					position.element().getValue().setY(tree.parent(position).get(0).element().getValue().getY()-200/childNum);
					position.element().getValue().setArrow(-1);
					
				}else
				if(numChild/2 == childNum || numChild/2 == childNum-0.5)//at centre of loop
				{
	
					//set same as parent Y axis
					position.element().getValue().setY(tree.parent(position).get(0).element().getValue().getY());
					position.element().getValue().setArrow(0);
	
				}else
				{
					if((numChild+1-childNum) <= 0)
					{
						//set below parent
						position.element().getValue().setY((int)(tree.parent(position).get(0).element().getValue().getY()+200/(-numChild+1+childNum)));
						position.element().getValue().setArrow(1);
					}else
					{
						//set below parent
						position.element().getValue().setY((int)(tree.parent(position).get(0).element().getValue().getY()+200/(numChild+1-childNum)));
						position.element().getValue().setArrow(1);
					}
					
					
				}
						
	
				/*if(position.element().getValue().getID() == 7)
				{
					System.out.println("numPdasdasasdsad "+ tree.parent(position).size());
				}*/
				
				position.element().getValue().setX(depth*100);
				if(position.element().getValue().getY() > 1000)
				{
					System.out.println("\nID " + position.element().getValue().getID()+"   X: "+ position.element().getValue().getX()+"   Y: "+position.element().getValue().getY());
					System.out.println("loop " + loop+"   numChild: "+numChild+"\n");
				}
				
				
				//add nodes
				addNode(position.element().getValue().getX(), position.element().getValue().getY(),position);
				position.element().getValue().setDisplayed(true);
				//add all edges - can have many parents
				/*
				if(tree.getNumChildren(position) == 0)
				{
					loop = 0;
					endFound = true;
					iteration++;
				}*/
			}
			

			
			displayNodes(tree, position);
			
		}
		
	}
	
	
	
	private static void displayEdge(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice) throws Exception 
	{
		
		
		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);
		
		while(iterator.hasNext())
		{	
			Position<Vertex<Choice>> position = iterator.next();
			
			Iterator<Position<Vertex<Choice>>> iteratorC = tree.children(position);
			//to add root
			if(tree.parent(choice).get(0) == null)
			{

				addEdge(position.element().getValue().getX(),position.element().getValue().getY(),choice.element().getValue().getX(),choice.element().getValue().getY(),position,choice.element().getValue().getArrow());
			}
			
			while(iteratorC.hasNext())
			{		
				Position<Vertex<Choice>> c = iteratorC.next();
				addEdge(c.element().getValue().getX(),c.element().getValue().getY(),position.element().getValue().getX(),position.element().getValue().getY(),c,position.element().getValue().getArrow());
			}
			
				displayEdge(tree, position);
			
		}
		
	}

	static boolean searchResult;
	private static void searchParentVisited(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice, int id) throws Exception 
	{
		if(searchResult)
		{
			return;
		}
		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);
		//checks if root
		/*if(tree.parent(choice).get(0) == null)
		{
			//checks if root is search id
			if(id == root.element().id)
			{
				searchResult = true;
				return;
			}
		}*/
		
		while(iterator.hasNext())
		{
			if(searchResult)
			{
				return;
			}
			
			if(id == root.element().getValue().getID())
			{
				searchResult = true;
				return;
			}

			Position<Vertex<Choice>> position = iterator.next();
			
			//checks if correct node is found
			
			
			
			if(id == position.element().getValue().getID())
			{
				

				//checks if parent node has been visited before

				for(Position<Vertex<Choice>> c : tree.parent(position))
				{
					//searchResult = c.element().getVisited();

					if(c.element().getValue().getVisited())
					{
						searchResult = true;
						return;
					}
				}
				
			}
			
			searchParentVisited(tree, position, id);	
		}	
	}
	
	static boolean searchChildResult;
	private static void searchFellowChildVisited(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice, int id) throws Exception 
	{

		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);
		//checks if root
		if(tree.parent(choice).get(0) == null)
		{
			//checks if root is search id
			if(id == root.element().getValue().getID())
			{
				//System.out.println("root found");
				searchChildResult = true;
				return;
			}
		}
		
		while(iterator.hasNext())
		{
			
			Position<Vertex<Choice>> position = iterator.next();
			//checks if correct node is found
			if(id == position.element().getValue().getID())
			{

				//goes over all children of that paren
				Iterator<Position<Vertex<Choice>>> iteratorChild = tree.children(tree.parent(position).get(0));
				
				while(iteratorChild.hasNext())
				{
					
					Position<Vertex<Choice>> positionChild = iteratorChild.next();
					//System.out.println(positionChild.element().getID() + "  "+ positionChild.element().getVisited());
					//if child visited, return false
					if(positionChild.element().getValue().getVisited())
					{
						searchChildResult = false;
						return;
					}
				}
					

				
			}
			
			searchFellowChildVisited(tree, position, id);	
		}	
		//System.out.println("failure");
		
	}

	
	private static void printChoices()
	{
		for(Position<Vertex<Choice>> p : vertexPath)
		{
			
			System.out.println(p.element().getValue().toString() + "\n");
		}
	}
	
	private static void shortestPath(Position<Vertex<Choice>> lastPosition) throws Exception
	{
		

		Iterator<Position<Vertex<Choice>>> iterator = tree.children(lastPosition);
		
		while(childPosition.hasNext())
		{
			Vertex<Choice>>> childPosition
		}
		if(!vertexPath.isEmpty())
		{
			
			Position<Vertex<Choice>> lastVertex = vertexPath.get(vertexPath.size()-1);
			
		}

	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-19 12:54:19.239
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-19 12:54:19.239
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-19 12:54:21.058
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------


import java.util.ArrayList;
import java.util.Iterator;

import com.jwetherell.algorithms.data_structures.Graph;
import com.jwetherell.algorithms.data_structures.Graph.Vertex;

import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.TextArea;
import javafx.scene.input.MouseDragEvent;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.Pane;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Line;
import javafx.scene.shape.Polygon;
import javafx.scene.shape.Shape;
import javafx.stage.Stage;
import javafx.stage.StageStyle;

public class GraphPane extends StackPane
{
	static Pane pane;
	static int total;
	static TextArea txtTotal;
	static TextArea txtDisplay;
	static GridPane gridPane;
	static GraphPane graphPane;
	static Tree<Vertex<Choice>> tree;
	static Position<Vertex<Choice>> root;
	static ScrollPane scrollPane;
	
	static ArrayList<Position<Vertex<Choice>>> vertexPath = new ArrayList<Position<Vertex<Choice>>>();
	static ArrayList<Button> choicePath = new ArrayList<Button>();
	static int choiceNumber = -1;
	
	public GraphPane()
	{
		
		graphPane = this;
		gridPane = new GridPane();
		//setting vbox/controls
		VBox vbox = new VBox();
		vbox.setMaxSize(800, 800);
		//setting pane/graph
		pane = new Pane();
		pane.setPrefSize(2000, 2000);
		
		//scrollpane
		scrollPane = new ScrollPane();
		scrollPane.setContent(pane);
		scrollPane.setPrefSize(600, 600);
		//adding both to main borderpane for layout



		
		//adding controls to vbox
		Label lblTotal = new Label("Total:");
		txtTotal = new TextArea();
		txtTotal.setPrefSize(getPrefWidth(), 20);
		
		Label lblDisplay = new Label("Display:");
		txtDisplay = new TextArea();
		txtDisplay.setPrefSize(getPrefWidth(), 20);
		
		//add buttons
		
		Button btnGoBack = new Button("Go Back One Choice");
		btnGoBack.setPrefSize(200, 30);
		
		Button btnDisplayChoices = new Button("Display Current Choices Info");
		btnDisplayChoices.setPrefSize(200, 30);


		
		gridPane.add(lblTotal, 0, 0);
		gridPane.add(txtTotal, 0, 1);
		gridPane.add(lblDisplay, 0, 2);
		gridPane.add(txtDisplay, 0, 3);
		gridPane.add(btnGoBack, 0, 4);
		gridPane.add(btnDisplayChoices, 1, 4);
		
		vbox.getChildren().add(gridPane);
		vbox.getChildren().add(scrollPane);
		
		this.getChildren().add(vbox);
		
		//generate tree and fill it
		ModifyTree modifyTree = new ModifyTree();
		
		tree = modifyTree.getTree();
		root = modifyTree.getRoot();
		
		try 
		{
			displayNodes(tree, root);
			displayEdge(tree, root);
			//System.out.println(tree.preOrderElementTraversal(tree, root));
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		//set buttons actipns
		
		btnGoBack.setOnAction(new EventHandler <ActionEvent>()
		{
			@Override
			public void handle(ActionEvent event) 
			{
				goBack();
			}		
		});
		
		btnDisplayChoices.setOnAction(new EventHandler <ActionEvent>()
		{
			@Override
			public void handle(ActionEvent event) 
			{
				//shortestPath();
				printChoices();
			}		
		});
		

		////
		
	}
	
	public static void goBack()
	{
		
		//if choice exists
		if(choiceNumber > -1)
		{
			//go back one on button
			Button button = choicePath.get(choiceNumber);
			button.setTextFill(null);
			button.setStyle("-fx-background-color: BLACK");
			System.out.println(button.getText());
			//go back on 
			Position<Vertex<Choice>> vertex = vertexPath.get(choiceNumber);
			vertex.element().getValue().setDisplayed(false);
			vertex.element().getValue().setVisited(false);
			
			//now get rid of button and vertex from list
			vertexPath.remove(choiceNumber);
			choicePath.remove(choiceNumber);
			
			total -= vertex.element().getWeight();
			txtTotal.setText("R"+total);
			choiceNumber--;
			
			
		}else
		{
			graphPane.setVisible(false);
			//go to error pane
			ErrorPane root = new ErrorPane("ERROR: There is no node selected to undo.", graphPane);
			Stage secondStage = new Stage();
			
			//secondStage.initStyle(StageStyle.UNDECORATED);
	        secondStage.setScene(new Scene(root));
	        secondStage.setTitle("Error");
	        secondStage.show();
	        return;
		}

	}
	
	public void addToPath(Position<Vertex<Choice>> elem,Button button)
	{
		vertexPath.add(elem);
		choicePath.add(button);
		choiceNumber++;
		
		total += elem.element().getWeight();
		txtTotal.setText("R"+total);
	}
	
	final static int nodeSize = 50;
	final static int edgeSize = 50;
	public static void addNode(int x, int y, Position<Vertex<Choice>> elem)
	{
		
		Button button = new Button(""+elem.element().getValue().getID());
		button.setShape(new Circle(10));
		button.setPrefSize(nodeSize,nodeSize);
		button.setLayoutX(x);
		button.setLayoutY(y);
		button.setTextFill(null);
		button.setStyle("-fx-background-color: BLACK");
		
		Label lblName = new Label(elem.element().getValue().getName());
		lblName.setLayoutX(x);
		lblName.setLayoutY(y-15);
		
		pane.getChildren().add(lblName);
		pane.getChildren().add(button);
		

		button.setOnAction(new EventHandler <ActionEvent>()
		{
			
			@Override
			public void handle(ActionEvent event) 
			{
				//total += elem;
				txtTotal.setText(""+total);
				graphPane.setVisible(false);
				
				//this is to search if parent has been visisted
				searchResult = false;
				//this is to search if a fellow child has been visited
				searchChildResult = true;
				try 
				{
					searchParentVisited(tree,  root, Integer.parseInt(button.getText()));
					searchFellowChildVisited(tree,  root, Integer.parseInt(button.getText()));
	
				} catch (Exception e) 
				{
					e.printStackTrace();
				}
				
				
				//if parent not visited yet
				if(!searchResult)
				{
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: Parent of Choice not selected yet.", graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
			        return;
					
				}else
				if(!searchChildResult)//now check if a fellow child has already been chosen
				{
								
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: You cannot choose more than one choice at the same depth", graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
			        return;
					
					
				}else
				if(button.getTextFill() == null)//if button viable
				{
					//opens main menu
					InfoPane root = new InfoPane(elem, button, graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Info");
			        secondStage.show();
					
				}else
				if(button.getTextFill().equals(Color.BLUE))//if buttons already been selected
				{
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: This option has already been selected.", graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
				}else
				{

					
				}
			}			
		});
	}
	
	public static void addEdge(int xP, int yP,int x, int y, Position<Vertex<Choice>> choice, int arrowPlacement)
	{	

		int posChange = 30;
		int midpointX = (xP+x+2*posChange)/2;
		int midpointY = (yP+y+2*posChange)/2;
		//System.out.println(xP +"-"+yP+"-"+x+"-"+y);
		//create line/edge from start to end
		Line line = new Line(xP+posChange, yP+posChange, x+posChange, y+posChange);
		Label lblWeight = new Label(""+choice.element().getWeight());
		lblWeight.setLayoutX(midpointX);
		lblWeight.setLayoutY(midpointY);
		
		//create directional arrow on line
		//Line arrowUp = new Line(x+15, y+25, x+30, y+30);
		//Line arrowDown = new Line(x+25, y+15, x+30, y+30);
		

		//if(xP != x && yP != y)
		{
			if(arrowPlacement > choice.element().getValue().getArrow())//upper bound
			{
				Polygon polygon = new Polygon();
		        polygon.getPoints().addAll(new Double[]{
		        		(double) (midpointX-15),(double) midpointY+10,
		        		(double) midpointX,(double) midpointY+15,
		        		(double) midpointX, (double) midpointY,
		        });

				pane.getChildren().add(polygon);

	
			}else
			if(arrowPlacement == choice.element().getValue().getArrow())//middle bound
			{

				Polygon polygon = new Polygon();
		        polygon.getPoints().addAll(new Double[]{
		        		(double) (midpointX-20),(double) midpointY-10,
		        		(double) midpointX,(double) midpointY,
		        		(double) midpointX-20, (double) midpointY+10,
		        });

				pane.getChildren().add(polygon);
				
			}else
			if(arrowPlacement < choice.element().getValue().getArrow())//lower bound
			{
				
				Polygon polygon = new Polygon();
		        polygon.getPoints().addAll(new Double[]{
		        		(double) (midpointX),(double) midpointY-20,
		        		(double) midpointX,(double) midpointY,
		        		(double) midpointX-20, (double) midpointY-10,
		        });

				pane.getChildren().add(polygon);
			}
		}
		//add line to pane
		//pane.getChildren().add(arrowUp);
		//pane.getChildren().add(arrowDown);
		pane.getChildren().add(line);
		pane.getChildren().add(lblWeight);
	}
	

	static int loop = 0;
	static int iteration = 1;
	static boolean endFound = false;

	private static void displayNodes(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice) throws Exception 
	{
		
		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);

		if(tree.parent(choice).get(0) == null)
		{
			choice.element().getValue().setX(0);
			choice.element().getValue().setY((int)scrollPane.getPrefHeight()/2);
			choice.element().getValue().setArrow(0);
			
			addNode(0, choice.element().getValue().getY(), choice);
		}
		
		while(iterator.hasNext())
		{
			//counts at which child you are currently at
			loop++;
			
			if(loop==3)
			{
				loop = 1;
			}
			
			Position<Vertex<Choice>> position = iterator.next();
			
			if(position.element().getValue().getDisplayed())
			{
				//System.out.println(position.toString() +"    ddddddd");
			}	
			else
			{
			
			//get depth which is the x axis
			int depth = tree.depth(tree, position);
			
			//calcuate y
			double numChild = tree.getNumChildren(tree.parent(position).get(0));


			
			int parentChoice = 0;
			//determines how a child of one parents should look

			if(tree.parent(position).size() == 1)
			{
				parentChoice = 0;
			}else
			if(tree.parent(position).size() % 2 == 0)//determines how a child of many parents should look - if even
			{
					parentChoice = tree.getNumChildren(tree.parent(position).get(0))/2;
					
				}else//determines how a child of many parents should look - if odd
				{
					
					parentChoice = (int)(tree.getNumChildren(tree.parent(position).get(0))/2+0.5);
					
				}
				
				//this is the # in order ofwhen the child was added to a parent
				int childNum = position.element().getValue().getChildNum();
				if(numChild <= 1)
				{
					
					position.element().getValue().setY(root.element().getValue().getY());
					position.element().getValue().setArrow(0);
				}
				else
				if(numChild/2 >= childNum || childNum==1)//in lower bound of loop
				{
					
					//set above parent
					position.element().getValue().setY(tree.parent(position).get(0).element().getValue().getY()-200/childNum);
					position.element().getValue().setArrow(-1);
					
				}else
				if(numChild/2 == childNum || numChild/2 == childNum-0.5)//at centre of loop
				{
	
					//set same as parent Y axis
					position.element().getValue().setY(tree.parent(position).get(0).element().getValue().getY());
					position.element().getValue().setArrow(0);
	
				}else
				{
					if((numChild+1-childNum) <= 0)
					{
						//set below parent
						position.element().getValue().setY((int)(tree.parent(position).get(0).element().getValue().getY()+200/(-numChild+1+childNum)));
						position.element().getValue().setArrow(1);
					}else
					{
						//set below parent
						position.element().getValue().setY((int)(tree.parent(position).get(0).element().getValue().getY()+200/(numChild+1-childNum)));
						position.element().getValue().setArrow(1);
					}
					
					
				}
						
	
				/*if(position.element().getValue().getID() == 7)
				{
					System.out.println("numPdasdasasdsad "+ tree.parent(position).size());
				}*/
				
				position.element().getValue().setX(depth*100);
				if(position.element().getValue().getY() > 1000)
				{
					System.out.println("\nID " + position.element().getValue().getID()+"   X: "+ position.element().getValue().getX()+"   Y: "+position.element().getValue().getY());
					System.out.println("loop " + loop+"   numChild: "+numChild+"\n");
				}
				
				
				//add nodes
				addNode(position.element().getValue().getX(), position.element().getValue().getY(),position);
				position.element().getValue().setDisplayed(true);
				//add all edges - can have many parents
				/*
				if(tree.getNumChildren(position) == 0)
				{
					loop = 0;
					endFound = true;
					iteration++;
				}*/
			}
			

			
			displayNodes(tree, position);
			
		}
		
	}
	
	
	
	private static void displayEdge(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice) throws Exception 
	{
		
		
		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);
		
		while(iterator.hasNext())
		{	
			Position<Vertex<Choice>> position = iterator.next();
			
			Iterator<Position<Vertex<Choice>>> iteratorC = tree.children(position);
			//to add root
			if(tree.parent(choice).get(0) == null)
			{

				addEdge(position.element().getValue().getX(),position.element().getValue().getY(),choice.element().getValue().getX(),choice.element().getValue().getY(),position,choice.element().getValue().getArrow());
			}
			
			while(iteratorC.hasNext())
			{		
				Position<Vertex<Choice>> c = iteratorC.next();
				addEdge(c.element().getValue().getX(),c.element().getValue().getY(),position.element().getValue().getX(),position.element().getValue().getY(),c,position.element().getValue().getArrow());
			}
			
				displayEdge(tree, position);
			
		}
		
	}

	static boolean searchResult;
	private static void searchParentVisited(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice, int id) throws Exception 
	{
		if(searchResult)
		{
			return;
		}
		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);
		//checks if root
		/*if(tree.parent(choice).get(0) == null)
		{
			//checks if root is search id
			if(id == root.element().id)
			{
				searchResult = true;
				return;
			}
		}*/
		
		while(iterator.hasNext())
		{
			if(searchResult)
			{
				return;
			}
			
			if(id == root.element().getValue().getID())
			{
				searchResult = true;
				return;
			}

			Position<Vertex<Choice>> position = iterator.next();
			
			//checks if correct node is found
			
			
			
			if(id == position.element().getValue().getID())
			{
				

				//checks if parent node has been visited before

				for(Position<Vertex<Choice>> c : tree.parent(position))
				{
					//searchResult = c.element().getVisited();

					if(c.element().getValue().getVisited())
					{
						searchResult = true;
						return;
					}
				}
				
			}
			
			searchParentVisited(tree, position, id);	
		}	
	}
	
	static boolean searchChildResult;
	private static void searchFellowChildVisited(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice, int id) throws Exception 
	{

		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);
		//checks if root
		if(tree.parent(choice).get(0) == null)
		{
			//checks if root is search id
			if(id == root.element().getValue().getID())
			{
				//System.out.println("root found");
				searchChildResult = true;
				return;
			}
		}
		
		while(iterator.hasNext())
		{
			
			Position<Vertex<Choice>> position = iterator.next();
			//checks if correct node is found
			if(id == position.element().getValue().getID())
			{

				//goes over all children of that paren
				Iterator<Position<Vertex<Choice>>> iteratorChild = tree.children(tree.parent(position).get(0));
				
				while(iteratorChild.hasNext())
				{
					
					Position<Vertex<Choice>> positionChild = iteratorChild.next();
					//System.out.println(positionChild.element().getID() + "  "+ positionChild.element().getVisited());
					//if child visited, return false
					if(positionChild.element().getValue().getVisited())
					{
						searchChildResult = false;
						return;
					}
				}
					

				
			}
			
			searchFellowChildVisited(tree, position, id);	
		}	
		//System.out.println("failure");
		
	}

	
	private static void printChoices()
	{
		for(Position<Vertex<Choice>> p : vertexPath)
		{
			
			System.out.println(p.element().getValue().toString() + "\n");
		}
	}
	
	private static void shortestPath(Position<Vertex<Choice>> lastPosition) throws Exception
	{
		

		Iterator<Position<Vertex<Choice>>> iterator = tree.children(lastPosition);
		
		while(childPosition.hasNext())
		{
			Vertex<Choice>>> childPosition
		}
		if(!vertexPath.isEmpty())
		{
			
			Position<Vertex<Choice>> lastVertex = vertexPath.get(vertexPath.size()-1);
			
		}

	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-19 12:54:21.061
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-19 12:54:21.063
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-19 12:54:21.944
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------


import java.util.ArrayList;
import java.util.Iterator;

import com.jwetherell.algorithms.data_structures.Graph;
import com.jwetherell.algorithms.data_structures.Graph.Vertex;

import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.TextArea;
import javafx.scene.input.MouseDragEvent;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.Pane;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Line;
import javafx.scene.shape.Polygon;
import javafx.scene.shape.Shape;
import javafx.stage.Stage;
import javafx.stage.StageStyle;

public class GraphPane extends StackPane
{
	static Pane pane;
	static int total;
	static TextArea txtTotal;
	static TextArea txtDisplay;
	static GridPane gridPane;
	static GraphPane graphPane;
	static Tree<Vertex<Choice>> tree;
	static Position<Vertex<Choice>> root;
	static ScrollPane scrollPane;
	
	static ArrayList<Position<Vertex<Choice>>> vertexPath = new ArrayList<Position<Vertex<Choice>>>();
	static ArrayList<Button> choicePath = new ArrayList<Button>();
	static int choiceNumber = -1;
	
	public GraphPane()
	{
		
		graphPane = this;
		gridPane = new GridPane();
		//setting vbox/controls
		VBox vbox = new VBox();
		vbox.setMaxSize(800, 800);
		//setting pane/graph
		pane = new Pane();
		pane.setPrefSize(2000, 2000);
		
		//scrollpane
		scrollPane = new ScrollPane();
		scrollPane.setContent(pane);
		scrollPane.setPrefSize(600, 600);
		//adding both to main borderpane for layout



		
		//adding controls to vbox
		Label lblTotal = new Label("Total:");
		txtTotal = new TextArea();
		txtTotal.setPrefSize(getPrefWidth(), 20);
		
		Label lblDisplay = new Label("Display:");
		txtDisplay = new TextArea();
		txtDisplay.setPrefSize(getPrefWidth(), 20);
		
		//add buttons
		
		Button btnGoBack = new Button("Go Back One Choice");
		btnGoBack.setPrefSize(200, 30);
		
		Button btnDisplayChoices = new Button("Display Current Choices Info");
		btnDisplayChoices.setPrefSize(200, 30);


		
		gridPane.add(lblTotal, 0, 0);
		gridPane.add(txtTotal, 0, 1);
		gridPane.add(lblDisplay, 0, 2);
		gridPane.add(txtDisplay, 0, 3);
		gridPane.add(btnGoBack, 0, 4);
		gridPane.add(btnDisplayChoices, 1, 4);
		
		vbox.getChildren().add(gridPane);
		vbox.getChildren().add(scrollPane);
		
		this.getChildren().add(vbox);
		
		//generate tree and fill it
		ModifyTree modifyTree = new ModifyTree();
		
		tree = modifyTree.getTree();
		root = modifyTree.getRoot();
		
		try 
		{
			displayNodes(tree, root);
			displayEdge(tree, root);
			//System.out.println(tree.preOrderElementTraversal(tree, root));
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		//set buttons actipns
		
		btnGoBack.setOnAction(new EventHandler <ActionEvent>()
		{
			@Override
			public void handle(ActionEvent event) 
			{
				goBack();
			}		
		});
		
		btnDisplayChoices.setOnAction(new EventHandler <ActionEvent>()
		{
			@Override
			public void handle(ActionEvent event) 
			{
				//shortestPath();
				printChoices();
			}		
		});
		

		////
		
	}
	
	public static void goBack()
	{
		
		//if choice exists
		if(choiceNumber > -1)
		{
			//go back one on button
			Button button = choicePath.get(choiceNumber);
			button.setTextFill(null);
			button.setStyle("-fx-background-color: BLACK");
			System.out.println(button.getText());
			//go back on 
			Position<Vertex<Choice>> vertex = vertexPath.get(choiceNumber);
			vertex.element().getValue().setDisplayed(false);
			vertex.element().getValue().setVisited(false);
			
			//now get rid of button and vertex from list
			vertexPath.remove(choiceNumber);
			choicePath.remove(choiceNumber);
			
			total -= vertex.element().getWeight();
			txtTotal.setText("R"+total);
			choiceNumber--;
			
			
		}else
		{
			graphPane.setVisible(false);
			//go to error pane
			ErrorPane root = new ErrorPane("ERROR: There is no node selected to undo.", graphPane);
			Stage secondStage = new Stage();
			
			//secondStage.initStyle(StageStyle.UNDECORATED);
	        secondStage.setScene(new Scene(root));
	        secondStage.setTitle("Error");
	        secondStage.show();
	        return;
		}

	}
	
	public void addToPath(Position<Vertex<Choice>> elem,Button button)
	{
		vertexPath.add(elem);
		choicePath.add(button);
		choiceNumber++;
		
		total += elem.element().getWeight();
		txtTotal.setText("R"+total);
	}
	
	final static int nodeSize = 50;
	final static int edgeSize = 50;
	public static void addNode(int x, int y, Position<Vertex<Choice>> elem)
	{
		
		Button button = new Button(""+elem.element().getValue().getID());
		button.setShape(new Circle(10));
		button.setPrefSize(nodeSize,nodeSize);
		button.setLayoutX(x);
		button.setLayoutY(y);
		button.setTextFill(null);
		button.setStyle("-fx-background-color: BLACK");
		
		Label lblName = new Label(elem.element().getValue().getName());
		lblName.setLayoutX(x);
		lblName.setLayoutY(y-15);
		
		pane.getChildren().add(lblName);
		pane.getChildren().add(button);
		

		button.setOnAction(new EventHandler <ActionEvent>()
		{
			
			@Override
			public void handle(ActionEvent event) 
			{
				//total += elem;
				txtTotal.setText(""+total);
				graphPane.setVisible(false);
				
				//this is to search if parent has been visisted
				searchResult = false;
				//this is to search if a fellow child has been visited
				searchChildResult = true;
				try 
				{
					searchParentVisited(tree,  root, Integer.parseInt(button.getText()));
					searchFellowChildVisited(tree,  root, Integer.parseInt(button.getText()));
	
				} catch (Exception e) 
				{
					e.printStackTrace();
				}
				
				
				//if parent not visited yet
				if(!searchResult)
				{
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: Parent of Choice not selected yet.", graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
			        return;
					
				}else
				if(!searchChildResult)//now check if a fellow child has already been chosen
				{
								
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: You cannot choose more than one choice at the same depth", graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
			        return;
					
					
				}else
				if(button.getTextFill() == null)//if button viable
				{
					//opens main menu
					InfoPane root = new InfoPane(elem, button, graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Info");
			        secondStage.show();
					
				}else
				if(button.getTextFill().equals(Color.BLUE))//if buttons already been selected
				{
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: This option has already been selected.", graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
				}else
				{

					
				}
			}			
		});
	}
	
	public static void addEdge(int xP, int yP,int x, int y, Position<Vertex<Choice>> choice, int arrowPlacement)
	{	

		int posChange = 30;
		int midpointX = (xP+x+2*posChange)/2;
		int midpointY = (yP+y+2*posChange)/2;
		//System.out.println(xP +"-"+yP+"-"+x+"-"+y);
		//create line/edge from start to end
		Line line = new Line(xP+posChange, yP+posChange, x+posChange, y+posChange);
		Label lblWeight = new Label(""+choice.element().getWeight());
		lblWeight.setLayoutX(midpointX);
		lblWeight.setLayoutY(midpointY);
		
		//create directional arrow on line
		//Line arrowUp = new Line(x+15, y+25, x+30, y+30);
		//Line arrowDown = new Line(x+25, y+15, x+30, y+30);
		

		//if(xP != x && yP != y)
		{
			if(arrowPlacement > choice.element().getValue().getArrow())//upper bound
			{
				Polygon polygon = new Polygon();
		        polygon.getPoints().addAll(new Double[]{
		        		(double) (midpointX-15),(double) midpointY+10,
		        		(double) midpointX,(double) midpointY+15,
		        		(double) midpointX, (double) midpointY,
		        });

				pane.getChildren().add(polygon);

	
			}else
			if(arrowPlacement == choice.element().getValue().getArrow())//middle bound
			{

				Polygon polygon = new Polygon();
		        polygon.getPoints().addAll(new Double[]{
		        		(double) (midpointX-20),(double) midpointY-10,
		        		(double) midpointX,(double) midpointY,
		        		(double) midpointX-20, (double) midpointY+10,
		        });

				pane.getChildren().add(polygon);
				
			}else
			if(arrowPlacement < choice.element().getValue().getArrow())//lower bound
			{
				
				Polygon polygon = new Polygon();
		        polygon.getPoints().addAll(new Double[]{
		        		(double) (midpointX),(double) midpointY-20,
		        		(double) midpointX,(double) midpointY,
		        		(double) midpointX-20, (double) midpointY-10,
		        });

				pane.getChildren().add(polygon);
			}
		}
		//add line to pane
		//pane.getChildren().add(arrowUp);
		//pane.getChildren().add(arrowDown);
		pane.getChildren().add(line);
		pane.getChildren().add(lblWeight);
	}
	

	static int loop = 0;
	static int iteration = 1;
	static boolean endFound = false;

	private static void displayNodes(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice) throws Exception 
	{
		
		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);

		if(tree.parent(choice).get(0) == null)
		{
			choice.element().getValue().setX(0);
			choice.element().getValue().setY((int)scrollPane.getPrefHeight()/2);
			choice.element().getValue().setArrow(0);
			
			addNode(0, choice.element().getValue().getY(), choice);
		}
		
		while(iterator.hasNext())
		{
			//counts at which child you are currently at
			loop++;
			
			if(loop==3)
			{
				loop = 1;
			}
			
			Position<Vertex<Choice>> position = iterator.next();
			
			if(position.element().getValue().getDisplayed())
			{
				//System.out.println(position.toString() +"    ddddddd");
			}	
			else
			{
			
			//get depth which is the x axis
			int depth = tree.depth(tree, position);
			
			//calcuate y
			double numChild = tree.getNumChildren(tree.parent(position).get(0));


			
			int parentChoice = 0;
			//determines how a child of one parents should look

			if(tree.parent(position).size() == 1)
			{
				parentChoice = 0;
			}else
			if(tree.parent(position).size() % 2 == 0)//determines how a child of many parents should look - if even
			{
					parentChoice = tree.getNumChildren(tree.parent(position).get(0))/2;
					
				}else//determines how a child of many parents should look - if odd
				{
					
					parentChoice = (int)(tree.getNumChildren(tree.parent(position).get(0))/2+0.5);
					
				}
				
				//this is the # in order ofwhen the child was added to a parent
				int childNum = position.element().getValue().getChildNum();
				if(numChild <= 1)
				{
					
					position.element().getValue().setY(root.element().getValue().getY());
					position.element().getValue().setArrow(0);
				}
				else
				if(numChild/2 >= childNum || childNum==1)//in lower bound of loop
				{
					
					//set above parent
					position.element().getValue().setY(tree.parent(position).get(0).element().getValue().getY()-200/childNum);
					position.element().getValue().setArrow(-1);
					
				}else
				if(numChild/2 == childNum || numChild/2 == childNum-0.5)//at centre of loop
				{
	
					//set same as parent Y axis
					position.element().getValue().setY(tree.parent(position).get(0).element().getValue().getY());
					position.element().getValue().setArrow(0);
	
				}else
				{
					if((numChild+1-childNum) <= 0)
					{
						//set below parent
						position.element().getValue().setY((int)(tree.parent(position).get(0).element().getValue().getY()+200/(-numChild+1+childNum)));
						position.element().getValue().setArrow(1);
					}else
					{
						//set below parent
						position.element().getValue().setY((int)(tree.parent(position).get(0).element().getValue().getY()+200/(numChild+1-childNum)));
						position.element().getValue().setArrow(1);
					}
					
					
				}
						
	
				/*if(position.element().getValue().getID() == 7)
				{
					System.out.println("numPdasdasasdsad "+ tree.parent(position).size());
				}*/
				
				position.element().getValue().setX(depth*100);
				if(position.element().getValue().getY() > 1000)
				{
					System.out.println("\nID " + position.element().getValue().getID()+"   X: "+ position.element().getValue().getX()+"   Y: "+position.element().getValue().getY());
					System.out.println("loop " + loop+"   numChild: "+numChild+"\n");
				}
				
				
				//add nodes
				addNode(position.element().getValue().getX(), position.element().getValue().getY(),position);
				position.element().getValue().setDisplayed(true);
				//add all edges - can have many parents
				/*
				if(tree.getNumChildren(position) == 0)
				{
					loop = 0;
					endFound = true;
					iteration++;
				}*/
			}
			

			
			displayNodes(tree, position);
			
		}
		
	}
	
	
	
	private static void displayEdge(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice) throws Exception 
	{
		
		
		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);
		
		while(iterator.hasNext())
		{	
			Position<Vertex<Choice>> position = iterator.next();
			
			Iterator<Position<Vertex<Choice>>> iteratorC = tree.children(position);
			//to add root
			if(tree.parent(choice).get(0) == null)
			{

				addEdge(position.element().getValue().getX(),position.element().getValue().getY(),choice.element().getValue().getX(),choice.element().getValue().getY(),position,choice.element().getValue().getArrow());
			}
			
			while(iteratorC.hasNext())
			{		
				Position<Vertex<Choice>> c = iteratorC.next();
				addEdge(c.element().getValue().getX(),c.element().getValue().getY(),position.element().getValue().getX(),position.element().getValue().getY(),c,position.element().getValue().getArrow());
			}
			
				displayEdge(tree, position);
			
		}
		
	}

	static boolean searchResult;
	private static void searchParentVisited(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice, int id) throws Exception 
	{
		if(searchResult)
		{
			return;
		}
		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);
		//checks if root
		/*if(tree.parent(choice).get(0) == null)
		{
			//checks if root is search id
			if(id == root.element().id)
			{
				searchResult = true;
				return;
			}
		}*/
		
		while(iterator.hasNext())
		{
			if(searchResult)
			{
				return;
			}
			
			if(id == root.element().getValue().getID())
			{
				searchResult = true;
				return;
			}

			Position<Vertex<Choice>> position = iterator.next();
			
			//checks if correct node is found
			
			
			
			if(id == position.element().getValue().getID())
			{
				

				//checks if parent node has been visited before

				for(Position<Vertex<Choice>> c : tree.parent(position))
				{
					//searchResult = c.element().getVisited();

					if(c.element().getValue().getVisited())
					{
						searchResult = true;
						return;
					}
				}
				
			}
			
			searchParentVisited(tree, position, id);	
		}	
	}
	
	static boolean searchChildResult;
	private static void searchFellowChildVisited(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice, int id) throws Exception 
	{

		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);
		//checks if root
		if(tree.parent(choice).get(0) == null)
		{
			//checks if root is search id
			if(id == root.element().getValue().getID())
			{
				//System.out.println("root found");
				searchChildResult = true;
				return;
			}
		}
		
		while(iterator.hasNext())
		{
			
			Position<Vertex<Choice>> position = iterator.next();
			//checks if correct node is found
			if(id == position.element().getValue().getID())
			{

				//goes over all children of that paren
				Iterator<Position<Vertex<Choice>>> iteratorChild = tree.children(tree.parent(position).get(0));
				
				while(iteratorChild.hasNext())
				{
					
					Position<Vertex<Choice>> positionChild = iteratorChild.next();
					//System.out.println(positionChild.element().getID() + "  "+ positionChild.element().getVisited());
					//if child visited, return false
					if(positionChild.element().getValue().getVisited())
					{
						searchChildResult = false;
						return;
					}
				}
					

				
			}
			
			searchFellowChildVisited(tree, position, id);	
		}	
		//System.out.println("failure");
		
	}

	
	private static void printChoices()
	{
		for(Position<Vertex<Choice>> p : vertexPath)
		{
			
			System.out.println(p.element().getValue().toString() + "\n");
		}
	}
	
	private static void shortestPath(Position<Vertex<Choice>> lastPosition) throws Exception
	{
		

		Iterator<Position<Vertex<Choice>>> iterator = tree.children(lastPosition);
		
		while(iterator.hasNext())
		{
			Vertex<Choice>>> childPosition
		}
		if(!vertexPath.isEmpty())
		{
			
			Position<Vertex<Choice>> lastVertex = vertexPath.get(vertexPath.size()-1);
			
		}

	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-04-19 12:54:21.947
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-04-19 12:54:21.948
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-19 12:54:21.991
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------


import java.util.ArrayList;
import java.util.Iterator;

import com.jwetherell.algorithms.data_structures.Graph;
import com.jwetherell.algorithms.data_structures.Graph.Vertex;

import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.TextArea;
import javafx.scene.input.MouseDragEvent;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.Pane;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Line;
import javafx.scene.shape.Polygon;
import javafx.scene.shape.Shape;
import javafx.stage.Stage;
import javafx.stage.StageStyle;

public class GraphPane extends StackPane
{
	static Pane pane;
	static int total;
	static TextArea txtTotal;
	static TextArea txtDisplay;
	static GridPane gridPane;
	static GraphPane graphPane;
	static Tree<Vertex<Choice>> tree;
	static Position<Vertex<Choice>> root;
	static ScrollPane scrollPane;
	
	static ArrayList<Position<Vertex<Choice>>> vertexPath = new ArrayList<Position<Vertex<Choice>>>();
	static ArrayList<Button> choicePath = new ArrayList<Button>();
	static int choiceNumber = -1;
	
	public GraphPane()
	{
		
		graphPane = this;
		gridPane = new GridPane();
		//setting vbox/controls
		VBox vbox = new VBox();
		vbox.setMaxSize(800, 800);
		//setting pane/graph
		pane = new Pane();
		pane.setPrefSize(2000, 2000);
		
		//scrollpane
		scrollPane = new ScrollPane();
		scrollPane.setContent(pane);
		scrollPane.setPrefSize(600, 600);
		//adding both to main borderpane for layout



		
		//adding controls to vbox
		Label lblTotal = new Label("Total:");
		txtTotal = new TextArea();
		txtTotal.setPrefSize(getPrefWidth(), 20);
		
		Label lblDisplay = new Label("Display:");
		txtDisplay = new TextArea();
		txtDisplay.setPrefSize(getPrefWidth(), 20);
		
		//add buttons
		
		Button btnGoBack = new Button("Go Back One Choice");
		btnGoBack.setPrefSize(200, 30);
		
		Button btnDisplayChoices = new Button("Display Current Choices Info");
		btnDisplayChoices.setPrefSize(200, 30);


		
		gridPane.add(lblTotal, 0, 0);
		gridPane.add(txtTotal, 0, 1);
		gridPane.add(lblDisplay, 0, 2);
		gridPane.add(txtDisplay, 0, 3);
		gridPane.add(btnGoBack, 0, 4);
		gridPane.add(btnDisplayChoices, 1, 4);
		
		vbox.getChildren().add(gridPane);
		vbox.getChildren().add(scrollPane);
		
		this.getChildren().add(vbox);
		
		//generate tree and fill it
		ModifyTree modifyTree = new ModifyTree();
		
		tree = modifyTree.getTree();
		root = modifyTree.getRoot();
		
		try 
		{
			displayNodes(tree, root);
			displayEdge(tree, root);
			//System.out.println(tree.preOrderElementTraversal(tree, root));
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		//set buttons actipns
		
		btnGoBack.setOnAction(new EventHandler <ActionEvent>()
		{
			@Override
			public void handle(ActionEvent event) 
			{
				goBack();
			}		
		});
		
		btnDisplayChoices.setOnAction(new EventHandler <ActionEvent>()
		{
			@Override
			public void handle(ActionEvent event) 
			{
				//shortestPath();
				printChoices();
			}		
		});
		

		////
		
	}
	
	public static void goBack()
	{
		
		//if choice exists
		if(choiceNumber > -1)
		{
			//go back one on button
			Button button = choicePath.get(choiceNumber);
			button.setTextFill(null);
			button.setStyle("-fx-background-color: BLACK");
			System.out.println(button.getText());
			//go back on 
			Position<Vertex<Choice>> vertex = vertexPath.get(choiceNumber);
			vertex.element().getValue().setDisplayed(false);
			vertex.element().getValue().setVisited(false);
			
			//now get rid of button and vertex from list
			vertexPath.remove(choiceNumber);
			choicePath.remove(choiceNumber);
			
			total -= vertex.element().getWeight();
			txtTotal.setText("R"+total);
			choiceNumber--;
			
			
		}else
		{
			graphPane.setVisible(false);
			//go to error pane
			ErrorPane root = new ErrorPane("ERROR: There is no node selected to undo.", graphPane);
			Stage secondStage = new Stage();
			
			//secondStage.initStyle(StageStyle.UNDECORATED);
	        secondStage.setScene(new Scene(root));
	        secondStage.setTitle("Error");
	        secondStage.show();
	        return;
		}

	}
	
	public void addToPath(Position<Vertex<Choice>> elem,Button button)
	{
		vertexPath.add(elem);
		choicePath.add(button);
		choiceNumber++;
		
		total += elem.element().getWeight();
		txtTotal.setText("R"+total);
	}
	
	final static int nodeSize = 50;
	final static int edgeSize = 50;
	public static void addNode(int x, int y, Position<Vertex<Choice>> elem)
	{
		
		Button button = new Button(""+elem.element().getValue().getID());
		button.setShape(new Circle(10));
		button.setPrefSize(nodeSize,nodeSize);
		button.setLayoutX(x);
		button.setLayoutY(y);
		button.setTextFill(null);
		button.setStyle("-fx-background-color: BLACK");
		
		Label lblName = new Label(elem.element().getValue().getName());
		lblName.setLayoutX(x);
		lblName.setLayoutY(y-15);
		
		pane.getChildren().add(lblName);
		pane.getChildren().add(button);
		

		button.setOnAction(new EventHandler <ActionEvent>()
		{
			
			@Override
			public void handle(ActionEvent event) 
			{
				//total += elem;
				txtTotal.setText(""+total);
				graphPane.setVisible(false);
				
				//this is to search if parent has been visisted
				searchResult = false;
				//this is to search if a fellow child has been visited
				searchChildResult = true;
				try 
				{
					searchParentVisited(tree,  root, Integer.parseInt(button.getText()));
					searchFellowChildVisited(tree,  root, Integer.parseInt(button.getText()));
	
				} catch (Exception e) 
				{
					e.printStackTrace();
				}
				
				
				//if parent not visited yet
				if(!searchResult)
				{
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: Parent of Choice not selected yet.", graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
			        return;
					
				}else
				if(!searchChildResult)//now check if a fellow child has already been chosen
				{
								
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: You cannot choose more than one choice at the same depth", graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
			        return;
					
					
				}else
				if(button.getTextFill() == null)//if button viable
				{
					//opens main menu
					InfoPane root = new InfoPane(elem, button, graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Info");
			        secondStage.show();
					
				}else
				if(button.getTextFill().equals(Color.BLUE))//if buttons already been selected
				{
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: This option has already been selected.", graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
				}else
				{

					
				}
			}			
		});
	}
	
	public static void addEdge(int xP, int yP,int x, int y, Position<Vertex<Choice>> choice, int arrowPlacement)
	{	

		int posChange = 30;
		int midpointX = (xP+x+2*posChange)/2;
		int midpointY = (yP+y+2*posChange)/2;
		//System.out.println(xP +"-"+yP+"-"+x+"-"+y);
		//create line/edge from start to end
		Line line = new Line(xP+posChange, yP+posChange, x+posChange, y+posChange);
		Label lblWeight = new Label(""+choice.element().getWeight());
		lblWeight.setLayoutX(midpointX);
		lblWeight.setLayoutY(midpointY);
		
		//create directional arrow on line
		//Line arrowUp = new Line(x+15, y+25, x+30, y+30);
		//Line arrowDown = new Line(x+25, y+15, x+30, y+30);
		

		//if(xP != x && yP != y)
		{
			if(arrowPlacement > choice.element().getValue().getArrow())//upper bound
			{
				Polygon polygon = new Polygon();
		        polygon.getPoints().addAll(new Double[]{
		        		(double) (midpointX-15),(double) midpointY+10,
		        		(double) midpointX,(double) midpointY+15,
		        		(double) midpointX, (double) midpointY,
		        });

				pane.getChildren().add(polygon);

	
			}else
			if(arrowPlacement == choice.element().getValue().getArrow())//middle bound
			{

				Polygon polygon = new Polygon();
		        polygon.getPoints().addAll(new Double[]{
		        		(double) (midpointX-20),(double) midpointY-10,
		        		(double) midpointX,(double) midpointY,
		        		(double) midpointX-20, (double) midpointY+10,
		        });

				pane.getChildren().add(polygon);
				
			}else
			if(arrowPlacement < choice.element().getValue().getArrow())//lower bound
			{
				
				Polygon polygon = new Polygon();
		        polygon.getPoints().addAll(new Double[]{
		        		(double) (midpointX),(double) midpointY-20,
		        		(double) midpointX,(double) midpointY,
		        		(double) midpointX-20, (double) midpointY-10,
		        });

				pane.getChildren().add(polygon);
			}
		}
		//add line to pane
		//pane.getChildren().add(arrowUp);
		//pane.getChildren().add(arrowDown);
		pane.getChildren().add(line);
		pane.getChildren().add(lblWeight);
	}
	

	static int loop = 0;
	static int iteration = 1;
	static boolean endFound = false;

	private static void displayNodes(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice) throws Exception 
	{
		
		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);

		if(tree.parent(choice).get(0) == null)
		{
			choice.element().getValue().setX(0);
			choice.element().getValue().setY((int)scrollPane.getPrefHeight()/2);
			choice.element().getValue().setArrow(0);
			
			addNode(0, choice.element().getValue().getY(), choice);
		}
		
		while(iterator.hasNext())
		{
			//counts at which child you are currently at
			loop++;
			
			if(loop==3)
			{
				loop = 1;
			}
			
			Position<Vertex<Choice>> position = iterator.next();
			
			if(position.element().getValue().getDisplayed())
			{
				//System.out.println(position.toString() +"    ddddddd");
			}	
			else
			{
			
			//get depth which is the x axis
			int depth = tree.depth(tree, position);
			
			//calcuate y
			double numChild = tree.getNumChildren(tree.parent(position).get(0));


			
			int parentChoice = 0;
			//determines how a child of one parents should look

			if(tree.parent(position).size() == 1)
			{
				parentChoice = 0;
			}else
			if(tree.parent(position).size() % 2 == 0)//determines how a child of many parents should look - if even
			{
					parentChoice = tree.getNumChildren(tree.parent(position).get(0))/2;
					
				}else//determines how a child of many parents should look - if odd
				{
					
					parentChoice = (int)(tree.getNumChildren(tree.parent(position).get(0))/2+0.5);
					
				}
				
				//this is the # in order ofwhen the child was added to a parent
				int childNum = position.element().getValue().getChildNum();
				if(numChild <= 1)
				{
					
					position.element().getValue().setY(root.element().getValue().getY());
					position.element().getValue().setArrow(0);
				}
				else
				if(numChild/2 >= childNum || childNum==1)//in lower bound of loop
				{
					
					//set above parent
					position.element().getValue().setY(tree.parent(position).get(0).element().getValue().getY()-200/childNum);
					position.element().getValue().setArrow(-1);
					
				}else
				if(numChild/2 == childNum || numChild/2 == childNum-0.5)//at centre of loop
				{
	
					//set same as parent Y axis
					position.element().getValue().setY(tree.parent(position).get(0).element().getValue().getY());
					position.element().getValue().setArrow(0);
	
				}else
				{
					if((numChild+1-childNum) <= 0)
					{
						//set below parent
						position.element().getValue().setY((int)(tree.parent(position).get(0).element().getValue().getY()+200/(-numChild+1+childNum)));
						position.element().getValue().setArrow(1);
					}else
					{
						//set below parent
						position.element().getValue().setY((int)(tree.parent(position).get(0).element().getValue().getY()+200/(numChild+1-childNum)));
						position.element().getValue().setArrow(1);
					}
					
					
				}
						
	
				/*if(position.element().getValue().getID() == 7)
				{
					System.out.println("numPdasdasasdsad "+ tree.parent(position).size());
				}*/
				
				position.element().getValue().setX(depth*100);
				if(position.element().getValue().getY() > 1000)
				{
					System.out.println("\nID " + position.element().getValue().getID()+"   X: "+ position.element().getValue().getX()+"   Y: "+position.element().getValue().getY());
					System.out.println("loop " + loop+"   numChild: "+numChild+"\n");
				}
				
				
				//add nodes
				addNode(position.element().getValue().getX(), position.element().getValue().getY(),position);
				position.element().getValue().setDisplayed(true);
				//add all edges - can have many parents
				/*
				if(tree.getNumChildren(position) == 0)
				{
					loop = 0;
					endFound = true;
					iteration++;
				}*/
			}
			

			
			displayNodes(tree, position);
			
		}
		
	}
	
	
	
	private static void displayEdge(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice) throws Exception 
	{
		
		
		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);
		
		while(iterator.hasNext())
		{	
			Position<Vertex<Choice>> position = iterator.next();
			
			Iterator<Position<Vertex<Choice>>> iteratorC = tree.children(position);
			//to add root
			if(tree.parent(choice).get(0) == null)
			{

				addEdge(position.element().getValue().getX(),position.element().getValue().getY(),choice.element().getValue().getX(),choice.element().getValue().getY(),position,choice.element().getValue().getArrow());
			}
			
			while(iteratorC.hasNext())
			{		
				Position<Vertex<Choice>> c = iteratorC.next();
				addEdge(c.element().getValue().getX(),c.element().getValue().getY(),position.element().getValue().getX(),position.element().getValue().getY(),c,position.element().getValue().getArrow());
			}
			
				displayEdge(tree, position);
			
		}
		
	}

	static boolean searchResult;
	private static void searchParentVisited(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice, int id) throws Exception 
	{
		if(searchResult)
		{
			return;
		}
		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);
		//checks if root
		/*if(tree.parent(choice).get(0) == null)
		{
			//checks if root is search id
			if(id == root.element().id)
			{
				searchResult = true;
				return;
			}
		}*/
		
		while(iterator.hasNext())
		{
			if(searchResult)
			{
				return;
			}
			
			if(id == root.element().getValue().getID())
			{
				searchResult = true;
				return;
			}

			Position<Vertex<Choice>> position = iterator.next();
			
			//checks if correct node is found
			
			
			
			if(id == position.element().getValue().getID())
			{
				

				//checks if parent node has been visited before

				for(Position<Vertex<Choice>> c : tree.parent(position))
				{
					//searchResult = c.element().getVisited();

					if(c.element().getValue().getVisited())
					{
						searchResult = true;
						return;
					}
				}
				
			}
			
			searchParentVisited(tree, position, id);	
		}	
	}
	
	static boolean searchChildResult;
	private static void searchFellowChildVisited(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice, int id) throws Exception 
	{

		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);
		//checks if root
		if(tree.parent(choice).get(0) == null)
		{
			//checks if root is search id
			if(id == root.element().getValue().getID())
			{
				//System.out.println("root found");
				searchChildResult = true;
				return;
			}
		}
		
		while(iterator.hasNext())
		{
			
			Position<Vertex<Choice>> position = iterator.next();
			//checks if correct node is found
			if(id == position.element().getValue().getID())
			{

				//goes over all children of that paren
				Iterator<Position<Vertex<Choice>>> iteratorChild = tree.children(tree.parent(position).get(0));
				
				while(iteratorChild.hasNext())
				{
					
					Position<Vertex<Choice>> positionChild = iteratorChild.next();
					//System.out.println(positionChild.element().getID() + "  "+ positionChild.element().getVisited());
					//if child visited, return false
					if(positionChild.element().getValue().getVisited())
					{
						searchChildResult = false;
						return;
					}
				}
					

				
			}
			
			searchFellowChildVisited(tree, position, id);	
		}	
		//System.out.println("failure");
		
	}

	
	private static void printChoices()
	{
		for(Position<Vertex<Choice>> p : vertexPath)
		{
			
			System.out.println(p.element().getValue().toString() + "\n");
		}
	}
	
	private static void shortestPath(Position<Vertex<Choice>> lastPosition) throws Exception
	{
		

		Iterator<Position<Vertex<Choice>>> iterator = tree.children(lastPosition);
		
		while(iterator.hasNext())
		{
			Vertex<Choice>>> childPosition
		}
		if(!vertexPath.isEmpty())
		{
			
			Position<Vertex<Choice>> lastVertex = vertexPath.get(vertexPath.size()-1);
			
		}

	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-19 12:54:21.992
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-19 12:54:21.992
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-19 12:54:22.069
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------


import java.util.ArrayList;
import java.util.Iterator;

import com.jwetherell.algorithms.data_structures.Graph;
import com.jwetherell.algorithms.data_structures.Graph.Vertex;

import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.TextArea;
import javafx.scene.input.MouseDragEvent;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.Pane;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Line;
import javafx.scene.shape.Polygon;
import javafx.scene.shape.Shape;
import javafx.stage.Stage;
import javafx.stage.StageStyle;

public class GraphPane extends StackPane
{
	static Pane pane;
	static int total;
	static TextArea txtTotal;
	static TextArea txtDisplay;
	static GridPane gridPane;
	static GraphPane graphPane;
	static Tree<Vertex<Choice>> tree;
	static Position<Vertex<Choice>> root;
	static ScrollPane scrollPane;
	
	static ArrayList<Position<Vertex<Choice>>> vertexPath = new ArrayList<Position<Vertex<Choice>>>();
	static ArrayList<Button> choicePath = new ArrayList<Button>();
	static int choiceNumber = -1;
	
	public GraphPane()
	{
		
		graphPane = this;
		gridPane = new GridPane();
		//setting vbox/controls
		VBox vbox = new VBox();
		vbox.setMaxSize(800, 800);
		//setting pane/graph
		pane = new Pane();
		pane.setPrefSize(2000, 2000);
		
		//scrollpane
		scrollPane = new ScrollPane();
		scrollPane.setContent(pane);
		scrollPane.setPrefSize(600, 600);
		//adding both to main borderpane for layout



		
		//adding controls to vbox
		Label lblTotal = new Label("Total:");
		txtTotal = new TextArea();
		txtTotal.setPrefSize(getPrefWidth(), 20);
		
		Label lblDisplay = new Label("Display:");
		txtDisplay = new TextArea();
		txtDisplay.setPrefSize(getPrefWidth(), 20);
		
		//add buttons
		
		Button btnGoBack = new Button("Go Back One Choice");
		btnGoBack.setPrefSize(200, 30);
		
		Button btnDisplayChoices = new Button("Display Current Choices Info");
		btnDisplayChoices.setPrefSize(200, 30);


		
		gridPane.add(lblTotal, 0, 0);
		gridPane.add(txtTotal, 0, 1);
		gridPane.add(lblDisplay, 0, 2);
		gridPane.add(txtDisplay, 0, 3);
		gridPane.add(btnGoBack, 0, 4);
		gridPane.add(btnDisplayChoices, 1, 4);
		
		vbox.getChildren().add(gridPane);
		vbox.getChildren().add(scrollPane);
		
		this.getChildren().add(vbox);
		
		//generate tree and fill it
		ModifyTree modifyTree = new ModifyTree();
		
		tree = modifyTree.getTree();
		root = modifyTree.getRoot();
		
		try 
		{
			displayNodes(tree, root);
			displayEdge(tree, root);
			//System.out.println(tree.preOrderElementTraversal(tree, root));
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		//set buttons actipns
		
		btnGoBack.setOnAction(new EventHandler <ActionEvent>()
		{
			@Override
			public void handle(ActionEvent event) 
			{
				goBack();
			}		
		});
		
		btnDisplayChoices.setOnAction(new EventHandler <ActionEvent>()
		{
			@Override
			public void handle(ActionEvent event) 
			{
				//shortestPath();
				printChoices();
			}		
		});
		

		////
		
	}
	
	public static void goBack()
	{
		
		//if choice exists
		if(choiceNumber > -1)
		{
			//go back one on button
			Button button = choicePath.get(choiceNumber);
			button.setTextFill(null);
			button.setStyle("-fx-background-color: BLACK");
			System.out.println(button.getText());
			//go back on 
			Position<Vertex<Choice>> vertex = vertexPath.get(choiceNumber);
			vertex.element().getValue().setDisplayed(false);
			vertex.element().getValue().setVisited(false);
			
			//now get rid of button and vertex from list
			vertexPath.remove(choiceNumber);
			choicePath.remove(choiceNumber);
			
			total -= vertex.element().getWeight();
			txtTotal.setText("R"+total);
			choiceNumber--;
			
			
		}else
		{
			graphPane.setVisible(false);
			//go to error pane
			ErrorPane root = new ErrorPane("ERROR: There is no node selected to undo.", graphPane);
			Stage secondStage = new Stage();
			
			//secondStage.initStyle(StageStyle.UNDECORATED);
	        secondStage.setScene(new Scene(root));
	        secondStage.setTitle("Error");
	        secondStage.show();
	        return;
		}

	}
	
	public void addToPath(Position<Vertex<Choice>> elem,Button button)
	{
		vertexPath.add(elem);
		choicePath.add(button);
		choiceNumber++;
		
		total += elem.element().getWeight();
		txtTotal.setText("R"+total);
	}
	
	final static int nodeSize = 50;
	final static int edgeSize = 50;
	public static void addNode(int x, int y, Position<Vertex<Choice>> elem)
	{
		
		Button button = new Button(""+elem.element().getValue().getID());
		button.setShape(new Circle(10));
		button.setPrefSize(nodeSize,nodeSize);
		button.setLayoutX(x);
		button.setLayoutY(y);
		button.setTextFill(null);
		button.setStyle("-fx-background-color: BLACK");
		
		Label lblName = new Label(elem.element().getValue().getName());
		lblName.setLayoutX(x);
		lblName.setLayoutY(y-15);
		
		pane.getChildren().add(lblName);
		pane.getChildren().add(button);
		

		button.setOnAction(new EventHandler <ActionEvent>()
		{
			
			@Override
			public void handle(ActionEvent event) 
			{
				//total += elem;
				txtTotal.setText(""+total);
				graphPane.setVisible(false);
				
				//this is to search if parent has been visisted
				searchResult = false;
				//this is to search if a fellow child has been visited
				searchChildResult = true;
				try 
				{
					searchParentVisited(tree,  root, Integer.parseInt(button.getText()));
					searchFellowChildVisited(tree,  root, Integer.parseInt(button.getText()));
	
				} catch (Exception e) 
				{
					e.printStackTrace();
				}
				
				
				//if parent not visited yet
				if(!searchResult)
				{
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: Parent of Choice not selected yet.", graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
			        return;
					
				}else
				if(!searchChildResult)//now check if a fellow child has already been chosen
				{
								
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: You cannot choose more than one choice at the same depth", graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
			        return;
					
					
				}else
				if(button.getTextFill() == null)//if button viable
				{
					//opens main menu
					InfoPane root = new InfoPane(elem, button, graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Info");
			        secondStage.show();
					
				}else
				if(button.getTextFill().equals(Color.BLUE))//if buttons already been selected
				{
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: This option has already been selected.", graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
				}else
				{

					
				}
			}			
		});
	}
	
	public static void addEdge(int xP, int yP,int x, int y, Position<Vertex<Choice>> choice, int arrowPlacement)
	{	

		int posChange = 30;
		int midpointX = (xP+x+2*posChange)/2;
		int midpointY = (yP+y+2*posChange)/2;
		//System.out.println(xP +"-"+yP+"-"+x+"-"+y);
		//create line/edge from start to end
		Line line = new Line(xP+posChange, yP+posChange, x+posChange, y+posChange);
		Label lblWeight = new Label(""+choice.element().getWeight());
		lblWeight.setLayoutX(midpointX);
		lblWeight.setLayoutY(midpointY);
		
		//create directional arrow on line
		//Line arrowUp = new Line(x+15, y+25, x+30, y+30);
		//Line arrowDown = new Line(x+25, y+15, x+30, y+30);
		

		//if(xP != x && yP != y)
		{
			if(arrowPlacement > choice.element().getValue().getArrow())//upper bound
			{
				Polygon polygon = new Polygon();
		        polygon.getPoints().addAll(new Double[]{
		        		(double) (midpointX-15),(double) midpointY+10,
		        		(double) midpointX,(double) midpointY+15,
		        		(double) midpointX, (double) midpointY,
		        });

				pane.getChildren().add(polygon);

	
			}else
			if(arrowPlacement == choice.element().getValue().getArrow())//middle bound
			{

				Polygon polygon = new Polygon();
		        polygon.getPoints().addAll(new Double[]{
		        		(double) (midpointX-20),(double) midpointY-10,
		        		(double) midpointX,(double) midpointY,
		        		(double) midpointX-20, (double) midpointY+10,
		        });

				pane.getChildren().add(polygon);
				
			}else
			if(arrowPlacement < choice.element().getValue().getArrow())//lower bound
			{
				
				Polygon polygon = new Polygon();
		        polygon.getPoints().addAll(new Double[]{
		        		(double) (midpointX),(double) midpointY-20,
		        		(double) midpointX,(double) midpointY,
		        		(double) midpointX-20, (double) midpointY-10,
		        });

				pane.getChildren().add(polygon);
			}
		}
		//add line to pane
		//pane.getChildren().add(arrowUp);
		//pane.getChildren().add(arrowDown);
		pane.getChildren().add(line);
		pane.getChildren().add(lblWeight);
	}
	

	static int loop = 0;
	static int iteration = 1;
	static boolean endFound = false;

	private static void displayNodes(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice) throws Exception 
	{
		
		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);

		if(tree.parent(choice).get(0) == null)
		{
			choice.element().getValue().setX(0);
			choice.element().getValue().setY((int)scrollPane.getPrefHeight()/2);
			choice.element().getValue().setArrow(0);
			
			addNode(0, choice.element().getValue().getY(), choice);
		}
		
		while(iterator.hasNext())
		{
			//counts at which child you are currently at
			loop++;
			
			if(loop==3)
			{
				loop = 1;
			}
			
			Position<Vertex<Choice>> position = iterator.next();
			
			if(position.element().getValue().getDisplayed())
			{
				//System.out.println(position.toString() +"    ddddddd");
			}	
			else
			{
			
			//get depth which is the x axis
			int depth = tree.depth(tree, position);
			
			//calcuate y
			double numChild = tree.getNumChildren(tree.parent(position).get(0));


			
			int parentChoice = 0;
			//determines how a child of one parents should look

			if(tree.parent(position).size() == 1)
			{
				parentChoice = 0;
			}else
			if(tree.parent(position).size() % 2 == 0)//determines how a child of many parents should look - if even
			{
					parentChoice = tree.getNumChildren(tree.parent(position).get(0))/2;
					
				}else//determines how a child of many parents should look - if odd
				{
					
					parentChoice = (int)(tree.getNumChildren(tree.parent(position).get(0))/2+0.5);
					
				}
				
				//this is the # in order ofwhen the child was added to a parent
				int childNum = position.element().getValue().getChildNum();
				if(numChild <= 1)
				{
					
					position.element().getValue().setY(root.element().getValue().getY());
					position.element().getValue().setArrow(0);
				}
				else
				if(numChild/2 >= childNum || childNum==1)//in lower bound of loop
				{
					
					//set above parent
					position.element().getValue().setY(tree.parent(position).get(0).element().getValue().getY()-200/childNum);
					position.element().getValue().setArrow(-1);
					
				}else
				if(numChild/2 == childNum || numChild/2 == childNum-0.5)//at centre of loop
				{
	
					//set same as parent Y axis
					position.element().getValue().setY(tree.parent(position).get(0).element().getValue().getY());
					position.element().getValue().setArrow(0);
	
				}else
				{
					if((numChild+1-childNum) <= 0)
					{
						//set below parent
						position.element().getValue().setY((int)(tree.parent(position).get(0).element().getValue().getY()+200/(-numChild+1+childNum)));
						position.element().getValue().setArrow(1);
					}else
					{
						//set below parent
						position.element().getValue().setY((int)(tree.parent(position).get(0).element().getValue().getY()+200/(numChild+1-childNum)));
						position.element().getValue().setArrow(1);
					}
					
					
				}
						
	
				/*if(position.element().getValue().getID() == 7)
				{
					System.out.println("numPdasdasasdsad "+ tree.parent(position).size());
				}*/
				
				position.element().getValue().setX(depth*100);
				if(position.element().getValue().getY() > 1000)
				{
					System.out.println("\nID " + position.element().getValue().getID()+"   X: "+ position.element().getValue().getX()+"   Y: "+position.element().getValue().getY());
					System.out.println("loop " + loop+"   numChild: "+numChild+"\n");
				}
				
				
				//add nodes
				addNode(position.element().getValue().getX(), position.element().getValue().getY(),position);
				position.element().getValue().setDisplayed(true);
				//add all edges - can have many parents
				/*
				if(tree.getNumChildren(position) == 0)
				{
					loop = 0;
					endFound = true;
					iteration++;
				}*/
			}
			

			
			displayNodes(tree, position);
			
		}
		
	}
	
	
	
	private static void displayEdge(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice) throws Exception 
	{
		
		
		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);
		
		while(iterator.hasNext())
		{	
			Position<Vertex<Choice>> position = iterator.next();
			
			Iterator<Position<Vertex<Choice>>> iteratorC = tree.children(position);
			//to add root
			if(tree.parent(choice).get(0) == null)
			{

				addEdge(position.element().getValue().getX(),position.element().getValue().getY(),choice.element().getValue().getX(),choice.element().getValue().getY(),position,choice.element().getValue().getArrow());
			}
			
			while(iteratorC.hasNext())
			{		
				Position<Vertex<Choice>> c = iteratorC.next();
				addEdge(c.element().getValue().getX(),c.element().getValue().getY(),position.element().getValue().getX(),position.element().getValue().getY(),c,position.element().getValue().getArrow());
			}
			
				displayEdge(tree, position);
			
		}
		
	}

	static boolean searchResult;
	private static void searchParentVisited(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice, int id) throws Exception 
	{
		if(searchResult)
		{
			return;
		}
		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);
		//checks if root
		/*if(tree.parent(choice).get(0) == null)
		{
			//checks if root is search id
			if(id == root.element().id)
			{
				searchResult = true;
				return;
			}
		}*/
		
		while(iterator.hasNext())
		{
			if(searchResult)
			{
				return;
			}
			
			if(id == root.element().getValue().getID())
			{
				searchResult = true;
				return;
			}

			Position<Vertex<Choice>> position = iterator.next();
			
			//checks if correct node is found
			
			
			
			if(id == position.element().getValue().getID())
			{
				

				//checks if parent node has been visited before

				for(Position<Vertex<Choice>> c : tree.parent(position))
				{
					//searchResult = c.element().getVisited();

					if(c.element().getValue().getVisited())
					{
						searchResult = true;
						return;
					}
				}
				
			}
			
			searchParentVisited(tree, position, id);	
		}	
	}
	
	static boolean searchChildResult;
	private static void searchFellowChildVisited(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice, int id) throws Exception 
	{

		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);
		//checks if root
		if(tree.parent(choice).get(0) == null)
		{
			//checks if root is search id
			if(id == root.element().getValue().getID())
			{
				//System.out.println("root found");
				searchChildResult = true;
				return;
			}
		}
		
		while(iterator.hasNext())
		{
			
			Position<Vertex<Choice>> position = iterator.next();
			//checks if correct node is found
			if(id == position.element().getValue().getID())
			{

				//goes over all children of that paren
				Iterator<Position<Vertex<Choice>>> iteratorChild = tree.children(tree.parent(position).get(0));
				
				while(iteratorChild.hasNext())
				{
					
					Position<Vertex<Choice>> positionChild = iteratorChild.next();
					//System.out.println(positionChild.element().getID() + "  "+ positionChild.element().getVisited());
					//if child visited, return false
					if(positionChild.element().getValue().getVisited())
					{
						searchChildResult = false;
						return;
					}
				}
					

				
			}
			
			searchFellowChildVisited(tree, position, id);	
		}	
		//System.out.println("failure");
		
	}

	
	private static void printChoices()
	{
		for(Position<Vertex<Choice>> p : vertexPath)
		{
			
			System.out.println(p.element().getValue().toString() + "\n");
		}
	}
	
	private static void shortestPath(Position<Vertex<Choice>> lastPosition) throws Exception
	{
		

		Iterator<Position<Vertex<Choice>>> iterator = tree.children(lastPosition);
		
		while(iterator.hasNext())
		{
			Vertex<Choice>>> childPosition
		}
		if(!vertexPath.isEmpty())
		{
			
			Position<Vertex<Choice>> lastVertex = vertexPath.get(vertexPath.size()-1);
			
		}

	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-19 12:54:22.071
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-19 12:54:22.071
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-19 12:54:24.413
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------


import java.util.ArrayList;
import java.util.Iterator;

import com.jwetherell.algorithms.data_structures.Graph;
import com.jwetherell.algorithms.data_structures.Graph.Vertex;

import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.TextArea;
import javafx.scene.input.MouseDragEvent;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.Pane;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Line;
import javafx.scene.shape.Polygon;
import javafx.scene.shape.Shape;
import javafx.stage.Stage;
import javafx.stage.StageStyle;

public class GraphPane extends StackPane
{
	static Pane pane;
	static int total;
	static TextArea txtTotal;
	static TextArea txtDisplay;
	static GridPane gridPane;
	static GraphPane graphPane;
	static Tree<Vertex<Choice>> tree;
	static Position<Vertex<Choice>> root;
	static ScrollPane scrollPane;
	
	static ArrayList<Position<Vertex<Choice>>> vertexPath = new ArrayList<Position<Vertex<Choice>>>();
	static ArrayList<Button> choicePath = new ArrayList<Button>();
	static int choiceNumber = -1;
	
	public GraphPane()
	{
		
		graphPane = this;
		gridPane = new GridPane();
		//setting vbox/controls
		VBox vbox = new VBox();
		vbox.setMaxSize(800, 800);
		//setting pane/graph
		pane = new Pane();
		pane.setPrefSize(2000, 2000);
		
		//scrollpane
		scrollPane = new ScrollPane();
		scrollPane.setContent(pane);
		scrollPane.setPrefSize(600, 600);
		//adding both to main borderpane for layout



		
		//adding controls to vbox
		Label lblTotal = new Label("Total:");
		txtTotal = new TextArea();
		txtTotal.setPrefSize(getPrefWidth(), 20);
		
		Label lblDisplay = new Label("Display:");
		txtDisplay = new TextArea();
		txtDisplay.setPrefSize(getPrefWidth(), 20);
		
		//add buttons
		
		Button btnGoBack = new Button("Go Back One Choice");
		btnGoBack.setPrefSize(200, 30);
		
		Button btnDisplayChoices = new Button("Display Current Choices Info");
		btnDisplayChoices.setPrefSize(200, 30);


		
		gridPane.add(lblTotal, 0, 0);
		gridPane.add(txtTotal, 0, 1);
		gridPane.add(lblDisplay, 0, 2);
		gridPane.add(txtDisplay, 0, 3);
		gridPane.add(btnGoBack, 0, 4);
		gridPane.add(btnDisplayChoices, 1, 4);
		
		vbox.getChildren().add(gridPane);
		vbox.getChildren().add(scrollPane);
		
		this.getChildren().add(vbox);
		
		//generate tree and fill it
		ModifyTree modifyTree = new ModifyTree();
		
		tree = modifyTree.getTree();
		root = modifyTree.getRoot();
		
		try 
		{
			displayNodes(tree, root);
			displayEdge(tree, root);
			//System.out.println(tree.preOrderElementTraversal(tree, root));
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		//set buttons actipns
		
		btnGoBack.setOnAction(new EventHandler <ActionEvent>()
		{
			@Override
			public void handle(ActionEvent event) 
			{
				goBack();
			}		
		});
		
		btnDisplayChoices.setOnAction(new EventHandler <ActionEvent>()
		{
			@Override
			public void handle(ActionEvent event) 
			{
				//shortestPath();
				printChoices();
			}		
		});
		

		////
		
	}
	
	public static void goBack()
	{
		
		//if choice exists
		if(choiceNumber > -1)
		{
			//go back one on button
			Button button = choicePath.get(choiceNumber);
			button.setTextFill(null);
			button.setStyle("-fx-background-color: BLACK");
			System.out.println(button.getText());
			//go back on 
			Position<Vertex<Choice>> vertex = vertexPath.get(choiceNumber);
			vertex.element().getValue().setDisplayed(false);
			vertex.element().getValue().setVisited(false);
			
			//now get rid of button and vertex from list
			vertexPath.remove(choiceNumber);
			choicePath.remove(choiceNumber);
			
			total -= vertex.element().getWeight();
			txtTotal.setText("R"+total);
			choiceNumber--;
			
			
		}else
		{
			graphPane.setVisible(false);
			//go to error pane
			ErrorPane root = new ErrorPane("ERROR: There is no node selected to undo.", graphPane);
			Stage secondStage = new Stage();
			
			//secondStage.initStyle(StageStyle.UNDECORATED);
	        secondStage.setScene(new Scene(root));
	        secondStage.setTitle("Error");
	        secondStage.show();
	        return;
		}

	}
	
	public void addToPath(Position<Vertex<Choice>> elem,Button button)
	{
		vertexPath.add(elem);
		choicePath.add(button);
		choiceNumber++;
		
		total += elem.element().getWeight();
		txtTotal.setText("R"+total);
	}
	
	final static int nodeSize = 50;
	final static int edgeSize = 50;
	public static void addNode(int x, int y, Position<Vertex<Choice>> elem)
	{
		
		Button button = new Button(""+elem.element().getValue().getID());
		button.setShape(new Circle(10));
		button.setPrefSize(nodeSize,nodeSize);
		button.setLayoutX(x);
		button.setLayoutY(y);
		button.setTextFill(null);
		button.setStyle("-fx-background-color: BLACK");
		
		Label lblName = new Label(elem.element().getValue().getName());
		lblName.setLayoutX(x);
		lblName.setLayoutY(y-15);
		
		pane.getChildren().add(lblName);
		pane.getChildren().add(button);
		

		button.setOnAction(new EventHandler <ActionEvent>()
		{
			
			@Override
			public void handle(ActionEvent event) 
			{
				//total += elem;
				txtTotal.setText(""+total);
				graphPane.setVisible(false);
				
				//this is to search if parent has been visisted
				searchResult = false;
				//this is to search if a fellow child has been visited
				searchChildResult = true;
				try 
				{
					searchParentVisited(tree,  root, Integer.parseInt(button.getText()));
					searchFellowChildVisited(tree,  root, Integer.parseInt(button.getText()));
	
				} catch (Exception e) 
				{
					e.printStackTrace();
				}
				
				
				//if parent not visited yet
				if(!searchResult)
				{
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: Parent of Choice not selected yet.", graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
			        return;
					
				}else
				if(!searchChildResult)//now check if a fellow child has already been chosen
				{
								
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: You cannot choose more than one choice at the same depth", graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
			        return;
					
					
				}else
				if(button.getTextFill() == null)//if button viable
				{
					//opens main menu
					InfoPane root = new InfoPane(elem, button, graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Info");
			        secondStage.show();
					
				}else
				if(button.getTextFill().equals(Color.BLUE))//if buttons already been selected
				{
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: This option has already been selected.", graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
				}else
				{

					
				}
			}			
		});
	}
	
	public static void addEdge(int xP, int yP,int x, int y, Position<Vertex<Choice>> choice, int arrowPlacement)
	{	

		int posChange = 30;
		int midpointX = (xP+x+2*posChange)/2;
		int midpointY = (yP+y+2*posChange)/2;
		//System.out.println(xP +"-"+yP+"-"+x+"-"+y);
		//create line/edge from start to end
		Line line = new Line(xP+posChange, yP+posChange, x+posChange, y+posChange);
		Label lblWeight = new Label(""+choice.element().getWeight());
		lblWeight.setLayoutX(midpointX);
		lblWeight.setLayoutY(midpointY);
		
		//create directional arrow on line
		//Line arrowUp = new Line(x+15, y+25, x+30, y+30);
		//Line arrowDown = new Line(x+25, y+15, x+30, y+30);
		

		//if(xP != x && yP != y)
		{
			if(arrowPlacement > choice.element().getValue().getArrow())//upper bound
			{
				Polygon polygon = new Polygon();
		        polygon.getPoints().addAll(new Double[]{
		        		(double) (midpointX-15),(double) midpointY+10,
		        		(double) midpointX,(double) midpointY+15,
		        		(double) midpointX, (double) midpointY,
		        });

				pane.getChildren().add(polygon);

	
			}else
			if(arrowPlacement == choice.element().getValue().getArrow())//middle bound
			{

				Polygon polygon = new Polygon();
		        polygon.getPoints().addAll(new Double[]{
		        		(double) (midpointX-20),(double) midpointY-10,
		        		(double) midpointX,(double) midpointY,
		        		(double) midpointX-20, (double) midpointY+10,
		        });

				pane.getChildren().add(polygon);
				
			}else
			if(arrowPlacement < choice.element().getValue().getArrow())//lower bound
			{
				
				Polygon polygon = new Polygon();
		        polygon.getPoints().addAll(new Double[]{
		        		(double) (midpointX),(double) midpointY-20,
		        		(double) midpointX,(double) midpointY,
		        		(double) midpointX-20, (double) midpointY-10,
		        });

				pane.getChildren().add(polygon);
			}
		}
		//add line to pane
		//pane.getChildren().add(arrowUp);
		//pane.getChildren().add(arrowDown);
		pane.getChildren().add(line);
		pane.getChildren().add(lblWeight);
	}
	

	static int loop = 0;
	static int iteration = 1;
	static boolean endFound = false;

	private static void displayNodes(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice) throws Exception 
	{
		
		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);

		if(tree.parent(choice).get(0) == null)
		{
			choice.element().getValue().setX(0);
			choice.element().getValue().setY((int)scrollPane.getPrefHeight()/2);
			choice.element().getValue().setArrow(0);
			
			addNode(0, choice.element().getValue().getY(), choice);
		}
		
		while(iterator.hasNext())
		{
			//counts at which child you are currently at
			loop++;
			
			if(loop==3)
			{
				loop = 1;
			}
			
			Position<Vertex<Choice>> position = iterator.next();
			
			if(position.element().getValue().getDisplayed())
			{
				//System.out.println(position.toString() +"    ddddddd");
			}	
			else
			{
			
			//get depth which is the x axis
			int depth = tree.depth(tree, position);
			
			//calcuate y
			double numChild = tree.getNumChildren(tree.parent(position).get(0));


			
			int parentChoice = 0;
			//determines how a child of one parents should look

			if(tree.parent(position).size() == 1)
			{
				parentChoice = 0;
			}else
			if(tree.parent(position).size() % 2 == 0)//determines how a child of many parents should look - if even
			{
					parentChoice = tree.getNumChildren(tree.parent(position).get(0))/2;
					
				}else//determines how a child of many parents should look - if odd
				{
					
					parentChoice = (int)(tree.getNumChildren(tree.parent(position).get(0))/2+0.5);
					
				}
				
				//this is the # in order ofwhen the child was added to a parent
				int childNum = position.element().getValue().getChildNum();
				if(numChild <= 1)
				{
					
					position.element().getValue().setY(root.element().getValue().getY());
					position.element().getValue().setArrow(0);
				}
				else
				if(numChild/2 >= childNum || childNum==1)//in lower bound of loop
				{
					
					//set above parent
					position.element().getValue().setY(tree.parent(position).get(0).element().getValue().getY()-200/childNum);
					position.element().getValue().setArrow(-1);
					
				}else
				if(numChild/2 == childNum || numChild/2 == childNum-0.5)//at centre of loop
				{
	
					//set same as parent Y axis
					position.element().getValue().setY(tree.parent(position).get(0).element().getValue().getY());
					position.element().getValue().setArrow(0);
	
				}else
				{
					if((numChild+1-childNum) <= 0)
					{
						//set below parent
						position.element().getValue().setY((int)(tree.parent(position).get(0).element().getValue().getY()+200/(-numChild+1+childNum)));
						position.element().getValue().setArrow(1);
					}else
					{
						//set below parent
						position.element().getValue().setY((int)(tree.parent(position).get(0).element().getValue().getY()+200/(numChild+1-childNum)));
						position.element().getValue().setArrow(1);
					}
					
					
				}
						
	
				/*if(position.element().getValue().getID() == 7)
				{
					System.out.println("numPdasdasasdsad "+ tree.parent(position).size());
				}*/
				
				position.element().getValue().setX(depth*100);
				if(position.element().getValue().getY() > 1000)
				{
					System.out.println("\nID " + position.element().getValue().getID()+"   X: "+ position.element().getValue().getX()+"   Y: "+position.element().getValue().getY());
					System.out.println("loop " + loop+"   numChild: "+numChild+"\n");
				}
				
				
				//add nodes
				addNode(position.element().getValue().getX(), position.element().getValue().getY(),position);
				position.element().getValue().setDisplayed(true);
				//add all edges - can have many parents
				/*
				if(tree.getNumChildren(position) == 0)
				{
					loop = 0;
					endFound = true;
					iteration++;
				}*/
			}
			

			
			displayNodes(tree, position);
			
		}
		
	}
	
	
	
	private static void displayEdge(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice) throws Exception 
	{
		
		
		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);
		
		while(iterator.hasNext())
		{	
			Position<Vertex<Choice>> position = iterator.next();
			
			Iterator<Position<Vertex<Choice>>> iteratorC = tree.children(position);
			//to add root
			if(tree.parent(choice).get(0) == null)
			{

				addEdge(position.element().getValue().getX(),position.element().getValue().getY(),choice.element().getValue().getX(),choice.element().getValue().getY(),position,choice.element().getValue().getArrow());
			}
			
			while(iteratorC.hasNext())
			{		
				Position<Vertex<Choice>> c = iteratorC.next();
				addEdge(c.element().getValue().getX(),c.element().getValue().getY(),position.element().getValue().getX(),position.element().getValue().getY(),c,position.element().getValue().getArrow());
			}
			
				displayEdge(tree, position);
			
		}
		
	}

	static boolean searchResult;
	private static void searchParentVisited(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice, int id) throws Exception 
	{
		if(searchResult)
		{
			return;
		}
		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);
		//checks if root
		/*if(tree.parent(choice).get(0) == null)
		{
			//checks if root is search id
			if(id == root.element().id)
			{
				searchResult = true;
				return;
			}
		}*/
		
		while(iterator.hasNext())
		{
			if(searchResult)
			{
				return;
			}
			
			if(id == root.element().getValue().getID())
			{
				searchResult = true;
				return;
			}

			Position<Vertex<Choice>> position = iterator.next();
			
			//checks if correct node is found
			
			
			
			if(id == position.element().getValue().getID())
			{
				

				//checks if parent node has been visited before

				for(Position<Vertex<Choice>> c : tree.parent(position))
				{
					//searchResult = c.element().getVisited();

					if(c.element().getValue().getVisited())
					{
						searchResult = true;
						return;
					}
				}
				
			}
			
			searchParentVisited(tree, position, id);	
		}	
	}
	
	static boolean searchChildResult;
	private static void searchFellowChildVisited(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice, int id) throws Exception 
	{

		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);
		//checks if root
		if(tree.parent(choice).get(0) == null)
		{
			//checks if root is search id
			if(id == root.element().getValue().getID())
			{
				//System.out.println("root found");
				searchChildResult = true;
				return;
			}
		}
		
		while(iterator.hasNext())
		{
			
			Position<Vertex<Choice>> position = iterator.next();
			//checks if correct node is found
			if(id == position.element().getValue().getID())
			{

				//goes over all children of that paren
				Iterator<Position<Vertex<Choice>>> iteratorChild = tree.children(tree.parent(position).get(0));
				
				while(iteratorChild.hasNext())
				{
					
					Position<Vertex<Choice>> positionChild = iteratorChild.next();
					//System.out.println(positionChild.element().getID() + "  "+ positionChild.element().getVisited());
					//if child visited, return false
					if(positionChild.element().getValue().getVisited())
					{
						searchChildResult = false;
						return;
					}
				}
					

				
			}
			
			searchFellowChildVisited(tree, position, id);	
		}	
		//System.out.println("failure");
		
	}

	
	private static void printChoices()
	{
		for(Position<Vertex<Choice>> p : vertexPath)
		{
			
			System.out.println(p.element().getValue().toString() + "\n");
		}
	}
	
	private static void shortestPath(Position<Vertex<Choice>> lastPosition) throws Exception
	{
		

		Iterator<Position<Vertex<Choice>>> iterator = tree.children(lastPosition);
		
		while(iterator.hasNext())
		{
			Vertex<Choice>>> childPosition
		}
		if(!vertexPath.isEmpty())
		{
			
			Position<Vertex<Choice>> lastVertex = vertexPath.get(vertexPath.size()-1);
			
		}

	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-19 12:54:24.415
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-19 12:54:24.417
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-19 12:54:25.276
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------


import java.util.ArrayList;
import java.util.Iterator;

import com.jwetherell.algorithms.data_structures.Graph;
import com.jwetherell.algorithms.data_structures.Graph.Vertex;

import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.TextArea;
import javafx.scene.input.MouseDragEvent;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.Pane;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Line;
import javafx.scene.shape.Polygon;
import javafx.scene.shape.Shape;
import javafx.stage.Stage;
import javafx.stage.StageStyle;

public class GraphPane extends StackPane
{
	static Pane pane;
	static int total;
	static TextArea txtTotal;
	static TextArea txtDisplay;
	static GridPane gridPane;
	static GraphPane graphPane;
	static Tree<Vertex<Choice>> tree;
	static Position<Vertex<Choice>> root;
	static ScrollPane scrollPane;
	
	static ArrayList<Position<Vertex<Choice>>> vertexPath = new ArrayList<Position<Vertex<Choice>>>();
	static ArrayList<Button> choicePath = new ArrayList<Button>();
	static int choiceNumber = -1;
	
	public GraphPane()
	{
		
		graphPane = this;
		gridPane = new GridPane();
		//setting vbox/controls
		VBox vbox = new VBox();
		vbox.setMaxSize(800, 800);
		//setting pane/graph
		pane = new Pane();
		pane.setPrefSize(2000, 2000);
		
		//scrollpane
		scrollPane = new ScrollPane();
		scrollPane.setContent(pane);
		scrollPane.setPrefSize(600, 600);
		//adding both to main borderpane for layout



		
		//adding controls to vbox
		Label lblTotal = new Label("Total:");
		txtTotal = new TextArea();
		txtTotal.setPrefSize(getPrefWidth(), 20);
		
		Label lblDisplay = new Label("Display:");
		txtDisplay = new TextArea();
		txtDisplay.setPrefSize(getPrefWidth(), 20);
		
		//add buttons
		
		Button btnGoBack = new Button("Go Back One Choice");
		btnGoBack.setPrefSize(200, 30);
		
		Button btnDisplayChoices = new Button("Display Current Choices Info");
		btnDisplayChoices.setPrefSize(200, 30);


		
		gridPane.add(lblTotal, 0, 0);
		gridPane.add(txtTotal, 0, 1);
		gridPane.add(lblDisplay, 0, 2);
		gridPane.add(txtDisplay, 0, 3);
		gridPane.add(btnGoBack, 0, 4);
		gridPane.add(btnDisplayChoices, 1, 4);
		
		vbox.getChildren().add(gridPane);
		vbox.getChildren().add(scrollPane);
		
		this.getChildren().add(vbox);
		
		//generate tree and fill it
		ModifyTree modifyTree = new ModifyTree();
		
		tree = modifyTree.getTree();
		root = modifyTree.getRoot();
		
		try 
		{
			displayNodes(tree, root);
			displayEdge(tree, root);
			//System.out.println(tree.preOrderElementTraversal(tree, root));
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		//set buttons actipns
		
		btnGoBack.setOnAction(new EventHandler <ActionEvent>()
		{
			@Override
			public void handle(ActionEvent event) 
			{
				goBack();
			}		
		});
		
		btnDisplayChoices.setOnAction(new EventHandler <ActionEvent>()
		{
			@Override
			public void handle(ActionEvent event) 
			{
				//shortestPath();
				printChoices();
			}		
		});
		

		////
		
	}
	
	public static void goBack()
	{
		
		//if choice exists
		if(choiceNumber > -1)
		{
			//go back one on button
			Button button = choicePath.get(choiceNumber);
			button.setTextFill(null);
			button.setStyle("-fx-background-color: BLACK");
			System.out.println(button.getText());
			//go back on 
			Position<Vertex<Choice>> vertex = vertexPath.get(choiceNumber);
			vertex.element().getValue().setDisplayed(false);
			vertex.element().getValue().setVisited(false);
			
			//now get rid of button and vertex from list
			vertexPath.remove(choiceNumber);
			choicePath.remove(choiceNumber);
			
			total -= vertex.element().getWeight();
			txtTotal.setText("R"+total);
			choiceNumber--;
			
			
		}else
		{
			graphPane.setVisible(false);
			//go to error pane
			ErrorPane root = new ErrorPane("ERROR: There is no node selected to undo.", graphPane);
			Stage secondStage = new Stage();
			
			//secondStage.initStyle(StageStyle.UNDECORATED);
	        secondStage.setScene(new Scene(root));
	        secondStage.setTitle("Error");
	        secondStage.show();
	        return;
		}

	}
	
	public void addToPath(Position<Vertex<Choice>> elem,Button button)
	{
		vertexPath.add(elem);
		choicePath.add(button);
		choiceNumber++;
		
		total += elem.element().getWeight();
		txtTotal.setText("R"+total);
	}
	
	final static int nodeSize = 50;
	final static int edgeSize = 50;
	public static void addNode(int x, int y, Position<Vertex<Choice>> elem)
	{
		
		Button button = new Button(""+elem.element().getValue().getID());
		button.setShape(new Circle(10));
		button.setPrefSize(nodeSize,nodeSize);
		button.setLayoutX(x);
		button.setLayoutY(y);
		button.setTextFill(null);
		button.setStyle("-fx-background-color: BLACK");
		
		Label lblName = new Label(elem.element().getValue().getName());
		lblName.setLayoutX(x);
		lblName.setLayoutY(y-15);
		
		pane.getChildren().add(lblName);
		pane.getChildren().add(button);
		

		button.setOnAction(new EventHandler <ActionEvent>()
		{
			
			@Override
			public void handle(ActionEvent event) 
			{
				//total += elem;
				txtTotal.setText(""+total);
				graphPane.setVisible(false);
				
				//this is to search if parent has been visisted
				searchResult = false;
				//this is to search if a fellow child has been visited
				searchChildResult = true;
				try 
				{
					searchParentVisited(tree,  root, Integer.parseInt(button.getText()));
					searchFellowChildVisited(tree,  root, Integer.parseInt(button.getText()));
	
				} catch (Exception e) 
				{
					e.printStackTrace();
				}
				
				
				//if parent not visited yet
				if(!searchResult)
				{
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: Parent of Choice not selected yet.", graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
			        return;
					
				}else
				if(!searchChildResult)//now check if a fellow child has already been chosen
				{
								
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: You cannot choose more than one choice at the same depth", graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
			        return;
					
					
				}else
				if(button.getTextFill() == null)//if button viable
				{
					//opens main menu
					InfoPane root = new InfoPane(elem, button, graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Info");
			        secondStage.show();
					
				}else
				if(button.getTextFill().equals(Color.BLUE))//if buttons already been selected
				{
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: This option has already been selected.", graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
				}else
				{

					
				}
			}			
		});
	}
	
	public static void addEdge(int xP, int yP,int x, int y, Position<Vertex<Choice>> choice, int arrowPlacement)
	{	

		int posChange = 30;
		int midpointX = (xP+x+2*posChange)/2;
		int midpointY = (yP+y+2*posChange)/2;
		//System.out.println(xP +"-"+yP+"-"+x+"-"+y);
		//create line/edge from start to end
		Line line = new Line(xP+posChange, yP+posChange, x+posChange, y+posChange);
		Label lblWeight = new Label(""+choice.element().getWeight());
		lblWeight.setLayoutX(midpointX);
		lblWeight.setLayoutY(midpointY);
		
		//create directional arrow on line
		//Line arrowUp = new Line(x+15, y+25, x+30, y+30);
		//Line arrowDown = new Line(x+25, y+15, x+30, y+30);
		

		//if(xP != x && yP != y)
		{
			if(arrowPlacement > choice.element().getValue().getArrow())//upper bound
			{
				Polygon polygon = new Polygon();
		        polygon.getPoints().addAll(new Double[]{
		        		(double) (midpointX-15),(double) midpointY+10,
		        		(double) midpointX,(double) midpointY+15,
		        		(double) midpointX, (double) midpointY,
		        });

				pane.getChildren().add(polygon);

	
			}else
			if(arrowPlacement == choice.element().getValue().getArrow())//middle bound
			{

				Polygon polygon = new Polygon();
		        polygon.getPoints().addAll(new Double[]{
		        		(double) (midpointX-20),(double) midpointY-10,
		        		(double) midpointX,(double) midpointY,
		        		(double) midpointX-20, (double) midpointY+10,
		        });

				pane.getChildren().add(polygon);
				
			}else
			if(arrowPlacement < choice.element().getValue().getArrow())//lower bound
			{
				
				Polygon polygon = new Polygon();
		        polygon.getPoints().addAll(new Double[]{
		        		(double) (midpointX),(double) midpointY-20,
		        		(double) midpointX,(double) midpointY,
		        		(double) midpointX-20, (double) midpointY-10,
		        });

				pane.getChildren().add(polygon);
			}
		}
		//add line to pane
		//pane.getChildren().add(arrowUp);
		//pane.getChildren().add(arrowDown);
		pane.getChildren().add(line);
		pane.getChildren().add(lblWeight);
	}
	

	static int loop = 0;
	static int iteration = 1;
	static boolean endFound = false;

	private static void displayNodes(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice) throws Exception 
	{
		
		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);

		if(tree.parent(choice).get(0) == null)
		{
			choice.element().getValue().setX(0);
			choice.element().getValue().setY((int)scrollPane.getPrefHeight()/2);
			choice.element().getValue().setArrow(0);
			
			addNode(0, choice.element().getValue().getY(), choice);
		}
		
		while(iterator.hasNext())
		{
			//counts at which child you are currently at
			loop++;
			
			if(loop==3)
			{
				loop = 1;
			}
			
			Position<Vertex<Choice>> position = iterator.next();
			
			if(position.element().getValue().getDisplayed())
			{
				//System.out.println(position.toString() +"    ddddddd");
			}	
			else
			{
			
			//get depth which is the x axis
			int depth = tree.depth(tree, position);
			
			//calcuate y
			double numChild = tree.getNumChildren(tree.parent(position).get(0));


			
			int parentChoice = 0;
			//determines how a child of one parents should look

			if(tree.parent(position).size() == 1)
			{
				parentChoice = 0;
			}else
			if(tree.parent(position).size() % 2 == 0)//determines how a child of many parents should look - if even
			{
					parentChoice = tree.getNumChildren(tree.parent(position).get(0))/2;
					
				}else//determines how a child of many parents should look - if odd
				{
					
					parentChoice = (int)(tree.getNumChildren(tree.parent(position).get(0))/2+0.5);
					
				}
				
				//this is the # in order ofwhen the child was added to a parent
				int childNum = position.element().getValue().getChildNum();
				if(numChild <= 1)
				{
					
					position.element().getValue().setY(root.element().getValue().getY());
					position.element().getValue().setArrow(0);
				}
				else
				if(numChild/2 >= childNum || childNum==1)//in lower bound of loop
				{
					
					//set above parent
					position.element().getValue().setY(tree.parent(position).get(0).element().getValue().getY()-200/childNum);
					position.element().getValue().setArrow(-1);
					
				}else
				if(numChild/2 == childNum || numChild/2 == childNum-0.5)//at centre of loop
				{
	
					//set same as parent Y axis
					position.element().getValue().setY(tree.parent(position).get(0).element().getValue().getY());
					position.element().getValue().setArrow(0);
	
				}else
				{
					if((numChild+1-childNum) <= 0)
					{
						//set below parent
						position.element().getValue().setY((int)(tree.parent(position).get(0).element().getValue().getY()+200/(-numChild+1+childNum)));
						position.element().getValue().setArrow(1);
					}else
					{
						//set below parent
						position.element().getValue().setY((int)(tree.parent(position).get(0).element().getValue().getY()+200/(numChild+1-childNum)));
						position.element().getValue().setArrow(1);
					}
					
					
				}
						
	
				/*if(position.element().getValue().getID() == 7)
				{
					System.out.println("numPdasdasasdsad "+ tree.parent(position).size());
				}*/
				
				position.element().getValue().setX(depth*100);
				if(position.element().getValue().getY() > 1000)
				{
					System.out.println("\nID " + position.element().getValue().getID()+"   X: "+ position.element().getValue().getX()+"   Y: "+position.element().getValue().getY());
					System.out.println("loop " + loop+"   numChild: "+numChild+"\n");
				}
				
				
				//add nodes
				addNode(position.element().getValue().getX(), position.element().getValue().getY(),position);
				position.element().getValue().setDisplayed(true);
				//add all edges - can have many parents
				/*
				if(tree.getNumChildren(position) == 0)
				{
					loop = 0;
					endFound = true;
					iteration++;
				}*/
			}
			

			
			displayNodes(tree, position);
			
		}
		
	}
	
	
	
	private static void displayEdge(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice) throws Exception 
	{
		
		
		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);
		
		while(iterator.hasNext())
		{	
			Position<Vertex<Choice>> position = iterator.next();
			
			Iterator<Position<Vertex<Choice>>> iteratorC = tree.children(position);
			//to add root
			if(tree.parent(choice).get(0) == null)
			{

				addEdge(position.element().getValue().getX(),position.element().getValue().getY(),choice.element().getValue().getX(),choice.element().getValue().getY(),position,choice.element().getValue().getArrow());
			}
			
			while(iteratorC.hasNext())
			{		
				Position<Vertex<Choice>> c = iteratorC.next();
				addEdge(c.element().getValue().getX(),c.element().getValue().getY(),position.element().getValue().getX(),position.element().getValue().getY(),c,position.element().getValue().getArrow());
			}
			
				displayEdge(tree, position);
			
		}
		
	}

	static boolean searchResult;
	private static void searchParentVisited(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice, int id) throws Exception 
	{
		if(searchResult)
		{
			return;
		}
		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);
		//checks if root
		/*if(tree.parent(choice).get(0) == null)
		{
			//checks if root is search id
			if(id == root.element().id)
			{
				searchResult = true;
				return;
			}
		}*/
		
		while(iterator.hasNext())
		{
			if(searchResult)
			{
				return;
			}
			
			if(id == root.element().getValue().getID())
			{
				searchResult = true;
				return;
			}

			Position<Vertex<Choice>> position = iterator.next();
			
			//checks if correct node is found
			
			
			
			if(id == position.element().getValue().getID())
			{
				

				//checks if parent node has been visited before

				for(Position<Vertex<Choice>> c : tree.parent(position))
				{
					//searchResult = c.element().getVisited();

					if(c.element().getValue().getVisited())
					{
						searchResult = true;
						return;
					}
				}
				
			}
			
			searchParentVisited(tree, position, id);	
		}	
	}
	
	static boolean searchChildResult;
	private static void searchFellowChildVisited(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice, int id) throws Exception 
	{

		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);
		//checks if root
		if(tree.parent(choice).get(0) == null)
		{
			//checks if root is search id
			if(id == root.element().getValue().getID())
			{
				//System.out.println("root found");
				searchChildResult = true;
				return;
			}
		}
		
		while(iterator.hasNext())
		{
			
			Position<Vertex<Choice>> position = iterator.next();
			//checks if correct node is found
			if(id == position.element().getValue().getID())
			{

				//goes over all children of that paren
				Iterator<Position<Vertex<Choice>>> iteratorChild = tree.children(tree.parent(position).get(0));
				
				while(iteratorChild.hasNext())
				{
					
					Position<Vertex<Choice>> positionChild = iteratorChild.next();
					//System.out.println(positionChild.element().getID() + "  "+ positionChild.element().getVisited());
					//if child visited, return false
					if(positionChild.element().getValue().getVisited())
					{
						searchChildResult = false;
						return;
					}
				}
					

				
			}
			
			searchFellowChildVisited(tree, position, id);	
		}	
		//System.out.println("failure");
		
	}

	
	private static void printChoices()
	{
		for(Position<Vertex<Choice>> p : vertexPath)
		{
			
			System.out.println(p.element().getValue().toString() + "\n");
		}
	}
	
	private static void shortestPath(Position<Vertex<Choice>> lastPosition) throws Exception
	{
		

		Iterator<Position<Vertex<Choice>>> iterator = tree.children(lastPosition);
		
		while(iterator.hasNext())
		{
			Vertex<Choice>>> childPosition 
		}
		if(!vertexPath.isEmpty())
		{
			
			Position<Vertex<Choice>> lastVertex = vertexPath.get(vertexPath.size()-1);
			
		}

	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-04-19 12:54:25.280
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-04-19 12:54:25.282
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-19 12:54:25.381
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------


import java.util.ArrayList;
import java.util.Iterator;

import com.jwetherell.algorithms.data_structures.Graph;
import com.jwetherell.algorithms.data_structures.Graph.Vertex;

import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.TextArea;
import javafx.scene.input.MouseDragEvent;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.Pane;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Line;
import javafx.scene.shape.Polygon;
import javafx.scene.shape.Shape;
import javafx.stage.Stage;
import javafx.stage.StageStyle;

public class GraphPane extends StackPane
{
	static Pane pane;
	static int total;
	static TextArea txtTotal;
	static TextArea txtDisplay;
	static GridPane gridPane;
	static GraphPane graphPane;
	static Tree<Vertex<Choice>> tree;
	static Position<Vertex<Choice>> root;
	static ScrollPane scrollPane;
	
	static ArrayList<Position<Vertex<Choice>>> vertexPath = new ArrayList<Position<Vertex<Choice>>>();
	static ArrayList<Button> choicePath = new ArrayList<Button>();
	static int choiceNumber = -1;
	
	public GraphPane()
	{
		
		graphPane = this;
		gridPane = new GridPane();
		//setting vbox/controls
		VBox vbox = new VBox();
		vbox.setMaxSize(800, 800);
		//setting pane/graph
		pane = new Pane();
		pane.setPrefSize(2000, 2000);
		
		//scrollpane
		scrollPane = new ScrollPane();
		scrollPane.setContent(pane);
		scrollPane.setPrefSize(600, 600);
		//adding both to main borderpane for layout



		
		//adding controls to vbox
		Label lblTotal = new Label("Total:");
		txtTotal = new TextArea();
		txtTotal.setPrefSize(getPrefWidth(), 20);
		
		Label lblDisplay = new Label("Display:");
		txtDisplay = new TextArea();
		txtDisplay.setPrefSize(getPrefWidth(), 20);
		
		//add buttons
		
		Button btnGoBack = new Button("Go Back One Choice");
		btnGoBack.setPrefSize(200, 30);
		
		Button btnDisplayChoices = new Button("Display Current Choices Info");
		btnDisplayChoices.setPrefSize(200, 30);


		
		gridPane.add(lblTotal, 0, 0);
		gridPane.add(txtTotal, 0, 1);
		gridPane.add(lblDisplay, 0, 2);
		gridPane.add(txtDisplay, 0, 3);
		gridPane.add(btnGoBack, 0, 4);
		gridPane.add(btnDisplayChoices, 1, 4);
		
		vbox.getChildren().add(gridPane);
		vbox.getChildren().add(scrollPane);
		
		this.getChildren().add(vbox);
		
		//generate tree and fill it
		ModifyTree modifyTree = new ModifyTree();
		
		tree = modifyTree.getTree();
		root = modifyTree.getRoot();
		
		try 
		{
			displayNodes(tree, root);
			displayEdge(tree, root);
			//System.out.println(tree.preOrderElementTraversal(tree, root));
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		//set buttons actipns
		
		btnGoBack.setOnAction(new EventHandler <ActionEvent>()
		{
			@Override
			public void handle(ActionEvent event) 
			{
				goBack();
			}		
		});
		
		btnDisplayChoices.setOnAction(new EventHandler <ActionEvent>()
		{
			@Override
			public void handle(ActionEvent event) 
			{
				//shortestPath();
				printChoices();
			}		
		});
		

		////
		
	}
	
	public static void goBack()
	{
		
		//if choice exists
		if(choiceNumber > -1)
		{
			//go back one on button
			Button button = choicePath.get(choiceNumber);
			button.setTextFill(null);
			button.setStyle("-fx-background-color: BLACK");
			System.out.println(button.getText());
			//go back on 
			Position<Vertex<Choice>> vertex = vertexPath.get(choiceNumber);
			vertex.element().getValue().setDisplayed(false);
			vertex.element().getValue().setVisited(false);
			
			//now get rid of button and vertex from list
			vertexPath.remove(choiceNumber);
			choicePath.remove(choiceNumber);
			
			total -= vertex.element().getWeight();
			txtTotal.setText("R"+total);
			choiceNumber--;
			
			
		}else
		{
			graphPane.setVisible(false);
			//go to error pane
			ErrorPane root = new ErrorPane("ERROR: There is no node selected to undo.", graphPane);
			Stage secondStage = new Stage();
			
			//secondStage.initStyle(StageStyle.UNDECORATED);
	        secondStage.setScene(new Scene(root));
	        secondStage.setTitle("Error");
	        secondStage.show();
	        return;
		}

	}
	
	public void addToPath(Position<Vertex<Choice>> elem,Button button)
	{
		vertexPath.add(elem);
		choicePath.add(button);
		choiceNumber++;
		
		total += elem.element().getWeight();
		txtTotal.setText("R"+total);
	}
	
	final static int nodeSize = 50;
	final static int edgeSize = 50;
	public static void addNode(int x, int y, Position<Vertex<Choice>> elem)
	{
		
		Button button = new Button(""+elem.element().getValue().getID());
		button.setShape(new Circle(10));
		button.setPrefSize(nodeSize,nodeSize);
		button.setLayoutX(x);
		button.setLayoutY(y);
		button.setTextFill(null);
		button.setStyle("-fx-background-color: BLACK");
		
		Label lblName = new Label(elem.element().getValue().getName());
		lblName.setLayoutX(x);
		lblName.setLayoutY(y-15);
		
		pane.getChildren().add(lblName);
		pane.getChildren().add(button);
		

		button.setOnAction(new EventHandler <ActionEvent>()
		{
			
			@Override
			public void handle(ActionEvent event) 
			{
				//total += elem;
				txtTotal.setText(""+total);
				graphPane.setVisible(false);
				
				//this is to search if parent has been visisted
				searchResult = false;
				//this is to search if a fellow child has been visited
				searchChildResult = true;
				try 
				{
					searchParentVisited(tree,  root, Integer.parseInt(button.getText()));
					searchFellowChildVisited(tree,  root, Integer.parseInt(button.getText()));
	
				} catch (Exception e) 
				{
					e.printStackTrace();
				}
				
				
				//if parent not visited yet
				if(!searchResult)
				{
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: Parent of Choice not selected yet.", graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
			        return;
					
				}else
				if(!searchChildResult)//now check if a fellow child has already been chosen
				{
								
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: You cannot choose more than one choice at the same depth", graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
			        return;
					
					
				}else
				if(button.getTextFill() == null)//if button viable
				{
					//opens main menu
					InfoPane root = new InfoPane(elem, button, graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Info");
			        secondStage.show();
					
				}else
				if(button.getTextFill().equals(Color.BLUE))//if buttons already been selected
				{
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: This option has already been selected.", graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
				}else
				{

					
				}
			}			
		});
	}
	
	public static void addEdge(int xP, int yP,int x, int y, Position<Vertex<Choice>> choice, int arrowPlacement)
	{	

		int posChange = 30;
		int midpointX = (xP+x+2*posChange)/2;
		int midpointY = (yP+y+2*posChange)/2;
		//System.out.println(xP +"-"+yP+"-"+x+"-"+y);
		//create line/edge from start to end
		Line line = new Line(xP+posChange, yP+posChange, x+posChange, y+posChange);
		Label lblWeight = new Label(""+choice.element().getWeight());
		lblWeight.setLayoutX(midpointX);
		lblWeight.setLayoutY(midpointY);
		
		//create directional arrow on line
		//Line arrowUp = new Line(x+15, y+25, x+30, y+30);
		//Line arrowDown = new Line(x+25, y+15, x+30, y+30);
		

		//if(xP != x && yP != y)
		{
			if(arrowPlacement > choice.element().getValue().getArrow())//upper bound
			{
				Polygon polygon = new Polygon();
		        polygon.getPoints().addAll(new Double[]{
		        		(double) (midpointX-15),(double) midpointY+10,
		        		(double) midpointX,(double) midpointY+15,
		        		(double) midpointX, (double) midpointY,
		        });

				pane.getChildren().add(polygon);

	
			}else
			if(arrowPlacement == choice.element().getValue().getArrow())//middle bound
			{

				Polygon polygon = new Polygon();
		        polygon.getPoints().addAll(new Double[]{
		        		(double) (midpointX-20),(double) midpointY-10,
		        		(double) midpointX,(double) midpointY,
		        		(double) midpointX-20, (double) midpointY+10,
		        });

				pane.getChildren().add(polygon);
				
			}else
			if(arrowPlacement < choice.element().getValue().getArrow())//lower bound
			{
				
				Polygon polygon = new Polygon();
		        polygon.getPoints().addAll(new Double[]{
		        		(double) (midpointX),(double) midpointY-20,
		        		(double) midpointX,(double) midpointY,
		        		(double) midpointX-20, (double) midpointY-10,
		        });

				pane.getChildren().add(polygon);
			}
		}
		//add line to pane
		//pane.getChildren().add(arrowUp);
		//pane.getChildren().add(arrowDown);
		pane.getChildren().add(line);
		pane.getChildren().add(lblWeight);
	}
	

	static int loop = 0;
	static int iteration = 1;
	static boolean endFound = false;

	private static void displayNodes(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice) throws Exception 
	{
		
		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);

		if(tree.parent(choice).get(0) == null)
		{
			choice.element().getValue().setX(0);
			choice.element().getValue().setY((int)scrollPane.getPrefHeight()/2);
			choice.element().getValue().setArrow(0);
			
			addNode(0, choice.element().getValue().getY(), choice);
		}
		
		while(iterator.hasNext())
		{
			//counts at which child you are currently at
			loop++;
			
			if(loop==3)
			{
				loop = 1;
			}
			
			Position<Vertex<Choice>> position = iterator.next();
			
			if(position.element().getValue().getDisplayed())
			{
				//System.out.println(position.toString() +"    ddddddd");
			}	
			else
			{
			
			//get depth which is the x axis
			int depth = tree.depth(tree, position);
			
			//calcuate y
			double numChild = tree.getNumChildren(tree.parent(position).get(0));


			
			int parentChoice = 0;
			//determines how a child of one parents should look

			if(tree.parent(position).size() == 1)
			{
				parentChoice = 0;
			}else
			if(tree.parent(position).size() % 2 == 0)//determines how a child of many parents should look - if even
			{
					parentChoice = tree.getNumChildren(tree.parent(position).get(0))/2;
					
				}else//determines how a child of many parents should look - if odd
				{
					
					parentChoice = (int)(tree.getNumChildren(tree.parent(position).get(0))/2+0.5);
					
				}
				
				//this is the # in order ofwhen the child was added to a parent
				int childNum = position.element().getValue().getChildNum();
				if(numChild <= 1)
				{
					
					position.element().getValue().setY(root.element().getValue().getY());
					position.element().getValue().setArrow(0);
				}
				else
				if(numChild/2 >= childNum || childNum==1)//in lower bound of loop
				{
					
					//set above parent
					position.element().getValue().setY(tree.parent(position).get(0).element().getValue().getY()-200/childNum);
					position.element().getValue().setArrow(-1);
					
				}else
				if(numChild/2 == childNum || numChild/2 == childNum-0.5)//at centre of loop
				{
	
					//set same as parent Y axis
					position.element().getValue().setY(tree.parent(position).get(0).element().getValue().getY());
					position.element().getValue().setArrow(0);
	
				}else
				{
					if((numChild+1-childNum) <= 0)
					{
						//set below parent
						position.element().getValue().setY((int)(tree.parent(position).get(0).element().getValue().getY()+200/(-numChild+1+childNum)));
						position.element().getValue().setArrow(1);
					}else
					{
						//set below parent
						position.element().getValue().setY((int)(tree.parent(position).get(0).element().getValue().getY()+200/(numChild+1-childNum)));
						position.element().getValue().setArrow(1);
					}
					
					
				}
						
	
				/*if(position.element().getValue().getID() == 7)
				{
					System.out.println("numPdasdasasdsad "+ tree.parent(position).size());
				}*/
				
				position.element().getValue().setX(depth*100);
				if(position.element().getValue().getY() > 1000)
				{
					System.out.println("\nID " + position.element().getValue().getID()+"   X: "+ position.element().getValue().getX()+"   Y: "+position.element().getValue().getY());
					System.out.println("loop " + loop+"   numChild: "+numChild+"\n");
				}
				
				
				//add nodes
				addNode(position.element().getValue().getX(), position.element().getValue().getY(),position);
				position.element().getValue().setDisplayed(true);
				//add all edges - can have many parents
				/*
				if(tree.getNumChildren(position) == 0)
				{
					loop = 0;
					endFound = true;
					iteration++;
				}*/
			}
			

			
			displayNodes(tree, position);
			
		}
		
	}
	
	
	
	private static void displayEdge(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice) throws Exception 
	{
		
		
		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);
		
		while(iterator.hasNext())
		{	
			Position<Vertex<Choice>> position = iterator.next();
			
			Iterator<Position<Vertex<Choice>>> iteratorC = tree.children(position);
			//to add root
			if(tree.parent(choice).get(0) == null)
			{

				addEdge(position.element().getValue().getX(),position.element().getValue().getY(),choice.element().getValue().getX(),choice.element().getValue().getY(),position,choice.element().getValue().getArrow());
			}
			
			while(iteratorC.hasNext())
			{		
				Position<Vertex<Choice>> c = iteratorC.next();
				addEdge(c.element().getValue().getX(),c.element().getValue().getY(),position.element().getValue().getX(),position.element().getValue().getY(),c,position.element().getValue().getArrow());
			}
			
				displayEdge(tree, position);
			
		}
		
	}

	static boolean searchResult;
	private static void searchParentVisited(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice, int id) throws Exception 
	{
		if(searchResult)
		{
			return;
		}
		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);
		//checks if root
		/*if(tree.parent(choice).get(0) == null)
		{
			//checks if root is search id
			if(id == root.element().id)
			{
				searchResult = true;
				return;
			}
		}*/
		
		while(iterator.hasNext())
		{
			if(searchResult)
			{
				return;
			}
			
			if(id == root.element().getValue().getID())
			{
				searchResult = true;
				return;
			}

			Position<Vertex<Choice>> position = iterator.next();
			
			//checks if correct node is found
			
			
			
			if(id == position.element().getValue().getID())
			{
				

				//checks if parent node has been visited before

				for(Position<Vertex<Choice>> c : tree.parent(position))
				{
					//searchResult = c.element().getVisited();

					if(c.element().getValue().getVisited())
					{
						searchResult = true;
						return;
					}
				}
				
			}
			
			searchParentVisited(tree, position, id);	
		}	
	}
	
	static boolean searchChildResult;
	private static void searchFellowChildVisited(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice, int id) throws Exception 
	{

		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);
		//checks if root
		if(tree.parent(choice).get(0) == null)
		{
			//checks if root is search id
			if(id == root.element().getValue().getID())
			{
				//System.out.println("root found");
				searchChildResult = true;
				return;
			}
		}
		
		while(iterator.hasNext())
		{
			
			Position<Vertex<Choice>> position = iterator.next();
			//checks if correct node is found
			if(id == position.element().getValue().getID())
			{

				//goes over all children of that paren
				Iterator<Position<Vertex<Choice>>> iteratorChild = tree.children(tree.parent(position).get(0));
				
				while(iteratorChild.hasNext())
				{
					
					Position<Vertex<Choice>> positionChild = iteratorChild.next();
					//System.out.println(positionChild.element().getID() + "  "+ positionChild.element().getVisited());
					//if child visited, return false
					if(positionChild.element().getValue().getVisited())
					{
						searchChildResult = false;
						return;
					}
				}
					

				
			}
			
			searchFellowChildVisited(tree, position, id);	
		}	
		//System.out.println("failure");
		
	}

	
	private static void printChoices()
	{
		for(Position<Vertex<Choice>> p : vertexPath)
		{
			
			System.out.println(p.element().getValue().toString() + "\n");
		}
	}
	
	private static void shortestPath(Position<Vertex<Choice>> lastPosition) throws Exception
	{
		

		Iterator<Position<Vertex<Choice>>> iterator = tree.children(lastPosition);
		
		while(iterator.hasNext())
		{
			Vertex<Choice>>> childPosition 
		}
		if(!vertexPath.isEmpty())
		{
			
			Position<Vertex<Choice>> lastVertex = vertexPath.get(vertexPath.size()-1);
			
		}

	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-19 12:54:25.382
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-19 12:54:25.383
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-19 12:54:27.950
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------


import java.util.ArrayList;
import java.util.Iterator;

import com.jwetherell.algorithms.data_structures.Graph;
import com.jwetherell.algorithms.data_structures.Graph.Vertex;

import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.TextArea;
import javafx.scene.input.MouseDragEvent;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.Pane;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Line;
import javafx.scene.shape.Polygon;
import javafx.scene.shape.Shape;
import javafx.stage.Stage;
import javafx.stage.StageStyle;

public class GraphPane extends StackPane
{
	static Pane pane;
	static int total;
	static TextArea txtTotal;
	static TextArea txtDisplay;
	static GridPane gridPane;
	static GraphPane graphPane;
	static Tree<Vertex<Choice>> tree;
	static Position<Vertex<Choice>> root;
	static ScrollPane scrollPane;
	
	static ArrayList<Position<Vertex<Choice>>> vertexPath = new ArrayList<Position<Vertex<Choice>>>();
	static ArrayList<Button> choicePath = new ArrayList<Button>();
	static int choiceNumber = -1;
	
	public GraphPane()
	{
		
		graphPane = this;
		gridPane = new GridPane();
		//setting vbox/controls
		VBox vbox = new VBox();
		vbox.setMaxSize(800, 800);
		//setting pane/graph
		pane = new Pane();
		pane.setPrefSize(2000, 2000);
		
		//scrollpane
		scrollPane = new ScrollPane();
		scrollPane.setContent(pane);
		scrollPane.setPrefSize(600, 600);
		//adding both to main borderpane for layout



		
		//adding controls to vbox
		Label lblTotal = new Label("Total:");
		txtTotal = new TextArea();
		txtTotal.setPrefSize(getPrefWidth(), 20);
		
		Label lblDisplay = new Label("Display:");
		txtDisplay = new TextArea();
		txtDisplay.setPrefSize(getPrefWidth(), 20);
		
		//add buttons
		
		Button btnGoBack = new Button("Go Back One Choice");
		btnGoBack.setPrefSize(200, 30);
		
		Button btnDisplayChoices = new Button("Display Current Choices Info");
		btnDisplayChoices.setPrefSize(200, 30);


		
		gridPane.add(lblTotal, 0, 0);
		gridPane.add(txtTotal, 0, 1);
		gridPane.add(lblDisplay, 0, 2);
		gridPane.add(txtDisplay, 0, 3);
		gridPane.add(btnGoBack, 0, 4);
		gridPane.add(btnDisplayChoices, 1, 4);
		
		vbox.getChildren().add(gridPane);
		vbox.getChildren().add(scrollPane);
		
		this.getChildren().add(vbox);
		
		//generate tree and fill it
		ModifyTree modifyTree = new ModifyTree();
		
		tree = modifyTree.getTree();
		root = modifyTree.getRoot();
		
		try 
		{
			displayNodes(tree, root);
			displayEdge(tree, root);
			//System.out.println(tree.preOrderElementTraversal(tree, root));
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		//set buttons actipns
		
		btnGoBack.setOnAction(new EventHandler <ActionEvent>()
		{
			@Override
			public void handle(ActionEvent event) 
			{
				goBack();
			}		
		});
		
		btnDisplayChoices.setOnAction(new EventHandler <ActionEvent>()
		{
			@Override
			public void handle(ActionEvent event) 
			{
				//shortestPath();
				printChoices();
			}		
		});
		

		////
		
	}
	
	public static void goBack()
	{
		
		//if choice exists
		if(choiceNumber > -1)
		{
			//go back one on button
			Button button = choicePath.get(choiceNumber);
			button.setTextFill(null);
			button.setStyle("-fx-background-color: BLACK");
			System.out.println(button.getText());
			//go back on 
			Position<Vertex<Choice>> vertex = vertexPath.get(choiceNumber);
			vertex.element().getValue().setDisplayed(false);
			vertex.element().getValue().setVisited(false);
			
			//now get rid of button and vertex from list
			vertexPath.remove(choiceNumber);
			choicePath.remove(choiceNumber);
			
			total -= vertex.element().getWeight();
			txtTotal.setText("R"+total);
			choiceNumber--;
			
			
		}else
		{
			graphPane.setVisible(false);
			//go to error pane
			ErrorPane root = new ErrorPane("ERROR: There is no node selected to undo.", graphPane);
			Stage secondStage = new Stage();
			
			//secondStage.initStyle(StageStyle.UNDECORATED);
	        secondStage.setScene(new Scene(root));
	        secondStage.setTitle("Error");
	        secondStage.show();
	        return;
		}

	}
	
	public void addToPath(Position<Vertex<Choice>> elem,Button button)
	{
		vertexPath.add(elem);
		choicePath.add(button);
		choiceNumber++;
		
		total += elem.element().getWeight();
		txtTotal.setText("R"+total);
	}
	
	final static int nodeSize = 50;
	final static int edgeSize = 50;
	public static void addNode(int x, int y, Position<Vertex<Choice>> elem)
	{
		
		Button button = new Button(""+elem.element().getValue().getID());
		button.setShape(new Circle(10));
		button.setPrefSize(nodeSize,nodeSize);
		button.setLayoutX(x);
		button.setLayoutY(y);
		button.setTextFill(null);
		button.setStyle("-fx-background-color: BLACK");
		
		Label lblName = new Label(elem.element().getValue().getName());
		lblName.setLayoutX(x);
		lblName.setLayoutY(y-15);
		
		pane.getChildren().add(lblName);
		pane.getChildren().add(button);
		

		button.setOnAction(new EventHandler <ActionEvent>()
		{
			
			@Override
			public void handle(ActionEvent event) 
			{
				//total += elem;
				txtTotal.setText(""+total);
				graphPane.setVisible(false);
				
				//this is to search if parent has been visisted
				searchResult = false;
				//this is to search if a fellow child has been visited
				searchChildResult = true;
				try 
				{
					searchParentVisited(tree,  root, Integer.parseInt(button.getText()));
					searchFellowChildVisited(tree,  root, Integer.parseInt(button.getText()));
	
				} catch (Exception e) 
				{
					e.printStackTrace();
				}
				
				
				//if parent not visited yet
				if(!searchResult)
				{
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: Parent of Choice not selected yet.", graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
			        return;
					
				}else
				if(!searchChildResult)//now check if a fellow child has already been chosen
				{
								
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: You cannot choose more than one choice at the same depth", graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
			        return;
					
					
				}else
				if(button.getTextFill() == null)//if button viable
				{
					//opens main menu
					InfoPane root = new InfoPane(elem, button, graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Info");
			        secondStage.show();
					
				}else
				if(button.getTextFill().equals(Color.BLUE))//if buttons already been selected
				{
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: This option has already been selected.", graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
				}else
				{

					
				}
			}			
		});
	}
	
	public static void addEdge(int xP, int yP,int x, int y, Position<Vertex<Choice>> choice, int arrowPlacement)
	{	

		int posChange = 30;
		int midpointX = (xP+x+2*posChange)/2;
		int midpointY = (yP+y+2*posChange)/2;
		//System.out.println(xP +"-"+yP+"-"+x+"-"+y);
		//create line/edge from start to end
		Line line = new Line(xP+posChange, yP+posChange, x+posChange, y+posChange);
		Label lblWeight = new Label(""+choice.element().getWeight());
		lblWeight.setLayoutX(midpointX);
		lblWeight.setLayoutY(midpointY);
		
		//create directional arrow on line
		//Line arrowUp = new Line(x+15, y+25, x+30, y+30);
		//Line arrowDown = new Line(x+25, y+15, x+30, y+30);
		

		//if(xP != x && yP != y)
		{
			if(arrowPlacement > choice.element().getValue().getArrow())//upper bound
			{
				Polygon polygon = new Polygon();
		        polygon.getPoints().addAll(new Double[]{
		        		(double) (midpointX-15),(double) midpointY+10,
		        		(double) midpointX,(double) midpointY+15,
		        		(double) midpointX, (double) midpointY,
		        });

				pane.getChildren().add(polygon);

	
			}else
			if(arrowPlacement == choice.element().getValue().getArrow())//middle bound
			{

				Polygon polygon = new Polygon();
		        polygon.getPoints().addAll(new Double[]{
		        		(double) (midpointX-20),(double) midpointY-10,
		        		(double) midpointX,(double) midpointY,
		        		(double) midpointX-20, (double) midpointY+10,
		        });

				pane.getChildren().add(polygon);
				
			}else
			if(arrowPlacement < choice.element().getValue().getArrow())//lower bound
			{
				
				Polygon polygon = new Polygon();
		        polygon.getPoints().addAll(new Double[]{
		        		(double) (midpointX),(double) midpointY-20,
		        		(double) midpointX,(double) midpointY,
		        		(double) midpointX-20, (double) midpointY-10,
		        });

				pane.getChildren().add(polygon);
			}
		}
		//add line to pane
		//pane.getChildren().add(arrowUp);
		//pane.getChildren().add(arrowDown);
		pane.getChildren().add(line);
		pane.getChildren().add(lblWeight);
	}
	

	static int loop = 0;
	static int iteration = 1;
	static boolean endFound = false;

	private static void displayNodes(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice) throws Exception 
	{
		
		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);

		if(tree.parent(choice).get(0) == null)
		{
			choice.element().getValue().setX(0);
			choice.element().getValue().setY((int)scrollPane.getPrefHeight()/2);
			choice.element().getValue().setArrow(0);
			
			addNode(0, choice.element().getValue().getY(), choice);
		}
		
		while(iterator.hasNext())
		{
			//counts at which child you are currently at
			loop++;
			
			if(loop==3)
			{
				loop = 1;
			}
			
			Position<Vertex<Choice>> position = iterator.next();
			
			if(position.element().getValue().getDisplayed())
			{
				//System.out.println(position.toString() +"    ddddddd");
			}	
			else
			{
			
			//get depth which is the x axis
			int depth = tree.depth(tree, position);
			
			//calcuate y
			double numChild = tree.getNumChildren(tree.parent(position).get(0));


			
			int parentChoice = 0;
			//determines how a child of one parents should look

			if(tree.parent(position).size() == 1)
			{
				parentChoice = 0;
			}else
			if(tree.parent(position).size() % 2 == 0)//determines how a child of many parents should look - if even
			{
					parentChoice = tree.getNumChildren(tree.parent(position).get(0))/2;
					
				}else//determines how a child of many parents should look - if odd
				{
					
					parentChoice = (int)(tree.getNumChildren(tree.parent(position).get(0))/2+0.5);
					
				}
				
				//this is the # in order ofwhen the child was added to a parent
				int childNum = position.element().getValue().getChildNum();
				if(numChild <= 1)
				{
					
					position.element().getValue().setY(root.element().getValue().getY());
					position.element().getValue().setArrow(0);
				}
				else
				if(numChild/2 >= childNum || childNum==1)//in lower bound of loop
				{
					
					//set above parent
					position.element().getValue().setY(tree.parent(position).get(0).element().getValue().getY()-200/childNum);
					position.element().getValue().setArrow(-1);
					
				}else
				if(numChild/2 == childNum || numChild/2 == childNum-0.5)//at centre of loop
				{
	
					//set same as parent Y axis
					position.element().getValue().setY(tree.parent(position).get(0).element().getValue().getY());
					position.element().getValue().setArrow(0);
	
				}else
				{
					if((numChild+1-childNum) <= 0)
					{
						//set below parent
						position.element().getValue().setY((int)(tree.parent(position).get(0).element().getValue().getY()+200/(-numChild+1+childNum)));
						position.element().getValue().setArrow(1);
					}else
					{
						//set below parent
						position.element().getValue().setY((int)(tree.parent(position).get(0).element().getValue().getY()+200/(numChild+1-childNum)));
						position.element().getValue().setArrow(1);
					}
					
					
				}
						
	
				/*if(position.element().getValue().getID() == 7)
				{
					System.out.println("numPdasdasasdsad "+ tree.parent(position).size());
				}*/
				
				position.element().getValue().setX(depth*100);
				if(position.element().getValue().getY() > 1000)
				{
					System.out.println("\nID " + position.element().getValue().getID()+"   X: "+ position.element().getValue().getX()+"   Y: "+position.element().getValue().getY());
					System.out.println("loop " + loop+"   numChild: "+numChild+"\n");
				}
				
				
				//add nodes
				addNode(position.element().getValue().getX(), position.element().getValue().getY(),position);
				position.element().getValue().setDisplayed(true);
				//add all edges - can have many parents
				/*
				if(tree.getNumChildren(position) == 0)
				{
					loop = 0;
					endFound = true;
					iteration++;
				}*/
			}
			

			
			displayNodes(tree, position);
			
		}
		
	}
	
	
	
	private static void displayEdge(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice) throws Exception 
	{
		
		
		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);
		
		while(iterator.hasNext())
		{	
			Position<Vertex<Choice>> position = iterator.next();
			
			Iterator<Position<Vertex<Choice>>> iteratorC = tree.children(position);
			//to add root
			if(tree.parent(choice).get(0) == null)
			{

				addEdge(position.element().getValue().getX(),position.element().getValue().getY(),choice.element().getValue().getX(),choice.element().getValue().getY(),position,choice.element().getValue().getArrow());
			}
			
			while(iteratorC.hasNext())
			{		
				Position<Vertex<Choice>> c = iteratorC.next();
				addEdge(c.element().getValue().getX(),c.element().getValue().getY(),position.element().getValue().getX(),position.element().getValue().getY(),c,position.element().getValue().getArrow());
			}
			
				displayEdge(tree, position);
			
		}
		
	}

	static boolean searchResult;
	private static void searchParentVisited(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice, int id) throws Exception 
	{
		if(searchResult)
		{
			return;
		}
		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);
		//checks if root
		/*if(tree.parent(choice).get(0) == null)
		{
			//checks if root is search id
			if(id == root.element().id)
			{
				searchResult = true;
				return;
			}
		}*/
		
		while(iterator.hasNext())
		{
			if(searchResult)
			{
				return;
			}
			
			if(id == root.element().getValue().getID())
			{
				searchResult = true;
				return;
			}

			Position<Vertex<Choice>> position = iterator.next();
			
			//checks if correct node is found
			
			
			
			if(id == position.element().getValue().getID())
			{
				

				//checks if parent node has been visited before

				for(Position<Vertex<Choice>> c : tree.parent(position))
				{
					//searchResult = c.element().getVisited();

					if(c.element().getValue().getVisited())
					{
						searchResult = true;
						return;
					}
				}
				
			}
			
			searchParentVisited(tree, position, id);	
		}	
	}
	
	static boolean searchChildResult;
	private static void searchFellowChildVisited(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice, int id) throws Exception 
	{

		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);
		//checks if root
		if(tree.parent(choice).get(0) == null)
		{
			//checks if root is search id
			if(id == root.element().getValue().getID())
			{
				//System.out.println("root found");
				searchChildResult = true;
				return;
			}
		}
		
		while(iterator.hasNext())
		{
			
			Position<Vertex<Choice>> position = iterator.next();
			//checks if correct node is found
			if(id == position.element().getValue().getID())
			{

				//goes over all children of that paren
				Iterator<Position<Vertex<Choice>>> iteratorChild = tree.children(tree.parent(position).get(0));
				
				while(iteratorChild.hasNext())
				{
					
					Position<Vertex<Choice>> positionChild = iteratorChild.next();
					//System.out.println(positionChild.element().getID() + "  "+ positionChild.element().getVisited());
					//if child visited, return false
					if(positionChild.element().getValue().getVisited())
					{
						searchChildResult = false;
						return;
					}
				}
					

				
			}
			
			searchFellowChildVisited(tree, position, id);	
		}	
		//System.out.println("failure");
		
	}

	
	private static void printChoices()
	{
		for(Position<Vertex<Choice>> p : vertexPath)
		{
			
			System.out.println(p.element().getValue().toString() + "\n");
		}
	}
	
	private static void shortestPath(Position<Vertex<Choice>> lastPosition) throws Exception
	{
		

		Iterator<Position<Vertex<Choice>>> iterator = tree.children(lastPosition);
		
		while(iterator.hasNext())
		{
			Vertex<Choice>>> childPosition 
		}
		if(!vertexPath.isEmpty())
		{
			
			Position<Vertex<Choice>> lastVertex = vertexPath.get(vertexPath.size()-1);
			
		}

	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-04-19 12:54:27.951
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-04-19 12:54:27.952
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-19 12:54:30.352
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------


import java.util.ArrayList;
import java.util.Iterator;

import com.jwetherell.algorithms.data_structures.Graph;
import com.jwetherell.algorithms.data_structures.Graph.Vertex;

import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.TextArea;
import javafx.scene.input.MouseDragEvent;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.Pane;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Line;
import javafx.scene.shape.Polygon;
import javafx.scene.shape.Shape;
import javafx.stage.Stage;
import javafx.stage.StageStyle;

public class GraphPane extends StackPane
{
	static Pane pane;
	static int total;
	static TextArea txtTotal;
	static TextArea txtDisplay;
	static GridPane gridPane;
	static GraphPane graphPane;
	static Tree<Vertex<Choice>> tree;
	static Position<Vertex<Choice>> root;
	static ScrollPane scrollPane;
	
	static ArrayList<Position<Vertex<Choice>>> vertexPath = new ArrayList<Position<Vertex<Choice>>>();
	static ArrayList<Button> choicePath = new ArrayList<Button>();
	static int choiceNumber = -1;
	
	public GraphPane()
	{
		
		graphPane = this;
		gridPane = new GridPane();
		//setting vbox/controls
		VBox vbox = new VBox();
		vbox.setMaxSize(800, 800);
		//setting pane/graph
		pane = new Pane();
		pane.setPrefSize(2000, 2000);
		
		//scrollpane
		scrollPane = new ScrollPane();
		scrollPane.setContent(pane);
		scrollPane.setPrefSize(600, 600);
		//adding both to main borderpane for layout



		
		//adding controls to vbox
		Label lblTotal = new Label("Total:");
		txtTotal = new TextArea();
		txtTotal.setPrefSize(getPrefWidth(), 20);
		
		Label lblDisplay = new Label("Display:");
		txtDisplay = new TextArea();
		txtDisplay.setPrefSize(getPrefWidth(), 20);
		
		//add buttons
		
		Button btnGoBack = new Button("Go Back One Choice");
		btnGoBack.setPrefSize(200, 30);
		
		Button btnDisplayChoices = new Button("Display Current Choices Info");
		btnDisplayChoices.setPrefSize(200, 30);


		
		gridPane.add(lblTotal, 0, 0);
		gridPane.add(txtTotal, 0, 1);
		gridPane.add(lblDisplay, 0, 2);
		gridPane.add(txtDisplay, 0, 3);
		gridPane.add(btnGoBack, 0, 4);
		gridPane.add(btnDisplayChoices, 1, 4);
		
		vbox.getChildren().add(gridPane);
		vbox.getChildren().add(scrollPane);
		
		this.getChildren().add(vbox);
		
		//generate tree and fill it
		ModifyTree modifyTree = new ModifyTree();
		
		tree = modifyTree.getTree();
		root = modifyTree.getRoot();
		
		try 
		{
			displayNodes(tree, root);
			displayEdge(tree, root);
			//System.out.println(tree.preOrderElementTraversal(tree, root));
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		//set buttons actipns
		
		btnGoBack.setOnAction(new EventHandler <ActionEvent>()
		{
			@Override
			public void handle(ActionEvent event) 
			{
				goBack();
			}		
		});
		
		btnDisplayChoices.setOnAction(new EventHandler <ActionEvent>()
		{
			@Override
			public void handle(ActionEvent event) 
			{
				//shortestPath();
				printChoices();
			}		
		});
		

		////
		
	}
	
	public static void goBack()
	{
		
		//if choice exists
		if(choiceNumber > -1)
		{
			//go back one on button
			Button button = choicePath.get(choiceNumber);
			button.setTextFill(null);
			button.setStyle("-fx-background-color: BLACK");
			System.out.println(button.getText());
			//go back on 
			Position<Vertex<Choice>> vertex = vertexPath.get(choiceNumber);
			vertex.element().getValue().setDisplayed(false);
			vertex.element().getValue().setVisited(false);
			
			//now get rid of button and vertex from list
			vertexPath.remove(choiceNumber);
			choicePath.remove(choiceNumber);
			
			total -= vertex.element().getWeight();
			txtTotal.setText("R"+total);
			choiceNumber--;
			
			
		}else
		{
			graphPane.setVisible(false);
			//go to error pane
			ErrorPane root = new ErrorPane("ERROR: There is no node selected to undo.", graphPane);
			Stage secondStage = new Stage();
			
			//secondStage.initStyle(StageStyle.UNDECORATED);
	        secondStage.setScene(new Scene(root));
	        secondStage.setTitle("Error");
	        secondStage.show();
	        return;
		}

	}
	
	public void addToPath(Position<Vertex<Choice>> elem,Button button)
	{
		vertexPath.add(elem);
		choicePath.add(button);
		choiceNumber++;
		
		total += elem.element().getWeight();
		txtTotal.setText("R"+total);
	}
	
	final static int nodeSize = 50;
	final static int edgeSize = 50;
	public static void addNode(int x, int y, Position<Vertex<Choice>> elem)
	{
		
		Button button = new Button(""+elem.element().getValue().getID());
		button.setShape(new Circle(10));
		button.setPrefSize(nodeSize,nodeSize);
		button.setLayoutX(x);
		button.setLayoutY(y);
		button.setTextFill(null);
		button.setStyle("-fx-background-color: BLACK");
		
		Label lblName = new Label(elem.element().getValue().getName());
		lblName.setLayoutX(x);
		lblName.setLayoutY(y-15);
		
		pane.getChildren().add(lblName);
		pane.getChildren().add(button);
		

		button.setOnAction(new EventHandler <ActionEvent>()
		{
			
			@Override
			public void handle(ActionEvent event) 
			{
				//total += elem;
				txtTotal.setText(""+total);
				graphPane.setVisible(false);
				
				//this is to search if parent has been visisted
				searchResult = false;
				//this is to search if a fellow child has been visited
				searchChildResult = true;
				try 
				{
					searchParentVisited(tree,  root, Integer.parseInt(button.getText()));
					searchFellowChildVisited(tree,  root, Integer.parseInt(button.getText()));
	
				} catch (Exception e) 
				{
					e.printStackTrace();
				}
				
				
				//if parent not visited yet
				if(!searchResult)
				{
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: Parent of Choice not selected yet.", graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
			        return;
					
				}else
				if(!searchChildResult)//now check if a fellow child has already been chosen
				{
								
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: You cannot choose more than one choice at the same depth", graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
			        return;
					
					
				}else
				if(button.getTextFill() == null)//if button viable
				{
					//opens main menu
					InfoPane root = new InfoPane(elem, button, graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Info");
			        secondStage.show();
					
				}else
				if(button.getTextFill().equals(Color.BLUE))//if buttons already been selected
				{
					//go to error pane
					ErrorPane root = new ErrorPane("ERROR: This option has already been selected.", graphPane);
					Stage secondStage = new Stage();
					
					//secondStage.initStyle(StageStyle.UNDECORATED);
			        secondStage.setScene(new Scene(root));
			        secondStage.setTitle("Error");
			        secondStage.show();
				}else
				{

					
				}
			}			
		});
	}
	
	public static void addEdge(int xP, int yP,int x, int y, Position<Vertex<Choice>> choice, int arrowPlacement)
	{	

		int posChange = 30;
		int midpointX = (xP+x+2*posChange)/2;
		int midpointY = (yP+y+2*posChange)/2;
		//System.out.println(xP +"-"+yP+"-"+x+"-"+y);
		//create line/edge from start to end
		Line line = new Line(xP+posChange, yP+posChange, x+posChange, y+posChange);
		Label lblWeight = new Label(""+choice.element().getWeight());
		lblWeight.setLayoutX(midpointX);
		lblWeight.setLayoutY(midpointY);
		
		//create directional arrow on line
		//Line arrowUp = new Line(x+15, y+25, x+30, y+30);
		//Line arrowDown = new Line(x+25, y+15, x+30, y+30);
		

		//if(xP != x && yP != y)
		{
			if(arrowPlacement > choice.element().getValue().getArrow())//upper bound
			{
				Polygon polygon = new Polygon();
		        polygon.getPoints().addAll(new Double[]{
		        		(double) (midpointX-15),(double) midpointY+10,
		        		(double) midpointX,(double) midpointY+15,
		        		(double) midpointX, (double) midpointY,
		        });

				pane.getChildren().add(polygon);

	
			}else
			if(arrowPlacement == choice.element().getValue().getArrow())//middle bound
			{

				Polygon polygon = new Polygon();
		        polygon.getPoints().addAll(new Double[]{
		        		(double) (midpointX-20),(double) midpointY-10,
		        		(double) midpointX,(double) midpointY,
		        		(double) midpointX-20, (double) midpointY+10,
		        });

				pane.getChildren().add(polygon);
				
			}else
			if(arrowPlacement < choice.element().getValue().getArrow())//lower bound
			{
				
				Polygon polygon = new Polygon();
		        polygon.getPoints().addAll(new Double[]{
		        		(double) (midpointX),(double) midpointY-20,
		        		(double) midpointX,(double) midpointY,
		        		(double) midpointX-20, (double) midpointY-10,
		        });

				pane.getChildren().add(polygon);
			}
		}
		//add line to pane
		//pane.getChildren().add(arrowUp);
		//pane.getChildren().add(arrowDown);
		pane.getChildren().add(line);
		pane.getChildren().add(lblWeight);
	}
	

	static int loop = 0;
	static int iteration = 1;
	static boolean endFound = false;

	private static void displayNodes(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice) throws Exception 
	{
		
		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);

		if(tree.parent(choice).get(0) == null)
		{
			choice.element().getValue().setX(0);
			choice.element().getValue().setY((int)scrollPane.getPrefHeight()/2);
			choice.element().getValue().setArrow(0);
			
			addNode(0, choice.element().getValue().getY(), choice);
		}
		
		while(iterator.hasNext())
		{
			//counts at which child you are currently at
			loop++;
			
			if(loop==3)
			{
				loop = 1;
			}
			
			Position<Vertex<Choice>> position = iterator.next();
			
			if(position.element().getValue().getDisplayed())
			{
				//System.out.println(position.toString() +"    ddddddd");
			}	
			else
			{
			
			//get depth which is the x axis
			int depth = tree.depth(tree, position);
			
			//calcuate y
			double numChild = tree.getNumChildren(tree.parent(position).get(0));


			
			int parentChoice = 0;
			//determines how a child of one parents should look

			if(tree.parent(position).size() == 1)
			{
				parentChoice = 0;
			}else
			if(tree.parent(position).size() % 2 == 0)//determines how a child of many parents should look - if even
			{
					parentChoice = tree.getNumChildren(tree.parent(position).get(0))/2;
					
				}else//determines how a child of many parents should look - if odd
				{
					
					parentChoice = (int)(tree.getNumChildren(tree.parent(position).get(0))/2+0.5);
					
				}
				
				//this is the # in order ofwhen the child was added to a parent
				int childNum = position.element().getValue().getChildNum();
				if(numChild <= 1)
				{
					
					position.element().getValue().setY(root.element().getValue().getY());
					position.element().getValue().setArrow(0);
				}
				else
				if(numChild/2 >= childNum || childNum==1)//in lower bound of loop
				{
					
					//set above parent
					position.element().getValue().setY(tree.parent(position).get(0).element().getValue().getY()-200/childNum);
					position.element().getValue().setArrow(-1);
					
				}else
				if(numChild/2 == childNum || numChild/2 == childNum-0.5)//at centre of loop
				{
	
					//set same as parent Y axis
					position.element().getValue().setY(tree.parent(position).get(0).element().getValue().getY());
					position.element().getValue().setArrow(0);
	
				}else
				{
					if((numChild+1-childNum) <= 0)
					{
						//set below parent
						position.element().getValue().setY((int)(tree.parent(position).get(0).element().getValue().getY()+200/(-numChild+1+childNum)));
						position.element().getValue().setArrow(1);
					}else
					{
						//set below parent
						position.element().getValue().setY((int)(tree.parent(position).get(0).element().getValue().getY()+200/(numChild+1-childNum)));
						position.element().getValue().setArrow(1);
					}
					
					
				}
						
	
				/*if(position.element().getValue().getID() == 7)
				{
					System.out.println("numPdasdasasdsad "+ tree.parent(position).size());
				}*/
				
				position.element().getValue().setX(depth*100);
				if(position.element().getValue().getY() > 1000)
				{
					System.out.println("\nID " + position.element().getValue().getID()+"   X: "+ position.element().getValue().getX()+"   Y: "+position.element().getValue().getY());
					System.out.println("loop " + loop+"   numChild: "+numChild+"\n");
				}
				
				
				//add nodes
				addNode(position.element().getValue().getX(), position.element().getValue().getY(),position);
				position.element().getValue().setDisplayed(true);
				//add all edges - can have many parents
				/*
				if(tree.getNumChildren(position) == 0)
				{
					loop = 0;
					endFound = true;
					iteration++;
				}*/
			}
			

			
			displayNodes(tree, position);
			
		}
		
	}
	
	
	
	private static void displayEdge(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice) throws Exception 
	{
		
		
		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);
		
		while(iterator.hasNext())
		{	
			Position<Vertex<Choice>> position = iterator.next();
			
			Iterator<Position<Vertex<Choice>>> iteratorC = tree.children(position);
			//to add root
			if(tree.parent(choice).get(0) == null)
			{

				addEdge(position.element().getValue().getX(),position.element().getValue().getY(),choice.element().getValue().getX(),choice.element().getValue().getY(),position,choice.element().getValue().getArrow());
			}
			
			while(iteratorC.hasNext())
			{		
				Position<Vertex<Choice>> c = iteratorC.next();
				addEdge(c.element().getValue().getX(),c.element().getValue().getY(),position.element().getValue().getX(),position.element().getValue().getY(),c,position.element().getValue().getArrow());
			}
			
				displayEdge(tree, position);
			
		}
		
	}

	static boolean searchResult;
	private static void searchParentVisited(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice, int id) throws Exception 
	{
		if(searchResult)
		{
			return;
		}
		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);
		//checks if root
		/*if(tree.parent(choice).get(0) == null)
		{
			//checks if root is search id
			if(id == root.element().id)
			{
				searchResult = true;
				return;
			}
		}*/
		
		while(iterator.hasNext())
		{
			if(searchResult)
			{
				return;
			}
			
			if(id == root.element().getValue().getID())
			{
				searchResult = true;
				return;
			}

			Position<Vertex<Choice>> position = iterator.next();
			
			//checks if correct node is found
			
			
			
			if(id == position.element().getValue().getID())
			{
				

				//checks if parent node has been visited before

				for(Position<Vertex<Choice>> c : tree.parent(position))
				{
					//searchResult = c.element().getVisited();

					if(c.element().getValue().getVisited())
					{
						searchResult = true;
						return;
					}
				}
				
			}
			
			searchParentVisited(tree, position, id);	
		}	
	}
	
	static boolean searchChildResult;
	private static void searchFellowChildVisited(Tree<Vertex<Choice>> tree, Position<Vertex<Choice>> choice, int id) throws Exception 
	{

		Iterator<Position<Vertex<Choice>>> iterator = tree.children(choice);
		//checks if root
		if(tree.parent(choice).get(0) == null)
		{
			//checks if root is search id
			if(id == root.element().getValue().getID())
			{
				//System.out.println("root found");
				searchChildResult = true;
				return;
			}
		}
		
		while(iterator.hasNext())
		{
			
			Position<Vertex<Choice>> position = iterator.next();
			//checks if correct node is found
			if(id == position.element().getValue().getID())
			{

				//goes over all children of that paren
				Iterator<Position<Vertex<Choice>>> iteratorChild = tree.children(tree.parent(position).get(0));
				
				while(iteratorChild.hasNext())
				{
					
					Position<Vertex<Choice>> positionChild = iteratorChild.next();
					//System.out.println(positionChild.element().getID() + "  "+ positionChild.element().getVisited());
					//if child visited, return false
					if(positionChild.element().getValue().getVisited())
					{
						searchChildResult = false;
						return;
					}
				}
					

				
			}
			
			searchFellowChildVisited(tree, position, id);	
		}	
		//System.out.println("failure");
		
	}

	
	private static void printChoices()
	{
		for(Position<Vertex<Choice>> p : vertexPath)
		{
			
			System.out.println(p.element().getValue().toString() + "\n");
		}
	}
	
	private static void shortestPath(Position<Vertex<Choice>> lastPosition) throws Exception
	{
		

		Iterator<Position<Vertex<Choice>>> iterator = tree.children(lastPosition);
		
		while(iterator.hasNext())
		{
			Position<Vertex<Choice>>> childPosition 
		}
		if(!vertexPath.isEmpty())
		{
			
			Position<Vertex<Choice>> lastVertex = vertexPath.get(vertexPath.size()-1);
			
		}

	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3504)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3087)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:540)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

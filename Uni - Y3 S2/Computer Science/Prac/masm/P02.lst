Microsoft (R) Macro Assembler Version 6.11		    08/03/23 15:05:52
src\P02.asm						     Page 1 - 1


				;	Author:     221003350 Ariel Sischy
				;	Computer Science 3B - P02
				.386
				.MODEL FLAT ; Flat memory model
				.STACK 4096 ; 4096 bytes

				INCLUDE io.inc ; Directive to use the IO Library
			      C ;
			      C ; Simple I/O Routines - Version 2
			      C ;
			      C 
			      C IFNDEF IO_INC
 = 1			      C IO_INC equ <1>
			      C 
			      C OutputStr PROTO NEAR32 STDCALL :DWORD
			      C OutputInt PROTO NEAR32 STDCALL :DWORD
			      C OutputFloat PROTO NEAR32 STDCALL :DWORD
			      C OutputFloat8 PROTO NEAR32 STDCALL :QWORD
			      C InputInt PROTO NEAR32 STDCALL
			      C InputStr PROTO NEAR32 STDCALL :DWORD, :DWORD
			      C 
			      C ELSE
			      C ENDIF
			      C 

				; Exit function
				ExitProcess PROTO NEAR32 stdcall, dwExitCode:DWORD

				; The data section stores all global variables
 00000000			.DATA

				;String input messages
 00000000 50 6C 65 61 73	strInputA0 BYTE "Please enter A0:",0
	   65 20 65 6E 74
	   65 72 20 41 30
	   3A 00
 00000011 50 6C 65 61 73	strInputA1 BYTE "Please enter A1:",0
	   65 20 65 6E 74
	   65 72 20 41 31
	   3A 00

 00000022 50 6C 65 61 73	strInputW0 BYTE "Please enter W0:",0
	   65 20 65 6E 74
	   65 72 20 57 30
	   3A 00
 00000033 50 6C 65 61 73	strInputW1 BYTE "Please enter W1:",0
	   65 20 65 6E 74
	   65 72 20 57 31
	   3A 00

 00000044 50 6C 65 61 73	strInputExit BYTE "Please enter 0 to exit, or 1 to continue:",0
	   65 20 65 6E 74
	   65 72 20 30 20
	   74 6F 20 65 78
	   69 74 2C 20 6F
	   72 20 31 20 74
	   6F 20 63 6F 6E
	   74 69 6E 75 65
	   3A 00

 0000006E 54 68 65 20 6D	strOutputMax BYTE "The max is: ",0
	   61 78 20 69 73
	   3A 20 00
				;A and W input variablesS
 0000007B 00000000		A0 DWORD ?
 0000007F 00000000		A1 DWORD ?
 00000083 00000000		W0 DWORD ?
 00000087 00000000		W1 DWORD ?

				;OUTPUT
 0000008B 00000000		maxFeature DWORD ?



 00000000			.CODE
 00000000			_start:
 00000000				
					;get variables while exiting loop
 00000000  B9 00000001			MOV ecx, 1
 00000005			whileLoopCondition:
					;if exit has been specified, exit loop
 00000005  83 F9 00			CMP ecx, 0
 00000008  74 63			JZ whileLoopEnd

 0000000A			whileLoopBody:

					;Msg asking while A0 input from user
					INVOKE OutputStr, ADDR strInputA0
					INVOKE InputInt
 00000019  A3 0000007B R		MOV A0, eax

					;Msg asking while A1 input from user
					INVOKE OutputStr, ADDR strInputA1
					INVOKE InputInt
 0000002D  A3 0000007F R		MOV A1, eax

					;Msg asking while W0 input from user
					INVOKE OutputStr, ADDR strInputW0
					INVOKE InputInt
 00000041  A3 00000083 R		MOV W0, eax

					;Msg asking while W1 input from user
					INVOKE OutputStr, ADDR strInputW1
					INVOKE InputInt
 00000055  A3 00000087 R		MOV W1, eax

					;Msg asking to exit loop
					INVOKE OutputStr, ADDR strInputExit
					INVOKE InputInt
 00000069  8B C8			MOV ecx, eax


 0000006B  EB 98			JMP whileLoopCondition ;jump to start of loop

 0000006D			whileLoopEnd:

					;divide A0 by W0
 0000006D  A1 0000007B R		MOV eax, A0
 00000072  8B 1D 00000083 R		MOV ebx, W0
 00000078  99				CDQ
 00000079  F7 FB			IDIV ebx

					;check if remainder is 0
 0000007B  83 FA 00			CMP edx, 0 
 0000007E  74 01			JZ notZeroCheck0

					;if not zero, increment by 1
 00000080  40				INC eax
 00000081			notZeroCheck0:
 00000081  8B C8			MOV ecx, eax ; store eax in ecx



					;divide A1 by W1
 00000083  A1 0000007F R		MOV eax, A1
 00000088  8B 1D 00000087 R		MOV ebx, W1
 0000008E  99				CDQ
 0000008F  F7 FB			IDIV ebx

					;check if remainder is 0
 00000091  83 FA 00			CMP edx, 0 
 00000094  74 01			JZ notZeroCheck1

					;if not zero, increment by 1
 00000096  40				INC eax
 00000097			notZeroCheck1:
 00000097  8B D0			MOV edx, eax

					;now compare which is the max
 00000099  3B CA			CMP ecx, edx
					
 0000009B  79 02			JNS sumZeroOrBigger
					;then edx is max
 0000009D  EB 04			JMP edxIsBigger

 0000009F				sumZeroOrBigger:
 0000009F  75 0A			JNZ ecxIsBigger;handles if both equal... not needed
 000000A1  EB 08			JMP ecxIsBigger;jump to where ecx is bigger


 000000A3				edxIsBigger:; where edx is bigger
 000000A3  89 15 0000008B R		MOV maxFeature, edx
 000000A9  EB 06			JMP goToEnd

 000000AB				ecxIsBigger: ; where ecx is bigger
 000000AB  89 0D 0000008B R		MOV maxFeature, ecx

 000000B1				goToEnd:
					INVOKE OutputStr, ADDR strOutputMax ;output max
					INVOKE OutputInt, maxFeature


					INVOKE ExitProcess, 0
 000000CD			Public _start
				END
Microsoft (R) Macro Assembler Version 6.11		    08/03/23 15:05:52
src\P02.asm						     Symbols 2 - 1




Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

FLAT . . . . . . . . . . . . . .	GROUP
STACK  . . . . . . . . . . . . .	32 Bit	 00001000 DWord	  Stack	  'STACK'	 
_DATA  . . . . . . . . . . . . .	32 Bit	 0000008F DWord	  Public  'DATA'	
_TEXT  . . . . . . . . . . . . .	32 Bit	 000000CD DWord	  Public  'CODE'	


Procedures,  parameters and locals:

                N a m e                 Type     Value    Attr

$$$$$$00001  . . . . . . . . . .	P Near	 00000000 _TEXT	Length= 000000CD Private
  whileLoopCondition . . . . . .	L Near	 00000005 _TEXT	
  whileLoopBody  . . . . . . . .	L Near	 0000000A _TEXT	
  whileLoopEnd . . . . . . . . .	L Near	 0000006D _TEXT	
  notZeroCheck0  . . . . . . . .	L Near	 00000081 _TEXT	
  notZeroCheck1  . . . . . . . .	L Near	 00000097 _TEXT	
  sumZeroOrBigger  . . . . . . .	L Near	 0000009F _TEXT	
  edxIsBigger  . . . . . . . . .	L Near	 000000A3 _TEXT	
  ecxIsBigger  . . . . . . . . .	L Near	 000000AB _TEXT	
  goToEnd  . . . . . . . . . . .	L Near	 000000B1 _TEXT	
ExitProcess  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
InputInt . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
InputStr . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OutputFloat8 . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OutputFloat  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OutputInt  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OutputStr  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL


Symbols:

                N a m e                 Type     Value    Attr

@CodeSize  . . . . . . . . . . .	Number	 00000000h   
@DataSize  . . . . . . . . . . .	Number	 00000000h   
@Interface . . . . . . . . . . .	Number	 00000000h   
@Model . . . . . . . . . . . . .	Number	 00000007h   
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . .	Text   	 FLAT
@fardata?  . . . . . . . . . . .	Text   	 FLAT
@fardata . . . . . . . . . . . .	Text   	 FLAT
@stack . . . . . . . . . . . . .	Text   	 FLAT
A0 . . . . . . . . . . . . . . .	DWord	 0000007B _DATA	
A1 . . . . . . . . . . . . . . .	DWord	 0000007F _DATA	
IO_INC . . . . . . . . . . . . .	Text   	 1
W0 . . . . . . . . . . . . . . .	DWord	 00000083 _DATA	
W1 . . . . . . . . . . . . . . .	DWord	 00000087 _DATA	
_start . . . . . . . . . . . . .	L Near	 00000000 _TEXT	Public
ecxIsBigger  . . . . . . . . . .	L Near	 000000AB _TEXT	
edxIsBigger  . . . . . . . . . .	L Near	 000000A3 _TEXT	
goToEnd  . . . . . . . . . . . .	L Near	 000000B1 _TEXT	
maxFeature . . . . . . . . . . .	DWord	 0000008B _DATA	
notZeroCheck0  . . . . . . . . .	L Near	 00000081 _TEXT	
notZeroCheck1  . . . . . . . . .	L Near	 00000097 _TEXT	
strInputA0 . . . . . . . . . . .	Byte	 00000000 _DATA	
strInputA1 . . . . . . . . . . .	Byte	 00000011 _DATA	
strInputExit . . . . . . . . . .	Byte	 00000044 _DATA	
strInputW0 . . . . . . . . . . .	Byte	 00000022 _DATA	
strInputW1 . . . . . . . . . . .	Byte	 00000033 _DATA	
strOutputMax . . . . . . . . . .	Byte	 0000006E _DATA	
sumZeroOrBigger  . . . . . . . .	L Near	 0000009F _TEXT	
whileLoopBody  . . . . . . . . .	L Near	 0000000A _TEXT	
whileLoopCondition . . . . . . .	L Near	 00000005 _TEXT	
whileLoopEnd . . . . . . . . . .	L Near	 0000006D _TEXT	

	   0 Warnings
	   0 Errors
